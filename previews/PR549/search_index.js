var documenterSearchIndex = {"docs":
[{"location":"dev_guide/auto_generation/#Auto-Generation-of-Component-Structs","page":"Auto-Generation of Component Structs","title":"Auto-Generation of Component Structs","text":"InfrastructureSystems.jl provides a mechanism to auto-generate Julia files containing structs and field accessor functions from JSON descriptors. Here are reasons to consider using this approach:\n\nAuto-generation allows for easy refactoring of code. Adding fields to many structs can be tedious because you might have to edit many constructors. This process eliminates boiler-plate edits.\nThe JSON descriptor format includes a mechanism to define range validation on component fields. Validation can be enabled when adding components to a system.\nProvides consistent formatting of structs, fields, and constructors.\nProvides consistent documentation of structs and fields.","category":"section"},{"location":"dev_guide/auto_generation/#Instructions","page":"Auto-Generation of Component Structs","title":"Instructions","text":"Refer to the docstrings for generate_struct and generate_structs and generate the files from the REPL.\n\nOr\n\nCreate or modify the JSON descriptor file. Follow the PowerSystems.jl example.\nRun the generation script, passing your descriptor file and an output directory.\n\nInfrastructureSystems.generate_structs(\n    \"./src/descriptors/power_system_structs.json\",\n    \"./src/models/generated\",\n)","category":"section"},{"location":"dev_guide/auto_generation/#Struct-Descriptor-Rules","page":"Auto-Generation of Component Structs","title":"Struct Descriptor Rules","text":"Each struct descriptor must define the following fields:\n\nstruct_name: Name of struct\ndocstring: The docstring of the struct\nfields: Array of struct members. See below for requirements.\nsupertype: Declare the struct with this parent type.\n\nRequired fields for each struct member:\n\nname: Name of field\ndata_type: Type of field\n\nOptional fields for each struct member:\n\naccessor_module: Set this if the getter/setter functions are reimplementing a method defined in a different module.\ncomment: Field comment\ndefault: The constructors will define this as a default value.\nexclude_setter: Do not generate a setter function for this field.\ninternal_default: Set to true for non-user-facing fields like InfrastructureSystemsInternal that have default values.\nneeds_conversion: Set to true if the getter and setter function needs to apply unit conversion. The type must implement\nget_value(::InfrastructureSystemsComponent, ::Type) and\nset_value(::InfrastructureSystemsComponent, ::Type) for this combination of component type and member type.\nnull_value: Value to indicate the value is null, such as 0.0 for floating point numbers. If all members in the struct define this field then a \"demo\" constructor will be generated. This allows you to enter val = MyType(nothing) in the REPL and see the layout of a struct without worrying about valid values.\nvalid_range: Define this as a Dict with min and max and InfrastructureSystems.jl will validate any value against that range when you add the component to the system. Use null if one doesn't apply, such as if there is no max limit.\nvalidation_action: Define this as error or warn. If it is error then InfrastructureSystems.jl will raise an exception if the validation code detects a problem. Otherwise, it will log a warning.\n\nNotes:\n\nYou will need to decide how to manage the generated files. The Sienna packages keep the generated code in the git repository. This is not required. You could choose to generate them at startup.\nYou may need to create custom constructors and this approach will not allow you to put them in the same file as the struct definition.","category":"section"},{"location":"docs_best_practices/explanation/#Explanation","page":"Explanation","title":"Explanation","text":"","category":"section"},{"location":"docs_best_practices/explanation/#History-and-Motivation","page":"Explanation","title":"History and Motivation","text":"During the first phase of Sienna's (previously SIIP's) development, Sienna used a 3-part documentation organization, based on the expected needs of different user personas:\n\nModeler: Users that want to use existing functionality\nModel Developer: Users that want to develop custom structs, components, models, and/or workflows\nCode Base Developers: Users that want to add new core functionalities or fix bugs in the core capabilities\n\nHowever, as Sienna's user base has expanded, it has become apparent that this previous organization is no longer serving. As of 2024, a new effort is underway to clean up and re-organize the Sienna documentation according to the 4-part Diataxis framework, a well-established, systematic approach to technical documentation split up into:\n\nTutorials\nHow-to guides\nReference\nExplanation\n\nIn addition, the current documentation has multiple quality issues, including misformatted text, broken reference links, and documentation that has been written but is not visible to users in the API (\"missing docstrings\"). While the style guide has been available, the guide focuses primarily on the style of code itself, without providing clear guidelines and best practices for other parts of the documentation besides docstrings. In addition, the first stage of Sienna's development coincided with the initial development of the Documenter.jl package. Early versions of Sienna's packages were documented requiring Documenter.jl v0.27, and in the meantime, Documenter.jl has released its v1.0 and onwards, which contain much more rigorous checks for documentation quality. Sienna's packages have not kept up with these improvements.","category":"section"},{"location":"docs_best_practices/explanation/#Purpose-of-the-Documentation-Best-Practices","page":"Explanation","title":"Purpose of the Documentation Best Practices","text":"We aim to remedy the historical issues above through a concerted clean up and re-organization effort and compliance with Documenter.jl >v1.0's quality control checks, following these best practice guidelines. These guidelines are not intended to reiterate Diataxis, beyond regularly reminding contributers to refer to them â€“ and contributers should read the Diataxis website in its entirety before getting started. Instead, the best practices are intended to bridge the gap where there are Julia- or Sienna-specific recommendations, either to consistently implement the Diataxis framework or to highlight common documentation issues throughout the Sienna packages that need to be addressed as part of our concerted clean-up effort.","category":"section"},{"location":"docs_best_practices/how-to/troubleshoot/#Troubleshoot-Common-Errors","page":"Troubleshoot Common Errors","title":"Troubleshoot Common Errors","text":"","category":"section"},{"location":"docs_best_practices/how-to/troubleshoot/#miss_doc","page":"Troubleshoot Common Errors","title":"Error: ## docstrings not included in the manual","text":"Problem: Docstrings have been written, but have not been properly mapped to either a public or internal API. There may be multiple issues to iterate through:\n\nVerify there is an Internal API .md file to catch doctrings for structs/functions that are not exported. Example here\nIdentify the *.jl file for one of your missing docstrings. Are other docstrings in that file visible in the compiled API .html?\nYES: Check whether those other docstrings are listed in the Public API .md file in a @docs block. Either:\nAdd the missing struct/function names to an appropriate @docs block in the API .md if it is manually organized. See below if this creates a no docs found error.\nPreferrably, switch to @autodocs with the *.jl file as one of its Pages instead.\nNo: add a new @autodocs block in the Public API .md file with that *.jl file as one of its Pages.\nAre these docstrings from InfrastructureSystems.jl? Follow how-to selectively export docstrings from InfrastructureSystems.jl.","category":"section"},{"location":"docs_best_practices/how-to/troubleshoot/#no_docs","page":"Troubleshoot Common Errors","title":"Error: no docs found for SomeFunction or [:docs_block] error","text":"No docstring has been written for SomeFunction. Find the *.jl file containing SomeFunction and add a docstring.","category":"section"},{"location":"docs_best_practices/how-to/troubleshoot/#Error:-duplicate-docs-found","page":"Troubleshoot Common Errors","title":"Error: duplicate docs found","text":"Example: Error: duplicate docs found for 'PowerSimulations.SimulationProblemResults' in src\\reference\\PowerSimulations.md\n\nProblem: The same .jl file has been found more than once by Documenter.jl, which matches based on the end of a file path.\n\nDetermine which file the function is located in\nExample: simulation_problem_results.jl for PowerSimulations.SimulationProblemResults\nCheck whether that file is listed more than once in an @autodocs Pages list in the API markdown file (e.g., PowerSimulations.md or public.md). Remove duplicates.\nAlso check for other files with the same partial ending in the @autodocs Pages lists in the API .md file. Specify more of that file path to distinguish it.\nExample: Change Pages = [\"problem_results.jl\"] to Pages = [\"operation/problem_results.jl\"]","category":"section"},{"location":"docs_best_practices/how-to/troubleshoot/#Parsing-error-for-input-from-JuliaFormatter","page":"Troubleshoot Common Errors","title":"Parsing error for input from JuliaFormatter","text":"Problem: JuliaFormatter 1.0 gives an uninformative error message when it can't parse something, with unhelpful line numbers. Common causes are something that is not proper Julia syntax inside a julia markdown block:\n\n```julia\nWhoops,\n```\n\nOr a single bracket in a markdown file:\n\n] add PowerSystems\n\nWorkarounds:\n\nAvoid the single bracket with alternatives:\n\nusing Pkg;\nPkg.add([\"PowerSystems\"]);\n\nIf you can't avoid it:\nRemove the text with single bracket (or other problem) temporarily\nRun the formatter once to format the rest of the file\nAdd the text back in\nAdd the ignore keyword argument with the file name to JuliaFormatter.format in scripts/formatter/formatter_code.jl to skip the file in the future:\n\nignore = [\"problem-file.md\"]\n\nYou might need to iterate through multiple files.","category":"section"},{"location":"docs_best_practices/how-to/troubleshoot/#ignore_errors","page":"Troubleshoot Common Errors","title":"How can I see the output even with errors?","text":"Sometimes the easiest way to diagnose an error is to look at the generated webpage locally.\n\nBy setting warnonly=true in makedocs at make.jl, you can temporarily disable errors and build regardless. This makes it easy to track down cross-reference errors by clicking a link and seeing what fails.\n\nWe do not allow warnonly=true to be used in production, so if used, this must be removed before a pull request is submitted. ","category":"section"},{"location":"dev_guide/retest_migration/#Migrating-Tests-to-ReTest.jl","page":"Migrating Tests to ReTest.jl","title":"Migrating Tests to ReTest.jl","text":"This guide describes how to migrate a test suite from the traditional Test.jl pattern to ReTest.jl, which enables interactive test execution and selective test running.","category":"section"},{"location":"dev_guide/retest_migration/#Why-ReTest.jl?","page":"Migrating Tests to ReTest.jl","title":"Why ReTest.jl?","text":"ReTest.jl provides several advantages over the standard Test.jl workflow:\n\nRun subsets of tests using regular expressions\nFaster iteration during development (no need to restart Julia)\nWorks with Revise.jl for automatic test reloading\nCompatible with standard ] test execution","category":"section"},{"location":"dev_guide/retest_migration/#Key-Migration-Steps","page":"Migrating Tests to ReTest.jl","title":"Key Migration Steps","text":"","category":"section"},{"location":"dev_guide/retest_migration/#1.-Create-a-Separate-Test-Module","page":"Migrating Tests to ReTest.jl","title":"1. Create a Separate Test Module","text":"The most important structural change is wrapping all tests in a dedicated module. This module encapsulates the test environment and makes tests reloadable.\n\nCreate a file like test/MyPackageTests.jl:\n\nmodule MyPackageTests\n\nusing ReTest  # IMPORTANT: Must be at the top, before other imports\nusing Logging\n# other imports\n\nimport MyPackage\n\n# Include supporting files\ninclude(\"common.jl\")\ninclude(\"test_helpers.jl\")\n\n# Include all test files\nfor filename in readdir(joinpath(@__DIR__))\n    if startswith(filename, \"test_\") && endswith(filename, \".jl\")\n        include(filename)\n    end\nend\n\nfunction run_tests(args...; kwargs...)\n    # Setup logging, run tests, cleanup\n    @time retest(args...; kwargs...)\nend\n\nexport run_tests\n\nend\n\nusing .MyPackageTests","category":"section"},{"location":"dev_guide/retest_migration/#2.-Import-Order-Matters","page":"Migrating Tests to ReTest.jl","title":"2. Import Order Matters","text":"Critical: using ReTest must appear at the top of your test module, before other imports. ReTest.jl needs to be loaded first so that its @testset macro is available when test files are included.\n\nmodule MyPackageTests\n\nusing ReTest  # First!\nusing Logging\nusing SomeOtherPackage\n\nend\n\nIf you import ReTest after other packages that use @testset, you may get unexpected behavior or errors.","category":"section"},{"location":"dev_guide/retest_migration/#3.-Include-All-Test-Files-in-the-Module","page":"Migrating Tests to ReTest.jl","title":"3. Include All Test Files in the Module","text":"The module must include all test files so they become part of the module's scope. A common pattern is to automatically discover and include files:\n\nfor filename in readdir(joinpath(BASE_DIR, \"test\"))\n    if startswith(filename, \"test_\") && endswith(filename, \".jl\")\n        include(filename)\n    end\nend\n\nYou can also include files explicitly if you need control over the order:\n\ninclude(\"test_core.jl\")\ninclude(\"test_utils.jl\")\ninclude(\"test_integration.jl\")","category":"section"},{"location":"dev_guide/retest_migration/#4.-Define-and-Export-run_tests","page":"Migrating Tests to ReTest.jl","title":"4. Define and Export run_tests","text":"The module should define a run_tests function that wraps retest() and handles any setup/teardown (like logging configuration). This function should forward arguments to retest() to enable pattern matching:\n\nfunction run_tests(args...; kwargs...)\n    # Optional: setup logging\n    @time retest(args...; kwargs...)\n    # Optional: cleanup\nend\n\nexport run_tests\n\nThe export makes run_tests available after using .MyPackageTests.","category":"section"},{"location":"dev_guide/retest_migration/#5.-Update-runtests.jl","page":"Migrating Tests to ReTest.jl","title":"5. Update runtests.jl","text":"The main test/runtests.jl file becomes minimal:\n\nusing MyPackage\n\ninclude(\"MyPackageTests.jl\")\nrun_tests()","category":"section"},{"location":"dev_guide/retest_migration/#Comparison:-Before-and-After","page":"Migrating Tests to ReTest.jl","title":"Comparison: Before and After","text":"","category":"section"},{"location":"dev_guide/retest_migration/#Before-(Traditional-Test.jl-Pattern)","page":"Migrating Tests to ReTest.jl","title":"Before (Traditional Test.jl Pattern)","text":"# test/runtests.jl\ninclude(\"includes.jl\")\n\nconst DISABLED_TEST_FILES = [\n# \"test_foo.jl\",\n]\n\nmacro includetests(testarg...)\n    # Complex macro to discover and include test files\nend\n\nfunction run_tests()\n    @time @testset \"Begin MyPackage tests\" begin\n        @includetests ARGS\n    end\nend\n\nrun_tests()\n\nIssues with this approach:\n\nCannot easily run a subset of tests interactively\nMust restart Julia to pick up test changes\nThe @includetests macro adds complexity","category":"section"},{"location":"dev_guide/retest_migration/#After-(ReTest.jl-Pattern)","page":"Migrating Tests to ReTest.jl","title":"After (ReTest.jl Pattern)","text":"# test/MyPackageTests.jl\nmodule MyPackageTests\n\nusing ReTest\n# other imports\n\n# Include all test files\nfor filename in readdir(joinpath(@__DIR__))\n    if startswith(filename, \"test_\") && endswith(filename, \".jl\")\n        include(filename)\n    end\nend\n\nfunction run_tests(args...; kwargs...)\n    @time retest(args...; kwargs...)\nend\n\nexport run_tests\n\nend\n\nusing .MyPackageTests\n\n# test/runtests.jl\nusing MyPackage\n\ninclude(\"MyPackageTests.jl\")\nrun_tests()","category":"section"},{"location":"dev_guide/retest_migration/#Interactive-Development-Setup","page":"Migrating Tests to ReTest.jl","title":"Interactive Development Setup","text":"For interactive test development, create a test/load_tests.jl file:\n\nusing Revise\n\nfunction recursive_includet(filename)\n    already_included = copy(Revise.included_files)\n    includet(filename)\n    newly_included = setdiff(Revise.included_files, already_included)\n    for (mod, file) in newly_included\n        Revise.track(mod, file)\n    end\nend\n\nrecursive_includet(\"MyPackageTests.jl\")\n\nThen in the REPL:\n\njulia> using TestEnv\njulia> TestEnv.activate()\njulia> include(\"test/load_tests.jl\")\njulia> run_tests()                    # Run all tests\njulia> run_tests(r\"test.*foo\")        # Run tests matching pattern\n\nSee Running Tests for more details on interactive test execution.","category":"section"},{"location":"dev_guide/components_and_container/#Managing-Components","page":"Managing Components","title":"Managing Components","text":"InfrastructureSystems.jl provides a common way of managing component structs in a system.","category":"section"},{"location":"dev_guide/components_and_container/#Type-hierachy","page":"Managing Components","title":"Type hierachy","text":"Make every component a subtype of InfrastructureSystemsComponent.","category":"section"},{"location":"dev_guide/components_and_container/#InfrastructureSystemsInternal","page":"Managing Components","title":"InfrastructureSystemsInternal","text":"Add this struct to every component struct.\n\nIt automatically creates a UUID for the component. This guarantees a unique way to identify the component.\nIt optionally provides an extension dictionary for user data. A user extending your package may want to use your struct but need one more field. Rather than create a new type they can add data to this ext object.","category":"section"},{"location":"dev_guide/components_and_container/#Instructions-to-implement-a-Component","page":"Managing Components","title":"Instructions to implement a Component","text":"Add the field to your struct. The constructor does not take any parameters.\n\nstruct MyComponent\n    internal::InfrastructureSystemsInternal\nend\n\n# Optional\nget_ext(c::MyComponent) = InfrastructureSystems.get_ext(c.ext)\nclear_ext!(c::MyComponent) = InfrastructureSystems.clear_ext(c.ext)\n\nImplement this function with true or false depending on whether your component type will support time series data. The default method returns false.\n\nsupports_time_series(::MyComponent) = true\n\nImplement this function with true or false depending on whether your component type will support supplemental attributes. The default method returns true.\n\nsupports_supplemental_attributes(::MyComponent) = true\n\nNotes:\n\nInfrastructureSystems.get_uuid with argument obj::InfrastructureSystemsComponent returns the component UUID.\nThe extension dictionary is not created until the first time get_ext is called.","category":"section"},{"location":"dev_guide/components_and_container/#Interface-requirements","page":"Managing Components","title":"Interface requirements","text":"Implement these methods for every struct.\n\nget_internal(c::MyComponent)::InfrastructureSystemsInternal\nget_name(c::MyComponent)::String\n\nIf the struct supports time series (default is false):\n\nsupports_time_series(::MyComponent) = true","category":"section"},{"location":"dev_guide/components_and_container/#Component-Container","page":"Managing Components","title":"Component Container","text":"InfrastructureSystems.jl provides the SystemData struct to store a collection of components.\n\nIt is recommended but not required that you include this struct within your own system struct for these reasons:\n\nProvides search and iteration with InfrastructureSystems.get_component and InfrastructureSystems.get_components for abstract and concrete types.\nEnforces name uniqueness within a concrete type.\nAllows for component field validation.\nEnables component JSON serialization and deserialization.","category":"section"},{"location":"dev_guide/components_and_container/#Instructions-on-how-to-use-the-SystemData-container","page":"Managing Components","title":"Instructions on how to use the SystemData container","text":"Add an instance of SystemData to your system struct.\nOptionally pass a component validation descriptor file to the constructor.\nOptionally pass time_series_in_memory = true to the constructor if you know that all time series data will fit in memory and want a performance boost.\nRedirect these function calls to your instance of SystemData.\n\nadd_component!\nremove_component!\nget_component\nget_components\nget_components_by_name\nadd_time_series!","category":"section"},{"location":"dev_guide/components_and_container/#Importing-InfrastructureSystems-methods","page":"Managing Components","title":"Importing InfrastructureSystems methods","text":"It is recommended that you perform redirection on methods that act on SystemData so that those methods don't show up in Julia help or in methods output. For example:\n\nget_time_series_resolution(sys::MySystem) =\n    InfrastructureSystems.get_time_series_resolution(sys.data)\n\nOn the other hand, it is recommended that you import methods that act on an InfrastructureSystemsComponent into your package's namespace so that you don't have to duplicate docstrings and perform redirection. For example:\n\nimport InfrastructureSystems: get_time_series","category":"section"},{"location":"docs_best_practices/how-to/requirements_checklist/#Complete-Basic-Requirements-Checklist","page":"Complete Basic Requirements Checklist","title":"Complete Basic Requirements Checklist","text":"Sienna packages should follow the Diataxis framework, be strictly compiled with Documenter.jl v1.0 or greater, and be automatically formatted with JuliaFormatter.jl.","category":"section"},{"location":"docs_best_practices/how-to/requirements_checklist/#For-New-Packages","page":"Complete Basic Requirements Checklist","title":"For New Packages","text":"The SiennaTemplate.jl Git repo has the required environments and formatting and documentation code. Start from this template.","category":"section"},{"location":"docs_best_practices/how-to/requirements_checklist/#For-Existing-Packages","page":"Complete Basic Requirements Checklist","title":"For Existing Packages","text":"Existing Sienna packages will need to be updated with these requirements, but these will only need to be addressed once:\n\nOrganize the top-level documentation to follow the Diataxis framework (plus a welcome page/section). This might be a significant undertaking. See:\nHow to Write a How-to Guide\nHow to Write a Tutorial\nHow to Organize APIs and Write Docstrings\nUpdate the Project.toml file in the docs/ folder to replace compat requirements of Documenter = \"0.27\" with Documenter = \"1.0\"\nUpdate the docs/make.jl file to call Documenter.makedocs without the warnonly kwarg (i.e., all errors caught by makedocs must be resolved before merging). See an example here.\nSee How-to Troubleshoot Common Errors if this results in a host of errors.\nUpdate the scripts/formatter/formatter_code.jl to format the markdown .md files in the docs/ folder, calling format() with the kwarg format_markdown = true. See these three links for examples of the updated lines.","category":"section"},{"location":"dev_guide/tests/#Running-Tests","page":"Running Tests","title":"Running Tests","text":"","category":"section"},{"location":"dev_guide/tests/#Standard-test-execution","page":"Running Tests","title":"Standard test execution","text":"Unit tests can be executed in the REPL by executing the following:\n\njulia> ] test","category":"section"},{"location":"dev_guide/tests/#Interactive-test-execution","page":"Running Tests","title":"Interactive test execution","text":"While developing code and tests it can be convenient to run a subset of tests. You can do this with a combination of TestEnv.jl and ReTest.jl.\n\nNote: Per recommendations from the developers of TestEnv.jl, install the package in your global julia environment. Do the same for Revise.jl.\n\n$ julia\njulia> ]\n(@v1.10) pkg> add TestEnv Revise\n\nStart the environment with the InfrastructureSystems.jl environment.\n\n$ julia --project\n\nLoad the test environment.\n\njulia> using TestEnv\njulia> TestEnv.activate()\n\nLoad the tests through ReTest.jl and Revise.jl.\n\njulia> include(\"test/load_tests.jl\")\n\nRun all tests.\n\njulia> run_tests()\n\nRun a subset of tests with a regular expression. This pattern matches multiple testset definitions. The run_tests function forwards all arguments and keyword arguments to ReTest.retest.\n\njulia> run_tests(r\"Test.*components\")\n\nRefer to the ReTest documentation for more information.","category":"section"},{"location":"dev_guide/tests/#Change-logging-levels","page":"Running Tests","title":"Change logging levels","text":"julia> InfrastructureSystems.make_logging_config_file(\"logging_config.toml\")\njulia> ENV[\"SIENNA_LOGGING_CONFIG\"] = \"logging_config.toml\"\n\nEdit the file to suit your preferences and rerun.\n\njulia> run_tests()\n\nNote that you can filter out noisy log groups in this file.","category":"section"},{"location":"dev_guide/tests/#Noisy-log-messages","page":"Running Tests","title":"Noisy log messages","text":"The unit test module appends a summary of all log message counts to the log file.  If a message is logged too frequently then consider tagging that message with maxlog=X to suppress it.","category":"section"},{"location":"docs_best_practices/how-to/write_docstrings_org_api/#Organize-APIs-and-Write-Docstrings","page":"Organize APIs and Write Docstrings","title":"Organize APIs and Write Docstrings","text":"Docstrings for all structs, methods, and functions belong in the public or internal APIs, organized under the Reference section in Diataxis organization. Refer to this page particularly while editing Sienna docstrings and APIs for guidance on common problems in our existing documentation.","category":"section"},{"location":"docs_best_practices/how-to/write_docstrings_org_api/#Prepare","page":"Organize APIs and Write Docstrings","title":"Prepare","text":"If you have not read Diataxis, first read it in its entirety.\nRefer back to the Diataxis Reference section while working.\nRead and follow Julia's guidance on Writing Documentation, which mainly applies to docstrings\nRead the sections on Documenter.jl's @docs block and @autodocs block, and follow the guidance below on using @autodocs wherever possible","category":"section"},{"location":"docs_best_practices/how-to/write_docstrings_org_api/#Follow-the-Do's-and-Don't's","page":"Organize APIs and Write Docstrings","title":"Follow the Do's and Don't's","text":"Julia and Documenter.jl's guidance above should be your main reference, but in addition, follow these do's and don't to avoid common pitfalls from previous versions of Sienna documentation:\n\nPages = [\"write_docstrings_org_api.md\"]\nDepth = 3:3","category":"section"},{"location":"docs_best_practices/how-to/write_docstrings_org_api/#Look-at-the-compiled-.html!","page":"Organize APIs and Write Docstrings","title":"Look at the compiled .html!","text":"tip: Do\nCompile regularly and look at the APIs\nCheck method signatures and argument lists are formatted correctly","category":"section"},{"location":"docs_best_practices/how-to/write_docstrings_org_api/#Ensure-All-Docstrings-Are-Located-in-the-APIs","page":"Organize APIs and Write Docstrings","title":"Ensure All Docstrings Are Located in the APIs","text":"tip: Do\nInclude a Public API markdown file for exported structs, functions, and methods, and an Internals API for private functions. See PowerSystems.jl for an example with a Public API organized with @autodocs (see next) or SiennaTemplate.jl for a basic template when starting a new package.\n\ntip: Do\nMigrate all existing Formulation Libraries and Model Libraries into the Public API.\n\ntip: Do\nIf you want to make a docstring visible outside of the API (e.g., in a tutorial), use a non-canonical reference.","category":"section"},{"location":"docs_best_practices/how-to/write_docstrings_org_api/#use_autodocs","page":"Organize APIs and Write Docstrings","title":"Automate Adding Docstrings in the Public API with @autodocs","text":"tip: Do\nUse @autodocs blocks in the Public API markdown file to automatically find all docstrings in a file. Example:## Variables\n```@autodocs\nModules = [SomeSiennaPackage]\nPages = [\"variables.jl\"]\nPublic = true\nPrivate = false\n```\n\nwarning: Don't\nManually list out the struts or methods on a topic in a @docs block, because that introduces more work whenever we add something new or make a change. Example:## Variables\n```@docs\nvariable1\nvariable2\n```Consider re-organizing code if need be, so all related functions are in the same file(s) (e.g., variables.jl).","category":"section"},{"location":"docs_best_practices/how-to/write_docstrings_org_api/#docs_from_is","page":"Organize APIs and Write Docstrings","title":"Selectively Export Docstrings from InfrastructureSystems.jl","text":"If you are working in another Sienna package (e.g., SomeSiennaPackage.jl) that imports and exports code from InfrastructureSystems.jl:\n\ntip: Do\nList the files containing necessary InfrastructureSystems.jl structs and methods in SomeSiennaPackage.jl's Public API markdown file, then explicitly filter by what SomeSiennaPackage.jl exports. Example:```@autodocs\nModules = [InfrastructureSystems]\nPages   = [\"production_variable_cost_curve.jl\", # examples\n            \"cost_aliases.jl\",\n        ]\nOrder = [:type, :function]\nFilter = t -> nameof(t) in names(SomeSiennaPackage)\n```\n\nwarning: Don't\nList InfrastructureSystems as one of the modules in Documenter.makedocs in the make.jl file. Documenter.jl will look to map all InfrastructureSystems.jl docstrings into the API, resulting in hundreds of missing docstring errors. Example:makedocs(;\n    modules = [SomeSiennaPackage, InfrastructureSystems],\n    format = Documenter.HTML(;\n        prettyurls = haskey(ENV, \"GITHUB_ACTIONS\"),\n        size_threshold = nothing),\n    sitename = \"SomeSiennaPackage.jl\",\n    pages = Any[p for p in pages],\n)","category":"section"},{"location":"docs_best_practices/how-to/write_docstrings_org_api/#Ensure-All-Docstrings-Have-a-Function-Signature-and-Arguments-List","page":"Organize APIs and Write Docstrings","title":"Ensure All Docstrings Have a Function Signature and Arguments List","text":"tip: Do\nCheck all exported docstrings have a function signature and detailed arguments list visible in the API when you compile it. Example:(Image: A docstring with function signature and args list)\n\nwarning: Don't\nLeave docstrings that just have a description unaddressed. Example:(Image: A single line docstring)","category":"section"},{"location":"docs_best_practices/how-to/write_docstrings_org_api/#Automate-Updating-Docstring-Arguments-Lists","page":"Organize APIs and Write Docstrings","title":"Automate Updating Docstring Arguments Lists","text":"This is not commonly done in Sienna yet, but a goal is to improve our use of DocStringExtensions.jl for automation:\n\ntip: Do\nUse DocStringExtensions.TYPEDFIELDS to automatically compile arguments lists. Example:\"\"\"\n    SomeSiennaStruct(arg1, arg2)\n\n# Arguments\n$(TYPEDFIELDS)\n\nThis is the docstring line.\n\"\"\"\nstruct SomeSiennaStruct <: OperationalCost\n    \"Documentation for argument 1\"\n    arg1::ProductionVariableCostCurve\n    \"Documentation for argument 2\"\n    arg2::Float64\nend\n\nwarning: Don't\nCopy and paste arguments lists into the docstring, which opens opportunity for out-of-date errors when arguments are added or reordered. Example:\"\"\"\n    SomeSiennaStruct(arg1, arg2)\n\nThis is the docstring line.\n\n# Arguments\n  - `arg2::Float64`: Documentation for argument 2\n  - `arg1::ProductionVariableCostCurve`: Documentation for argument 1\n\"\"\"\nstruct SomeSiennaStruct <: OperationalCost\n    arg1::ProductionVariableCostCurve\n    arg2::Float64\nend","category":"section"},{"location":"docs_best_practices/how-to/write_docstrings_org_api/#Add-See-also-Links-to-Functions-with-the-Same-Name","page":"Organize APIs and Write Docstrings","title":"Add See also Links to Functions with the Same Name","text":"tip: Do\nTo help users navigate Julia's multiple dispatch, add See also paragraphs at the bottom of  function docstrings other versions of the function with the same name, using the guidance on adding a specific hyperlink. Example:See also \n[`get_time_series_array` by name from storage](@ref get_time_series_array(\n    ::Type{T},\n    owner::TimeSeriesOwners,\n    name::AbstractString;\n    start_time::Union{Nothing, Dates.DateTime} = nothing,\n    len::Union{Nothing, Int} = nothing,\n    ignore_scaling_factors = false,\n    features...,\n) where {T <: TimeSeriesData}),\n[`get_time_series_array` from a `StaticTimeSeriesCache`](@ref get_time_series_array(\n    owner::TimeSeriesOwners,\n    time_series::StaticTimeSeries,\n    start_time::Union{Nothing, Dates.DateTime} = nothing;\n    len::Union{Nothing, Int} = nothing,\n    ignore_scaling_factors = false,\n))","category":"section"},{"location":"docs_best_practices/how-to/write_docstrings_org_api/#Follow-the-Guidelines-on-Cleaning-Up-General-Formatting","page":"Organize APIs and Write Docstrings","title":"Follow the Guidelines on Cleaning Up General Formatting","text":"tip: Do\nFollow How-to Clean Up General Formatting, especially by adding hyperlinks to other Sienna structs that appear within an arguments list.","category":"section"},{"location":"style/#style_guide","page":"Style Guide","title":"Julia Coding Style Guide for Sienna","text":"","category":"section"},{"location":"style/#Goals","page":"Style Guide","title":"Goals","text":"Define a straightforward set of rules that lead to consistent, readable code.\nDevelopers focus on producing high quality code, not how to format it.","category":"section"},{"location":"style/#Base","page":"Style Guide","title":"Base","text":"Follow the official Julia style guide except for deviations noted here.\nFollow Julia contribution guidelines, notably its line length limit.\nFollow Julia guidelines for docstrings.\nFollow JuMP coding standards, including its deviations from the Julia style guide.  In particular, note its policies on\nwhitespace\nreturn statements\nvariable names.\nRead The Zen of Python.\nConsider using a plugin that configures your text editor to use EditorConfig settings.","category":"section"},{"location":"style/#Code-Organization","page":"Style Guide","title":"Code Organization","text":"Import standard modules, then 3rd-party modules, then yours. Include a blank line between each group.","category":"section"},{"location":"style/#Module","page":"Style Guide","title":"Module","text":"When writing a module locate all the exports in the main module file.\nPlease include a copy of this .gitignore file","category":"section"},{"location":"style/#Module-Aliases","page":"Style Guide","title":"Module Aliases","text":"Use the import X as Y syntax instead of const Y = X when creating module aliases.\n\nSince Julia 1.6, language servers will recognize import X as Y where they fail to recognize const aliases.","category":"section"},{"location":"style/#Comments","page":"Style Guide","title":"Comments","text":"Use comments to describe non-obvious or non-trivial aspects of code. Describe why something was done but not how.  The \"how\" should be apparent from the code itself.\nUse complete sentences and proper grammar.\nInclude a space in between the \"#\" and the first word of the comment.\nUse these tags in comments to describe known work:\nTODO:  tasks that need to be done\nFIXME:  code that needs refactoring\nBUG:  known bug that exists. Should include a bug ID and tracking system.\nPERF:  known performance limitation that needs improvement","category":"section"},{"location":"style/#Constructors","page":"Style Guide","title":"Constructors","text":"Per guidance from Julia documentation, use inner constructors to enforce restrictions on parameters or to allow construction of self-referential objects. Use outer constructors to provide default values or to perform customization.\nDocument the reason why the outer constructor is different.\nNote that the compiler will provide a default constructor with all struct members if no inner constructor is defined.\nWhen creating a constructor use function Foo() instead of Foo() = ... One exception is the case where one file has all single-line functions.","category":"section"},{"location":"style/#Exceptions","page":"Style Guide","title":"Exceptions","text":"Use exceptions for unexpected errors and not for normal error handling.\nDetection of an unsupported data format from a user should likely throw an exception and terminate the application.\nDo not use try/catch to handle retrieving a potentially-missing key from a dictionary.","category":"section"},{"location":"style/#Asserts","page":"Style Guide","title":"Asserts","text":"Use @assert statements to guard against programming errors. Do not use them after detecting bad user input. An assert tripping should indicate that there is a bug in the code. Note that they may be compiled out in optimized builds in the future.\nConsider using InfrastructureSystems.@assert_op instead of the standard @assert because it will automatically print the value of the expression. Unlike the standard @assert the Julia compiler will never exclude @assert_op in optimized builds.\n\njulia> a = 3; b = 4;\njulia> @assert_op a == b\nERROR: AssertionError: 3 == 4","category":"section"},{"location":"style/#Globals","page":"Style Guide","title":"Globals","text":"Global constants should use UPPER_CASE and be declared const.\nIf global variables are needed, prefix them with g_.\nDon't use magic numbers. Instead, define const globals or Enums (Julia @enum).","category":"section"},{"location":"style/#One-line-Conditionals","page":"Style Guide","title":"One-line Conditionals","text":"Julia code base uses this idiom frequently:  <cond> && <statement> Example:\n\n    function fact(n::Int)\n       n >= 0 || error(\"n must be non-negative\")\n       n == 0 && return 1\n       n * fact(n-1)\n    end\n\nThis is acceptable for simple code as in this example. However, in general, prefer to write out an entire if statement.\n\nTernary operators provide a way to write clean, concise code.  Use good judgement.\n\nGood:\n\n    y = x > 0 ? x : -x\n\nThere are many examples in our codebase that use the form <cond> ? <statement> : <statement>. These can be expressed much more clearly in an if/else statement.","category":"section"},{"location":"style/#Logging","page":"Style Guide","title":"Logging","text":"When adding a debug log statement consider whether it is appropriate to append _group = <some-name>. The packages use this Julia feature to suppress debug logging of entire groups at once.  InfrastructureSystems defines LOG_GROUPS with commonly-used group names.\n\nIf you are developing a feature with functionality in a single file then you can let Julia use the default name (the base name of the file). However, if the feature spans files then you should use an existing group or add a new one. Group names should be of type Symbol and follow the PascalCase naming convention.\n\nCommon group names should be defined in InfrastructureSystems but packages can add their own as needed.","category":"section"},{"location":"style/#Unit-Tests","page":"Style Guide","title":"Unit Tests","text":"All code should be tested. The packages in Sienna have a minimum of 70% coverage to be merged into main. This functionality is provided using Codecov","category":"section"},{"location":"style/#Whitespace","page":"Style Guide","title":"Whitespace","text":"If many function arguments cause the line length to be exceeded, put one argument per line. In some cases it may make sense to pair some variables on the same line.\n\n    function foo(\n                 var1::String,\n                 var2::String,\n                 var3::String,\n                 var4::String,\n                 var5::String,\n                 var6::String,\n                 )\n\nDo not surround equal signs with spaces when passing keyword args to a function or defining default values in function declarations.\nDo not right-align equal signs when assigning groups of variables. It causes unnecessary changes whenever someone adds a new variable with a longer name.\n\nBad:\n\n    x   = 1\n    foo = 2\n\nGood:\n\n    x = 1\n    foo = 2\n\nDefine abstract types on one line. Given the lack of IDE support for Julia, this makes it easier to find type definitions.\n\nBad:\n\n    abstract type\n        Foo\n    end\n\nGood:\n\n    abstract type Foo end\n\nAll Sienna packages perform tests using JuliaFormatter if you are unsure of your format, you can run julia  -e 'using JuliaFormatter; include(\".github/workflows/formatter_code.jl\")' at the root of the package. Make sure to have the latest version of JuliaFormatter in your main environment","category":"section"},{"location":"docs_best_practices/how-to/write_a_tutorial/#Write-a-Tutorial","page":"Write a Tutorial","title":"Write a Tutorial","text":"Tutorials are learning experiences to give our users confidence and experience in using Sienna.","category":"section"},{"location":"docs_best_practices/how-to/write_a_tutorial/#Prepare","page":"Write a Tutorial","title":"Prepare","text":"If you have not read Diataxis, first read it in its entirety.\nIf you have read it, skim the pages on Tutorials and the difference between a tutorial and how-to guide to refresh your memory and refer back throughout the process.\nLook at an example: PowerSystems.jl's Working with Time Series\n\nwarning: Warning\nHistorically, many of Sienna's \"tutorials\" have blended all 4 types of documentation in the Diataxis framework. If you are editing, be prepared to move material to related Explanation and How-to pages and into function docstrings in the APIs as you work.If you starting a new tutorial, ask yourself if a tutorial is appropriate for what you're trying to show, or if you should be writing a how-to instead. See also how to Write a How-to Guide.","category":"section"},{"location":"docs_best_practices/how-to/write_a_tutorial/#Follow-the-Do's-and-Don't's","page":"Write a Tutorial","title":"Follow the Do's and Don't's","text":"The Diataxis Tutorials page should be your main reference as you write, but in addition, use these functional and aesthetic guidelines to ensure we follow Diataxis and avoid common pitfalls from previous versions of Sienna documentation:\n\nPages = [\"write_a_tutorial.md\"]\nDepth = 3:3","category":"section"},{"location":"docs_best_practices/how-to/write_a_tutorial/#Give-it-a-story","page":"Write a Tutorial","title":"Give it a story","text":"The tutorial should have a logical flow, rather than be a series of disconnected code demonstrations.\n\ntip: Do\nUse either named @example or named @repl blocks to ensure all code compiles in order in the same environment and ensuring each step builds on the previous steps in your story:```@example my_tutorial\n<Some code here>\n```\n\nwarning: Don't\nUse a series of julia markdown blocks. These won't be compiled, failing the intention of a tutorial and introducing high likelihood of errors as syntax changes.```julia\n<Some code here>\n```","category":"section"},{"location":"docs_best_practices/how-to/write_a_tutorial/#Make-it-reproducible","page":"Write a Tutorial","title":"Make it reproducible","text":"A user should be able to copy and paste every code block in the tutorial in order and get the exact results seen on the documentation page.\n\ntip: Do\nDisplay all code, starting from using SomeSiennaPackage. Example: See Working with Time Series.\n\nwarning: Don't\nUse #hide or @setup blocks.","category":"section"},{"location":"docs_best_practices/how-to/write_a_tutorial/#Make-it-effortless-to-read","page":"Write a Tutorial","title":"Make it effortless to read","text":"tip: Do\nSplit code examples into ideally 1 (to 3) lines ONLY, with a short preface to explain what each line is doing, even if it's obvious to you.\n\nwarning: Don't\nUse blocks of example code and/or return statements that go over 1 screen length in the compiled .html. They are very hard to follow and allow a user to tune out or give up.","category":"section"},{"location":"docs_best_practices/how-to/write_a_tutorial/#Make-it-realistic-and-relatable","page":"Write a Tutorial","title":"Make it realistic and relatable","text":"tip: Do\nTake the time to define some realistic example data.\n\nwarning: Don't\nUse zero() or one() for all example data.","category":"section"},{"location":"docs_best_practices/how-to/write_a_tutorial/#Only-show-relevant-log-and-return-statements","page":"Write a Tutorial","title":"Only show relevant log and return statements","text":"tip: Do\nConfigure the logger or load/build a System that returns very few log statements. Use semi-colons at line ends to hide return statements if need be.\n\nwarning: Don't\nShow extensive or confusing log or return statements that bog down a reader with information that isn't directly relevant to what you're trying to teach.","category":"section"},{"location":"docs_best_practices/how-to/write_a_tutorial/#Remove-other-types-of-documentation","page":"Write a Tutorial","title":"Remove other types of documentation","text":"Particularly when editing existing material, watch out for material that should be moved elsewhere according to Diataxis principles:\n\ntip: Do\nPreface each call to a new function with a hyperlink to that function's docstring so the user can find more detail\n\nwarning: Don't\nInclude definitions and details about different keyword arguments or versions of a function in the tutorial itself. Some basic information is OK, but details and examples live in the docstrings, and they especially shouldn't be included in the tutorial in lieu of being in the docstrings.","category":"section"},{"location":"docs_best_practices/how-to/write_a_tutorial/#Follow-the-Guidelines-on-Cleaning-Up-General-Formatting","page":"Write a Tutorial","title":"Follow the Guidelines on Cleaning Up General Formatting","text":"tip: Do\nFollow How-to Clean Up General Formatting.","category":"section"},{"location":"docs_best_practices/how-to/write_a_tutorial/#Look-at-the-compiled-.html!","page":"Write a Tutorial","title":"Look at the compiled .html!","text":"tip: Do\nCompile the tutorial regularly and look at it\nCheck all code examples gave the expected results without erroring\nCheck for length of the code examples and iteratively adjust to make it easy to read","category":"section"},{"location":"dev_guide/recorder/#Recorder-Events","page":"Recorder Events","title":"Recorder Events","text":"InfrastructureSystems.jl provides a mechanism to store structured data in events that get recorded in one or more files. They can be filtered and displayed in tabular form.\n\nThe primary use is to store information that can help debug problems and it is largely used in PowerSimulations.jl. For example, you may want to store all state transitions in a simulation or every update of a variable.  If a problem occurs you can then display filtered tables of that data to figure out what went wrong.","category":"section"},{"location":"dev_guide/recorder/#Instructions","page":"Recorder Events","title":"Instructions","text":"Create events that are subtypes of InfrastructureSystems.AbstractRecorderEvent. Include an instance of RecorderEventCommon in each struct.\nCall InfrastructureSystems.register_recorder! with arguments recorder-name for each recorder object you want to create.\nDepending on how often your code create events you may want to make this conditional. You may only need it for debug runs.\nPowerSimulations creates one recorder for simulation step and stage start/stop events that is always enabled. It creates another that is optional but used for frequently-generated events.\nCall @InfrastructureSystems.record with arguments recorder-name event wherever you want to generate events in your code. The event will only get constructed if the recorder is registered.\nCall InfrastructureSystems.unregister_recorder! with arguments recorder-name for each registered recorder. You should guarantee this gets called, even if an exception is thrown.  Otherwise, the file may not get flushed and closed.\nAfter your code runs call InfrastructureSystems.show_recorder_events to view events.  Refer to the docstrings for more information.\nRefer to PowerSimulations.show_simulation_events for an example on how to customize this behavior for your package.","category":"section"},{"location":"InfrastructureSystems/#API_ref","page":"API","title":"InfrastructureSystems API Reference","text":"","category":"section"},{"location":"InfrastructureSystems/#InfrastructureSystems.COMPONENT_NAME_DELIMITER","page":"API","title":"InfrastructureSystems.COMPONENT_NAME_DELIMITER","text":"Delimiter to use when constructing qualified names like component_type__component_name.\n\n\n\n\n\n","category":"constant"},{"location":"InfrastructureSystems/#InfrastructureSystems.AbstractRecorderEvent","page":"API","title":"InfrastructureSystems.AbstractRecorderEvent","text":"Supertype for recorder events\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.AverageRateCurve","page":"API","title":"InfrastructureSystems.AverageRateCurve","text":"An average rate curve, relating the production quantity to the average cost rate from the origin: y = f(x)/x. Can be used, for instance, in the representation of a CostCurve where x is MW and y is currency/MWh, or in the representation of a FuelCurve where x is MW and y is fuel/MWh. Typically calculated by dividing absolute values of cost rate or fuel input rate by absolute values of electric power.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.ComponentContainer","page":"API","title":"InfrastructureSystems.ComponentContainer","text":"A data structure that acts like a container of components. The ComponentContainer interface consists of:\n\nget_components\nget_component\nget_available_components\nget_available_component\n\nNotable subtypes include Components, SystemData, and PowerSystems.System.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.ComponentSelector","page":"API","title":"InfrastructureSystems.ComponentSelector","text":"Given some ComponentContainer-like source of components to draw from, such as a PowerSystems.System, a ComponentSelector picks out a certain subset of them based on some user-defined selection criteria. A ComponentSelector can also be used to name that subset of components or to split it up into groups. The same ComponentSelector can be used to apply the same set of selection criteria to multiple sources of components. The primary use case for ComponentSelector is to support repeatable multi-scenario post-processing analytics (see e.g. PowerAnalytics.jl).\n\nFormally, instances of ComponentSelector represent lazy, partitioned, named, source-independent collections of InfrastructureSystemsComponents.\n\nCore Interface\n\nmake_selector: factory function to handle ComponentSelector creation; end users should use this rather than calling the constructors directly.\nget_groups: get the groups that make up a ComponentSelector, which will themselves be represented as ComponentSelectors.\nget_components: get all the components that make up a ComponentSelector, ignoring how they are grouped. A component should appear in the get_components of a given selector if and only if it appears in the get_components of at least one of that selector's groups.\nget_name: get the name of the ComponentSelector. All ComponentSelectors have a name, whether it is specified by the user or created automatically.\nrebuild_selector: create a new ComponentSelector from an existing one with some details (e.g., the name or the grouping behavior) tweaked.\n\nAvailability Filtering\n\nBesides the core interface, also provided are get_component for ComponentSelector subtypes that can only refer to at most one component; and get_available_component, get_available_components, and get_available_groups, which work the same as the corresponding functions without available except they only consider components for which get_available is true.\n\nscope_limiter Filtering\n\nThe ComponentSelector methods of get_component, get_components, and get_groups, and the corresponding _available_ variants, take an optional first argument scope_limiter::Union{Function, Nothing}. If a function is passed in here, it will be used as a filter function to limit the components under consideration before the ComponentSelector's criteria are evaluated.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.Components","page":"API","title":"InfrastructureSystems.Components","text":"A simple container for components and time series data.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.CompressionSettings","page":"API","title":"InfrastructureSystems.CompressionSettings","text":"CompressionSettings(enabled, type, level, shuffle)\n\nProvides customization of HDF5 compression settings.\n\nenabled::Bool: Controls whether compression is enabled.\ntype::InfrastructureSystems.CompressionTypesModule.CompressionTypes: Specifies the type of compression to use.\nlevel::Int64: Supported values are 0-9. Higher values deliver better compression ratios but take longer.\nshuffle::Bool: Controls whether to enable the shuffle filter. Used with DEFLATE.\n\nRefer to the HDF5.jl and HDF5 documentation for more details on the options.\n\nExample\n\nsettings = CompressionSettings(\n    enabled = true,\n    type = CompressionTypes.DEFLATE,  # BLOSC is also supported\n    level = 3,\n    shuffle = true,\n)\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.CostCurve","page":"API","title":"InfrastructureSystems.CostCurve","text":"struct CostCurve{T<:InfrastructureSystems.ValueCurve} <: InfrastructureSystems.ProductionVariableCostCurve{T<:InfrastructureSystems.ValueCurve}\n\nvalue_curve::InfrastructureSystems.ValueCurve: The underlying ValueCurve representation of this ProductionVariableCostCurve\npower_units::InfrastructureSystems.UnitSystemModule.UnitSystem: (default: natural units (MW)) The units for the x-axis of the curve\nvom_cost::LinearCurve: (default of 0) Additional proportional Variable Operation and Maintenance Cost in     /(power_unit h), represented as a LinearCurve\n\nCostCurve(value_curve, power_units, vom_cost)\nCostCurve(; value_curve, power_units, vom_cost)\n\nDirect representation of the variable operation cost of a power plant in currency. Composed of a ValueCurve that may represent input-output, incremental, or average rate data. The default units for the x-axis are MW and can be specified with power_units.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.DataFormatError","page":"API","title":"InfrastructureSystems.DataFormatError","text":"Thrown upon detection of user data that is not supported.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.Deterministic","page":"API","title":"InfrastructureSystems.Deterministic","text":"mutable struct Deterministic <: AbstractDeterministic\n    name::String\n    data::SortedDict\n    resolution::Dates.Period\n    interval::Dates.Period\n    scaling_factor_multiplier::Union{Nothing, Function}\n    internal::InfrastructureSystemsInternal\nend\n\nA deterministic forecast for a particular data field in a Component.\n\nArguments\n\nname::String: user-defined name\ndata::SortedDict: timestamp - scalingfactor\nresolution::Dates.Period: forecast resolution\ninterval::Dates.Period: forecast interval\nscaling_factor_multiplier::Union{Nothing, Function}: Applicable when the time series data are scaling factors. Called on the associated component to convert the values.\ninternal::InfrastructureSystemsInternal\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.Deterministic-Tuple{AbstractString, AbstractDict{Dates.DateTime, <:TimeSeries.TimeArray}}","page":"API","title":"InfrastructureSystems.Deterministic","text":"Deterministic(\n    name::AbstractString,\n    input_data::AbstractDict{Dates.DateTime, <:TimeSeries.TimeArray};\n    resolution,\n    interval,\n    normalization_factor,\n    scaling_factor_multiplier\n) -> InfrastructureSystems.Deterministic\n\n\nConstruct Deterministic from a Dict of TimeArrays.\n\nArguments\n\nname::AbstractString: user-defined name\ninput_data::AbstractDict{Dates.DateTime, TimeSeries.TimeArray}: time series data.\nresolution::Union{Nothing, Dates.Period} = nothing: If nothing, infer resolution from the data. Otherwise, it must be the difference between each consecutive timestamps. Resolution is required if the resolution is irregular, such as with Dates.Month or Dates.Year.\ninterval::Union{Nothing, Dates.Period} = nothing: If nothing, infer interval from the data. Otherwise, it must be the difference in time between the start of each window. Interval is required if the interval is irregular, such as with Dates.Month or Dates.Year.\nnormalization_factor::NormalizationFactor = 1.0: optional normalization factor to apply to each data entry\nscaling_factor_multiplier::Union{Nothing, Function} = nothing: If the data are scaling factors then this function will be called on the component and applied to the data when get_time_series_array is called.\ntimestamp = :timestamp: If the values are DataFrames is passed then this must be the column name that contains timestamps.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Deterministic-Tuple{AbstractString, AbstractString, InfrastructureSystems.InfrastructureSystemsComponent, Dates.Period}","page":"API","title":"InfrastructureSystems.Deterministic","text":"Deterministic(\n    name::AbstractString,\n    filename::AbstractString,\n    component::InfrastructureSystems.InfrastructureSystemsComponent,\n    resolution::Dates.Period;\n    interval,\n    normalization_factor,\n    scaling_factor_multiplier\n) -> InfrastructureSystems.Deterministic\n\n\nConstruct Deterministic from a CSV file. The first column must be a timestamp in DateTime format and the columns the values in the forecast window.\n\nArguments\n\nname::AbstractString: user-defined name\nfilename::AbstractString: name of CSV file containing data\ncomponent::InfrastructureSystemsComponent: component associated with the data\nnormalization_factor::NormalizationFactor = 1.0: optional normalization factor to apply to each data entry\nscaling_factor_multiplier::Union{Nothing, Function} = nothing: If the data are scaling factors then this function will be called on the component and applied to the data when get_time_series_array is called.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Deterministic-Tuple{AbstractString, InfrastructureSystems.RawTimeSeries, Dates.Period}","page":"API","title":"InfrastructureSystems.Deterministic","text":"Deterministic(\n    name::AbstractString,\n    series_data::InfrastructureSystems.RawTimeSeries,\n    resolution::Dates.Period;\n    interval,\n    normalization_factor,\n    scaling_factor_multiplier\n) -> InfrastructureSystems.Deterministic\n\n\nConstruct Deterministic from RawTimeSeries.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Deterministic-Tuple{InfrastructureSystems.Deterministic, AbstractString}","page":"API","title":"InfrastructureSystems.Deterministic","text":"Deterministic(\n    src::InfrastructureSystems.Deterministic,\n    name::AbstractString;\n    scaling_factor_multiplier\n) -> InfrastructureSystems.Deterministic\n\n\nConstruct Deterministic that shares the data from an existing instance.\n\nThis is useful in cases where you want a component to use the same time series data for two different attributes.\n\nExamples\n\nresolution = Dates.Hour(1)\ndata = Dict(\n    DateTime(\"2020-01-01T00:00:00\") => ones(24),\n    DateTime(\"2020-01-01T01:00:00\") => ones(24),\n)\n# Define a Deterministic for the first attribute\nforecast_max_active_power = Deterministic(\n    \"max_active_power\",\n    data,\n    resolution,\n    scaling_factor_multiplier = get_max_active_power,\n)\nadd_time_series!(sys, generator, forecast_max_active_power)\n# Reuse time series for second attribute\nforecast_max_reactive_power = Deterministic(\n    forecast_max_active_power,\n    \"max_reactive_power\"\n    scaling_factor_multiplier = get_max_reactive_power,\n)\nadd_time_series!(sys, generator, forecast_max_reactive_power)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Deterministic-Tuple{InfrastructureSystems.Deterministic, Any}","page":"API","title":"InfrastructureSystems.Deterministic","text":"Deterministic(\n    forecast::InfrastructureSystems.Deterministic,\n    data\n) -> InfrastructureSystems.Deterministic\n\n\nConstruct a new Deterministic from an existing instance and a subset of data.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.DeterministicMetadata","page":"API","title":"InfrastructureSystems.DeterministicMetadata","text":"mutable struct DeterministicMetadata <: ForecastMetadata\n    name::String\n    resolution::Dates.Period\n    initial_timestamp::Dates.DateTime\n    interval::Dates.Period\n    count::Int\n    time_series_uuid::UUIDs.UUID\n    horizon::Dates.Period\n    time_series_type::Type{<:AbstractDeterministic}\n    scaling_factor_multiplier::Union{Nothing, Function}\n    features::Dict{String, Union{Bool, Int, String}}\n    internal::InfrastructureSystemsInternal\nend\n\nA deterministic forecast for a particular data field in a Component.\n\nArguments\n\nname::String: user-defined name\nresolution::Dates.Period:\ninitial_timestamp::Dates.DateTime: time series availability time\ninterval::Dates.Period: time step between forecast windows\ncount::Int: number of forecast windows\ntime_series_uuid::UUIDs.UUID: reference to time series data\nhorizon::Dates.Period: length of this time series\ntime_series_type::Type{<:AbstractDeterministic}: Type of the time series data associated with this metadata.\nscaling_factor_multiplier::Union{Nothing, Function}: (default: nothing) Applicable when the time series data are scaling factors. Called on the associated component to convert the values.\nfeatures::Dict{String, Union{Bool, Int, String}}: (default: Dict{String, Any}()) User-defined tags that differentiate multiple time series arrays that represent the same component attribute, such as different arrays for different scenarios or years.\ninternal::InfrastructureSystemsInternal:\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.DeterministicSingleTimeSeries","page":"API","title":"InfrastructureSystems.DeterministicSingleTimeSeries","text":"mutable struct DeterministicSingleTimeSeries <: AbstractDeterministic\n    single_time_series::SingleTimeSeries\n    initial_timestamp::Dates.DateTime\n    interval::Dates.Period\n    count::Int\n    horizon::Int\nend\n\nA deterministic forecast that wraps a SingleTimeSeries\n\nDeterministicSingleTimeSeries behaves exactly like a Deterministic, but instead of storing windows at each initial time it provides a view into the existing SingleTimeSeries at incrementing offsets. This avoids large data duplications when  there are the overlapping windows between forecasts. \n\nCan be used as a perfect forecast based on historical data when real forecast data is unavailable. \n\nArguments\n\nsingle_time_series::SingleTimeSeries: wrapped SingleTimeSeries object\ninitial_timestamp::Dates.DateTime: time series availability time\ninterval::Dates.Period: time step between forecast windows\ncount::Int: number of forecast windows\nhorizon::Int: length of this time series\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.DeviceParameter","page":"API","title":"InfrastructureSystems.DeviceParameter","text":"Base type for auxillary structs. These should not be stored in a system.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.DynamicallyGroupedComponentSelector","page":"API","title":"InfrastructureSystems.DynamicallyGroupedComponentSelector","text":"PluralComponentSelectors whose grouping is determined by a groupby field. The semantics of this field are described at make_selector.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.FileLogger","page":"API","title":"InfrastructureSystems.FileLogger","text":"Specializes the behavior of SimpleLogger by adding timestamps and process and thread IDs.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.FilterComponentSelector","page":"API","title":"InfrastructureSystems.FilterComponentSelector","text":"ComponentSelector represented by a filter function and a type of component. Contains all the components of that type that satisfy the filter function, grouped by the groupby field (see make_selector).\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.FlattenIteratorWrapper","page":"API","title":"InfrastructureSystems.FlattenIteratorWrapper","text":"Wrapper around Iterators.Flatten to provide total length.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.Forecast","page":"API","title":"InfrastructureSystems.Forecast","text":"Supertype for forecast time series Current concrete subtypes are:\n\nDeterministic\nDeterministicSingleTimeSeries\nScenarios\nProbabilistic\n\nSubtypes of Forecast must implement:\n\nget_horizon_count\nget_initial_times\nget_initial_timestamp\nget_name\nget_scaling_factor_multiplier\nget_window\niterate_windows\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.ForecastCache-Union{Tuple{T}, Tuple{Type{T}, InfrastructureSystems.InfrastructureSystemsComponent, AbstractString}} where T<:InfrastructureSystems.Forecast","page":"API","title":"InfrastructureSystems.ForecastCache","text":"Construct ForecastCache to automatically control caching of forecast data. Maintains some count of forecast windows in memory based on cache_size_bytes.\n\nCall Base.iterate or get_next_time_series_array! to retrieve data. Each iteration will return a TimeSeries.TimeArray covering one forecast window of length horizon_count.\n\nArguments\n\n::Type{T}: subtype of Forecast\ncomponent::InfrastructureSystemsComponent: component\nname::AbstractString: forecast name\nstart_time::Union{Nothing, Dates.DateTime} = nothing: forecast start time\nhorizon_count::Union{Nothing, Int} = nothing: forecast horizon count\ncache_size_bytes = TIME_SERIES_CACHE_SIZE_BYTES: maximum size of data to keep in memory\nignore_scaling_factors = false: controls whether to ignore scaling_factor_multiplier in the time series instance\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.ForecastKey","page":"API","title":"InfrastructureSystems.ForecastKey","text":"A unique key to identify and retrieve a Forecast\n\nSee: get_time_series_keys and get_time_series(::TimeSeriesOwners, ::TimeSeriesKey).\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.FuelCurve","page":"API","title":"InfrastructureSystems.FuelCurve","text":"struct FuelCurve{T<:InfrastructureSystems.ValueCurve} <: InfrastructureSystems.ProductionVariableCostCurve{T<:InfrastructureSystems.ValueCurve}\n\nvalue_curve::InfrastructureSystems.ValueCurve: The underlying ValueCurve representation of this ProductionVariableCostCurve\npower_units::InfrastructureSystems.UnitSystemModule.UnitSystem: (default: natural units (MW)) The units for the x-axis of the curve\nfuel_cost::Union{Float64, InfrastructureSystems.TimeSeriesKey}: Either a fixed value for fuel cost or the TimeSeriesKey to a fuel cost time series\nstartup_fuel_offtake::LinearCurve: (default of 0) Fuel consumption at the unit startup proceedure. Additional cost to the startup costs and related only to the initial fuel required to start the unit.     represented as a LinearCurve\nvom_cost::LinearCurve: (default of 0) Additional proportional Variable Operation and Maintenance Cost in /(power_unit h)     represented as a LinearCurve\n\nFuelCurve(value_curve, power_units, fuel_cost, startup_fuel_offtake, vom_cost)\nFuelCurve(value_curve, fuel_cost)\nFuelCurve(value_curve, fuel_cost, startup_fuel_offtake, vom_cost)\nFuelCurve(value_curve, power_units, fuel_cost)\nFuelCurve(; value_curve, power_units, fuel_cost, startup_fuel_offtake, vom_cost)\n\nRepresentation of the variable operation cost of a power plant in terms of fuel (MBTU, liters, m^3, etc.), coupled with a conversion factor between fuel and currency. Composed of a ValueCurve that may represent input-output, incremental, or average rate data. The default units for the x-axis are MW and can be specified with power_units.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.GeographicInfo","page":"API","title":"InfrastructureSystems.GeographicInfo","text":"GeographicInfo <: SupplementalAttribute\n\nSupplemental attribute to store geographic information about system components in GeoJSON format.\n\nArguments\n\ngeo_json::Dict{String, Any}: dictionary containing GeoJSON data representing the geographic information of the component\ninternal::InfrastructureSystemsInternal: internal infrastructure systems data for managing metadata and UUID tracking\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.GeographicInfo-Tuple{}","page":"API","title":"InfrastructureSystems.GeographicInfo","text":"GeographicInfo(\n;\n    geo_json,\n    internal\n) -> InfrastructureSystems.GeographicInfo\n\n\nGeographicInfo(; geo_json, internal)\n\nConstruct a GeographicInfo supplemental attribute.\n\nArguments\n\ngeo_json::Dict{String, Any}: dictionary containing GeoJSON data. Defaults to an empty dictionary if not provided\ninternal::InfrastructureSystemsInternal: internal infrastructure systems data. Defaults to a new InfrastructureSystemsInternal instance if not provided\n\nExample\n\n# Create with default empty geo_json\ngeo_info = GeographicInfo()\n\n# Create with specific geo_json data\ngeo_data = Dict(\"type\" => \"Point\", \"coordinates\" => [1.0, 2.0])\ngeo_info = GeographicInfo(geo_json = geo_data)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Hdf5TimeSeriesStorage","page":"API","title":"InfrastructureSystems.Hdf5TimeSeriesStorage","text":"Stores all time series data in an HDF5 file.\n\nThe file used is assumed to be temporary and will be automatically deleted when there are no more references to the storage object.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.Hdf5TimeSeriesStorage-Tuple{Bool}","page":"API","title":"InfrastructureSystems.Hdf5TimeSeriesStorage","text":"Hdf5TimeSeriesStorage(\n    create_file::Bool;\n    filename,\n    directory,\n    compression\n) -> InfrastructureSystems.Hdf5TimeSeriesStorage\n\n\nConstructs Hdf5TimeSeriesStorage.\n\nArguments\n\ncreate_file::Bool: create new file\nfilename=nothing: if nothing, create a temp file, else use this name.\ndirectory=nothing: if set and filename is nothing, create a temp file in this directory. If it is not set, use the environment variable SIENNA_TIME_SERIES_DIRECTORY. If that is not set, use tempdir(). This should be set if the time series data is larger than the tmp filesystem can hold.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Hdf5TimeSeriesStorage-Tuple{}","page":"API","title":"InfrastructureSystems.Hdf5TimeSeriesStorage","text":"Hdf5TimeSeriesStorage(\n\n) -> InfrastructureSystems.Hdf5TimeSeriesStorage\n\n\nConstructs Hdf5TimeSeriesStorage by creating a temp file.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.InMemoryTimeSeriesStorage","page":"API","title":"InfrastructureSystems.InMemoryTimeSeriesStorage","text":"Stores all time series data in memory.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.InMemoryTimeSeriesStorage-Tuple{InfrastructureSystems.Hdf5TimeSeriesStorage}","page":"API","title":"InfrastructureSystems.InMemoryTimeSeriesStorage","text":"InMemoryTimeSeriesStorage(\n    hdf5_storage::InfrastructureSystems.Hdf5TimeSeriesStorage\n) -> InfrastructureSystems.InMemoryTimeSeriesStorage\n\n\nConstructs InMemoryTimeSeriesStorage from an instance of Hdf5TimeSeriesStorage.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.IncrementalCurve","page":"API","title":"InfrastructureSystems.IncrementalCurve","text":"An incremental (or 'marginal') curve, relating the production quantity to the derivative of cost: y = f'(x). Can be used, for instance, in the representation of a CostCurve where x is MW and y is currency/MWh, or in the representation of a FuelCurve where x is MW and y is fuel/MWh.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.InfrastructureSystemsComponent","text":"Base type for structs that are stored in a system.\n\nRequired interface functions for subtypes:\n\nNote: InfrastructureSystems provides default implementations for these methods that   depend on the struct field names name and internal.   If subtypes have different field names, they must implement these methods.\n\nget_name()\nsetnameinternal!()\nget_internal()\n\nWarning: Subtypes should not implement the function   setname!(::InfrastructureSystemsComponent, name).   InfrastructureSystems uses the component name in internal data structures, so it is not   safe to change the name of a component after it has been added to a system.   InfrastructureSystems provides setname!(data::SystemData, component, name) for this   purpose.\n\nOptional interface functions:\n\nThe default function returns true because some get_components functions need to return   all \"available\" and all components that don't explicitly have that attribute should be   returned.\n\nget_available()\n\nThe default function is a no-op.\n\nset_available!()\n\nSubtypes may contain time series and be associated with supplemental attributes. Those behaviors can be modified with these methods:\n\nsupportssupplementalattributes()\nsupportstimeseries()\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.InfrastructureSystemsInternal","page":"API","title":"InfrastructureSystems.InfrastructureSystemsInternal","text":"Internal storage common to InfrastructureSystems types.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.InfrastructureSystemsInternal-Tuple{Base.UUID}","page":"API","title":"InfrastructureSystems.InfrastructureSystemsInternal","text":"InfrastructureSystemsInternal(\n    u::Base.UUID\n) -> InfrastructureSystems.InfrastructureSystemsInternal\n\n\nCreates InfrastructureSystemsInternal with an existing UUID.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.InfrastructureSystemsInternal-Tuple{}","page":"API","title":"InfrastructureSystems.InfrastructureSystemsInternal","text":"InfrastructureSystemsInternal(\n;\n    uuid,\n    shared_system_references,\n    units_info,\n    ext\n) -> InfrastructureSystems.InfrastructureSystemsInternal\n\n\nCreates InfrastructureSystemsInternal with a new UUID.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.InfrastructureSystemsType","page":"API","title":"InfrastructureSystems.InfrastructureSystemsType","text":"Base type for any struct in the Sienna packages. All structs must implement a kwarg-only constructor to allow deserializing from a Dict.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.InputOutputCurve","page":"API","title":"InfrastructureSystems.InputOutputCurve","text":"An input-output curve, directly relating the production quantity to the cost: y = f(x). Can be used, for instance, in the representation of a CostCurve where x is MW and y is currency/hr, or in the representation of a FuelCurve where x is MW and y is fuel/hr.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.InputOutputCurve-Tuple{Real}","page":"API","title":"InfrastructureSystems.InputOutputCurve","text":"Evaluate the InputOutputCurve at a given input value x.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.LazyDictFromIterator-Union{Tuple{V}, Tuple{K}, Tuple{Type{K}, Type{V}, Any, Function}} where {K, V}","page":"API","title":"InfrastructureSystems.LazyDictFromIterator","text":"LazyDictFromIterator creates a dictionary from an iterator, but only increments the iterator and adds items to the dictionary as it needs them. In the worst case it is identical to creating a dictionary by iterating over the entire list. Each V should have a K member.\n\nArguments\n\nK: type of the dictionary keys\nV: type of the dictionary values\niter: any object implementing the Iterator interface\ngetter::Function: method to call on V to get its K\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.LinearCurve","page":"API","title":"InfrastructureSystems.LinearCurve","text":"LinearCurve(proportional_term::Float64)\nLinearCurve(proportional_term::Float64, constant_term::Float64)\n\nA linear input-output curve, representing a constant marginal rate. May have zero no-load cost (i.e., constant average rate) or not.\n\nArguments\n\nproportional_term::Float64: marginal rate\nconstant_term::Float64: optional, cost at zero production, defaults to 0.0\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.LinearFunctionData","page":"API","title":"InfrastructureSystems.LinearFunctionData","text":"Structure to represent the underlying data of linear functions. Principally used for the representation of cost functions f(x) = proportional_term*x + constant_term.\n\nArguments\n\nproportional_term::Float64: the proportional term in the represented function\nconstant_term::Float64: the constant term in the represented function\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.LinearFunctionData-Tuple{Number}","page":"API","title":"InfrastructureSystems.LinearFunctionData","text":"Evaluate the LinearFunctionData at a given x-coordinate\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.ListComponentSelector","page":"API","title":"InfrastructureSystems.ListComponentSelector","text":"ComponentSelector represented by a list of other ComponentSelectors. Those selectors form the groups.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.LogEvent","page":"API","title":"InfrastructureSystems.LogEvent","text":"Contains information describing a log event.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.LogEventTracker","page":"API","title":"InfrastructureSystems.LogEventTracker","text":"LogEventTracker() -> InfrastructureSystems.LogEventTracker\nLogEventTracker(\n    levels\n) -> InfrastructureSystems.LogEventTracker\n\n\nTracks counts of all log events by level.\n\nExamples\n\nLogEventTracker()\nLogEventTracker((Logging.Info, Logging.Warn, Logging.Error))\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.MultiLogger","page":"API","title":"InfrastructureSystems.MultiLogger","text":"Redirects log events to multiple loggers. The primary use case is to allow logging to both a file and the console. Secondarily, it can track the counts of all log messages.\n\nExample\n\nMultiLogger([TerminalLogger(stderr), SimpleLogger(stream)], LogEventTracker())\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.MultiLogger-Union{Tuple{Array{T}}, Tuple{T}} where T<:Base.CoreLogging.AbstractLogger","page":"API","title":"InfrastructureSystems.MultiLogger","text":"MultiLogger(\n    loggers::Array{T<:Base.CoreLogging.AbstractLogger}\n) -> InfrastructureSystems.MultiLogger\n\n\nCreates a MultiLogger with no event tracking.\n\nExample\n\nMultiLogger([TerminalLogger(stderr), SimpleLogger(stream)])\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.NameComponentSelector","page":"API","title":"InfrastructureSystems.NameComponentSelector","text":"ComponentSelector that refers by type and name to at most a single component. Has a single group that contains that component if it exists or contains no components if it doesn't.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.NotImplementedError","page":"API","title":"InfrastructureSystems.NotImplementedError","text":"Indicate that the feature at hand happens to not be implemented for the given data even though it could be. If it is a category mistake to imagine this feature defined on that data, use another exception, like TypeError or ArgumentError.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.PiecewiseAverageCurve","page":"API","title":"InfrastructureSystems.PiecewiseAverageCurve","text":"PiecewiseAverageCurve(initial_input::Union{Float64, Nothing}, x_coords::Vector{Float64}, slopes::Vector{Float64})\n\nA piecewise linear curve specified by average rates between production points. May have nonzero initial value.\n\nArguments\n\ninitial_input::Union{Float64, Nothing}: cost at minimum production point first(x_coords) (NOT at zero production), defines the start of the curve\nx_coords::Vector{Float64}: vector of n production points\nslopes::Vector{Float64}: vector of n-1 average rates/slopes of the curve segments between the points\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.PiecewiseIncrementalCurve","page":"API","title":"InfrastructureSystems.PiecewiseIncrementalCurve","text":"PiecewiseIncrementalCurve(initial_input::Union{Float64, Nothing}, x_coords::Vector{Float64}, slopes::Vector{Float64})\nPiecewiseIncrementalCurve(input_at_zero::Union{Nothing, Float64}, initial_input::Union{Float64, Nothing}, x_coords::Vector{Float64}, slopes::Vector{Float64})\n\nA piecewise linear curve specified by marginal rates (slopes) between production points. May have nonzero initial value.\n\nArguments\n\ninput_at_zero::Union{Nothing, Float64}: (optional, defaults to nothing) cost at zero production, does NOT represent a part of the curve\ninitial_input::Union{Float64, Nothing}: cost at minimum production point first(x_coords) (NOT at zero production), defines the start of the curve\nx_coords::Vector{Float64}: vector of n production points\nslopes::Vector{Float64}: vector of n-1 marginal rates/slopes of the curve segments between the points\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.PiecewiseLinearData","page":"API","title":"InfrastructureSystems.PiecewiseLinearData","text":"Structure to represent piecewise linear data as a series of points: two points define one segment, three points define two segments, etc. The curve starts at the first point given, not the origin. Principally used for the representation of cost functions where the points store quantities (x, y), such as (MW, /h).\n\nArguments\n\npoints::Vector{@NamedTuple{x::Float64, y::Float64}}: the points that define the function\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.PiecewiseLinearData-Tuple{Real}","page":"API","title":"InfrastructureSystems.PiecewiseLinearData","text":"Evaluate the PiecewiseLinearData or PiecewiseStepData at a given x-coordinate\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.PiecewisePointCurve","page":"API","title":"InfrastructureSystems.PiecewisePointCurve","text":"PiecewisePointCurve(points::Vector{Tuple{Float64, Float64}})\n\nA piecewise linear curve specified by cost values at production points.\n\nArguments\n\npoints::Vector{Tuple{Float64, Float64}} or similar: vector of (production, cost) pairs\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.PiecewiseStepData","page":"API","title":"InfrastructureSystems.PiecewiseStepData","text":"Structure to represent a step function as a series of endpoint x-coordinates and segment y-coordinates: two x-coordinates and one y-coordinate defines a single segment, three x-coordinates and two y-coordinates define two segments, etc. This can be useful to represent the derivative of a PiecewiseLinearData, where the y-coordinates of this step function represent the slopes of that piecewise linear function, so there is also an optional field c that can be used to store the initial y-value of that piecewise linear function. Principally used for the representation of cost functions where the points store quantities (x, dy/dx), such as (MW, /MWh).\n\nArguments\n\nx_coords::Vector{Float64}: the x-coordinates of the endpoints of the segments\ny_coords::Vector{Float64}: the y-coordinates of the segments: y_coords[1] is the y-value between\n\nx_coords[1] and x_coords[2], etc. Must have one fewer elements than x_coords.\n\nc::Union{Nothing, Float64}: optional, the value to use for the integral from 0 to x_coords[1] of this function\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.PluralComponentSelector","page":"API","title":"InfrastructureSystems.PluralComponentSelector","text":"ComponentSelector subtype that may refer to multiple components.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.Probabilistic","page":"API","title":"InfrastructureSystems.Probabilistic","text":"mutable struct Probabilistic <: Forecast\n    name::String\n    resolution::Dates.Period\n    interval::Dates.Period\n    percentiles::Vector{Float64}\n    data::SortedDict\n    scaling_factor_multiplier::Union{Nothing, Function}\n    internal::InfrastructureSystemsInternal\nend\n\nA Probabilistic forecast for a particular data field in a Component.\n\nArguments\n\nname::String: user-defined name\nresolution::Dates.Period: forecast resolution\ninterval::Dates.Period: forecast interval\npercentiles::Vector{Float64}: Percentiles for the probabilistic forecast\ndata::SortedDict: timestamp - scalingfactor\nscaling_factor_multiplier::Union{Nothing, Function}: Applicable when the time series data are scaling factors. Called on the associated component to convert the values.\ninternal::InfrastructureSystemsInternal\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.Probabilistic-Tuple{AbstractString, AbstractDict{Dates.DateTime, <:TimeSeries.TimeArray}, Vector{Float64}}","page":"API","title":"InfrastructureSystems.Probabilistic","text":"Probabilistic(\n    name::AbstractString,\n    input_data::AbstractDict{Dates.DateTime, <:TimeSeries.TimeArray},\n    percentiles::Vector{Float64};\n    resolution,\n    interval,\n    normalization_factor,\n    scaling_factor_multiplier\n) -> InfrastructureSystems.Probabilistic\n\n\nConstruct Probabilistic from a Dict of TimeArrays.\n\nArguments\n\nname::AbstractString: user-defined name\ninput_data::AbstractDict{Dates.DateTime, TimeSeries.TimeArray}: time series data.\npercentiles: Percentiles represented in the probabilistic forecast\nresolution::Union{Nothing, Dates.Period} = nothing: If nothing, infer resolution from the data. Otherwise, this must be the difference between each consecutive timestamps. This is required if the resolution is irregular, such as Dates.Month or Dates.Year.\ninterval::Union{Nothing, Dates.Period} = nothing: If nothing, infer interval from the data. Otherwise, it must be the difference in time between the start of each window. Interval is required if the type is irregular, such as with Dates.Month or Dates.Year.\nnormalization_factor::NormalizationFactor = 1.0: optional normalization factor to apply to each data entry\nscaling_factor_multiplier::Union{Nothing, Function} = nothing: If the data are scaling factors then this function will be called on the component and applied to the data when get_time_series_array is called.\ntimestamp = :timestamp: If the values are DataFrames is passed then this must be the column name that contains timestamps.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Probabilistic-Tuple{AbstractString, DataStructures.SortedDict{Dates.DateTime, Matrix{Float64}}, Vector, Dates.Period}","page":"API","title":"InfrastructureSystems.Probabilistic","text":"Probabilistic(\n    name::AbstractString,\n    data::DataStructures.SortedDict{Dates.DateTime, Matrix{Float64}},\n    percentiles::Vector,\n    resolution::Dates.Period;\n    interval,\n    normalization_factor,\n    scaling_factor_multiplier\n) -> InfrastructureSystems.Probabilistic\n\n\nConstruct Probabilistic from a SortedDict of Arrays.\n\nArguments\n\nname::AbstractString: user-defined name\ndata::AbstractDict{Dates.DateTime, Matrix{Float64}}: time series data.\npercentiles: Percentiles represented in the probabilistic forecast\nresolution::Dates.Period: The resolution of the forecast in Dates.Period`\ninterval::Union{Nothing, Dates.Period}: If nothing, infer interval from the data. Otherwise, it must be the difference in time between the start of each window. Interval is required if the type is irregular, such as with Dates.Month or Dates.Year.\nnormalization_factor::NormalizationFactor = 1.0: optional normalization factor to apply to each data entry\nscaling_factor_multiplier::Union{Nothing, Function} = nothing: If the data are scaling factors then this function will be called on the component and applied to the data when get_time_series_array is called.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Probabilistic-Tuple{AbstractString, InfrastructureSystems.RawTimeSeries, Vector, Dates.Period}","page":"API","title":"InfrastructureSystems.Probabilistic","text":"Probabilistic(\n    name::AbstractString,\n    series_data::InfrastructureSystems.RawTimeSeries,\n    percentiles::Vector,\n    resolution::Dates.Period;\n    interval,\n    normalization_factor,\n    scaling_factor_multiplier\n)\n\n\nConstruct Deterministic from RawTimeSeries.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Probabilistic-Tuple{InfrastructureSystems.Probabilistic, AbstractString}","page":"API","title":"InfrastructureSystems.Probabilistic","text":"Probabilistic(\n    src::InfrastructureSystems.Probabilistic,\n    name::AbstractString;\n    scaling_factor_multiplier\n) -> InfrastructureSystems.Probabilistic\n\n\nConstruct a Probabilistic that shares the data from an existing instance.\n\nThis is useful in cases where you want a component to use the same time series data for two different attributes.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.ProbabilisticMetadata","page":"API","title":"InfrastructureSystems.ProbabilisticMetadata","text":"mutable struct ProbabilisticMetadata <: ForecastMetadata\n    name::String\n    initial_timestamp::Dates.DateTime\n    resolution::Dates.Period\n    interval::Dates.Period\n    count::Int\n    percentiles::Vector{Float64}\n    time_series_uuid::UUIDs.UUID\n    horizon::Dates.Period\n    scaling_factor_multiplier::Union{Nothing, Function}\n    features::Dict{String, Union{Bool, Int, String}}\n    internal::InfrastructureSystemsInternal\nend\n\nA Probabilistic forecast for a particular data field in a Component.\n\nArguments\n\nname::String: user-defined name\ninitial_timestamp::Dates.DateTime: time series availability time\nresolution::Dates.Period:\ninterval::Dates.Period: time step between forecast windows\ncount::Int: number of forecast windows\npercentiles::Vector{Float64}: Percentiles for the probabilistic forecast\ntime_series_uuid::UUIDs.UUID: reference to time series data\nhorizon::Dates.Period: length of this time series\nscaling_factor_multiplier::Union{Nothing, Function}: (default: nothing) Applicable when the time series data are scaling factors. Called on the associated component to convert the values.\nfeatures::Dict{String, Union{Bool, Int, String}}: (default: Dict{String, Any}()) User-defined tags that differentiate multiple time series arrays that represent the same component attribute, such as different arrays for different scenarios or years.\ninternal::InfrastructureSystemsInternal:\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.QuadraticCurve","page":"API","title":"InfrastructureSystems.QuadraticCurve","text":"QuadraticCurve(quadratic_term::Float64, proportional_term::Float64, constant_term::Float64)\n\nA quadratic input-output curve, may have nonzero no-load cost.\n\nArguments\n\nquadratic_term::Float64: quadratic term of the curve\nproportional_term::Float64: proportional term of the curve\nconstant_term::Float64: constant term of the curve\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.QuadraticFunctionData","page":"API","title":"InfrastructureSystems.QuadraticFunctionData","text":"Structure to represent the underlying data of quadratic functions. Principally used for the representation of cost functions f(x) = quadratic_term*x^2 + proportional_term*x + constant_term.\n\nArguments\n\nquadratic_term::Float64: the quadratic term in the represented function\nproportional_term::Float64: the proportional term in the represented function\nconstant_term::Float64: the constant term in the represented function\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.QuadraticFunctionData-Tuple{InfrastructureSystems.LinearFunctionData}","page":"API","title":"InfrastructureSystems.QuadraticFunctionData","text":"QuadraticFunctionData(\n    data::InfrastructureSystems.LinearFunctionData\n) -> InfrastructureSystems.QuadraticFunctionData\n\n\nLosslessly convert LinearFunctionData to QuadraticFunctionData\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.QuadraticFunctionData-Tuple{Number}","page":"API","title":"InfrastructureSystems.QuadraticFunctionData","text":"Evaluate the QuadraticFunctionData at a given x-coordinate\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.RawTimeSeries","page":"API","title":"InfrastructureSystems.RawTimeSeries","text":"Wraps the data read from the text files with time series\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.Recorder","page":"API","title":"InfrastructureSystems.Recorder","text":"Records user-defined events in JSON format.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.Recorder-Tuple{Symbol}","page":"API","title":"InfrastructureSystems.Recorder","text":"Recorder(\n    name::Symbol;\n    io,\n    mode,\n    directory\n) -> InfrastructureSystems.Recorder\n\n\nConstruct a Recorder.\n\nArguments\n\nname::Symbol: name of recorder\nio::Union{Nothing, IO}:  If nothing, record events in a file using name.\nmode = \"w\":  Only used when io is nothing.\ndirectory = \".\":  Only used when io is nothing.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.RegroupedComponentSelector","page":"API","title":"InfrastructureSystems.RegroupedComponentSelector","text":"ComponentSelector that wraps another ComponentSelector and applies dynamic grouping. Components are the same as those of the wrapped selector, grouping is by the groupby field (see make_selector)\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.Results","page":"API","title":"InfrastructureSystems.Results","text":"To implement a sub-type of this you need to implement the methods below.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.Scenarios","page":"API","title":"InfrastructureSystems.Scenarios","text":"mutable struct Scenarios <: Forecast\n    name::String\n    resolution::Dates.Period\n    interval::Dates.Period\n    scenario_count::Int\n    data::SortedDict\n    scaling_factor_multiplier::Union{Nothing, Function}\n    internal::InfrastructureSystemsInternal\nend\n\nA Discrete Scenario Based time series for a particular data field in a Component.\n\nArguments\n\nname::String: user-defined name\nresolution::Dates.Period: forecast resolution\ninterval::Dates.Period: forecast interval\nscenario_count::Int: Number of scenarios\ndata::SortedDict: timestamp - scalingfactor\nscaling_factor_multiplier::Union{Nothing, Function}: Applicable when the time series data are scaling factors. Called on the associated component to convert the values.\ninternal::InfrastructureSystemsInternal\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.Scenarios-Tuple{AbstractString, AbstractDict{Dates.DateTime, <:TimeSeries.TimeArray}}","page":"API","title":"InfrastructureSystems.Scenarios","text":"Scenarios(\n    name::AbstractString,\n    input_data::AbstractDict{Dates.DateTime, <:TimeSeries.TimeArray};\n    resolution,\n    interval,\n    normalization_factor,\n    scaling_factor_multiplier\n) -> InfrastructureSystems.Scenarios\n\n\nConstruct Scenarios from a Dict of TimeArrays.\n\nArguments\n\nname::AbstractString: user-defined name\ninput_data::AbstractDict{Dates.DateTime, TimeSeries.TimeArray}: time series data.\nresolution::Union{Nothing, Dates.Period} = nothing: If nothing, infer resolution from the data. Otherwise, it must be the difference between each consecutive timestamps. Resolution is required if the type is irregular, such as with Dates.Month or Dates.Year.\ninterval::Union{Nothing, Dates.Period} = nothing: If nothing, infer interval from the data. Otherwise, it must be the difference in time between the start of each window. Interval is required if the type is irregular, such as with Dates.Month or Dates.Year.\nnormalization_factor::NormalizationFactor = 1.0: optional normalization factor to apply to each data entry\nscaling_factor_multiplier::Union{Nothing, Function} = nothing: If the data are scaling factors then this function will be called on the component and applied to the data when get_time_series_array is called.\ntimestamp = :timestamp: If the values are DataFrames is passed then this must be the column name that contains timestamps.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Scenarios-Tuple{AbstractString, DataStructures.SortedDict{Dates.DateTime, Matrix{Float64}}, Dates.Period}","page":"API","title":"InfrastructureSystems.Scenarios","text":"Scenarios(\n    name::AbstractString,\n    data::DataStructures.SortedDict{Dates.DateTime, Matrix{Float64}},\n    resolution::Dates.Period;\n    interval,\n    normalization_factor,\n    scaling_factor_multiplier\n) -> InfrastructureSystems.Scenarios\n\n\nConstruct Scenarios from a SortedDict of Arrays.\n\nArguments\n\nname::AbstractString: user-defined name\ninput_data::SortedDict{Dates.DateTime, Matrix{Float64}}: time series data.\nresolution::Dates.Period: The resolution of the forecast in Dates.Period\ninterval::Union{Nothing, Dates.Period}: If nothing, infer interval from the data. Otherwise, this must be the difference in time between the start of each window. Interval is required if the type is irregular, such as with Dates.Month or Dates.Year.\nnormalization_factor::NormalizationFactor = 1.0: optional normalization factor to apply to each data entry\nscaling_factor_multiplier::Union{Nothing, Function} = nothing: If the data are scaling factors then this function will be called on the component and applied to the data when get_time_series_array is called.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Scenarios-Tuple{InfrastructureSystems.Scenarios, AbstractString}","page":"API","title":"InfrastructureSystems.Scenarios","text":"Scenarios(\n    src::InfrastructureSystems.Scenarios,\n    name::AbstractString;\n    scaling_factor_multiplier\n) -> InfrastructureSystems.Scenarios\n\n\nConstruct Scenarios that shares the data from an existing instance.\n\nThis is useful in cases where you want a component to use the same time series data for two different attributes.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.ScenariosMetadata","page":"API","title":"InfrastructureSystems.ScenariosMetadata","text":"mutable struct ScenariosMetadata <: ForecastMetadata\n    name::String\n    resolution::Dates.Period\n    initial_timestamp::Dates.DateTime\n    interval::Dates.Period\n    scenario_count::Int64\n    count::Int\n    time_series_uuid::UUIDs.UUID\n    horizon::Dates.Period\n    scaling_factor_multiplier::Union{Nothing, Function}\n    features::Dict{String, Union{Bool, Int, String}}\n    internal::InfrastructureSystemsInternal\nend\n\nA Discrete Scenario Based time series for a particular data field in a Component.\n\nArguments\n\nname::String: user-defined name\nresolution::Dates.Period:\ninitial_timestamp::Dates.DateTime: time series availability time\ninterval::Dates.Period: time step between forecast windows\nscenario_count::Int64: Number of scenarios\ncount::Int: number of forecast windows\ntime_series_uuid::UUIDs.UUID: reference to time series data\nhorizon::Dates.Period: length of this time series\nscaling_factor_multiplier::Union{Nothing, Function}: (default: nothing) Applicable when the time series data are scaling factors. Called on the associated component to convert the values.\nfeatures::Dict{String, Union{Bool, Int, String}}: (default: Dict{String, Any}()) User-defined tags that differentiate multiple time series arrays that represent the same component attribute, such as different arrays for different scenarios or years.\ninternal::InfrastructureSystemsInternal:\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.SingleTimeSeries","page":"API","title":"InfrastructureSystems.SingleTimeSeries","text":"mutable struct SingleTimeSeries <: StaticTimeSeries\n    name::String\n    data::TimeSeries.TimeArray\n    scaling_factor_multiplier::Union{Nothing, Function}\n    internal::InfrastructureSystemsInternal\nend\n\nA single column of time series data for a particular data field in a Component.\n\nIn contrast with a forecast, this can represent one continual time series, such as a series of historical measurements or realizations or a single scenario (e.g. a weather year or different input assumptions).\n\nArguments\n\nname::String: user-defined name\ndata::TimeSeries.TimeArray: timestamp - scalingfactor\nresolution::Dates.Period: Time duration between steps in the time series. The resolution must be the same throughout the time series\nscaling_factor_multiplier::Union{Nothing, Function}: Applicable when the time series data are scaling factors. Called on the associated component to convert the values.\ninternal::InfrastructureSystemsInternal\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.SingleTimeSeries-Tuple{AbstractString, AbstractString, InfrastructureSystems.InfrastructureSystemsComponent, Dates.Period}","page":"API","title":"InfrastructureSystems.SingleTimeSeries","text":"SingleTimeSeries(\n    name::AbstractString,\n    filename::AbstractString,\n    component::InfrastructureSystems.InfrastructureSystemsComponent,\n    resolution::Dates.Period;\n    normalization_factor,\n    scaling_factor_multiplier\n) -> InfrastructureSystems.SingleTimeSeries\n\n\nConstruct SingleTimeSeries from a CSV file. The file must have a column that is the name of the component.\n\nArguments\n\nname::AbstractString: user-defined name\nfilename::AbstractString: name of CSV file containing data\ncomponent::InfrastructureSystemsComponent: component associated with the data\nresolution::Dates.Period: resolution of the time series\nnormalization_factor::NormalizationFactor = 1.0: optional normalization factor to apply to each data entry\nscaling_factor_multiplier::Union{Nothing, Function} = nothing: If the data are scaling factors then this function will be called on the component and applied to the data when get_time_series_array is called.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.SingleTimeSeries-Tuple{AbstractString, Union{DataFrames.DataFrame, TimeSeries.TimeArray}}","page":"API","title":"InfrastructureSystems.SingleTimeSeries","text":"SingleTimeSeries(\n    name::AbstractString,\n    data::Union{DataFrames.DataFrame, TimeSeries.TimeArray};\n    normalization_factor,\n    scaling_factor_multiplier,\n    timestamp,\n    resolution\n) -> InfrastructureSystems.SingleTimeSeries\n\n\nConstruct SingleTimeSeries from a TimeArray or DataFrame.\n\nArguments\n\nname::AbstractString: user-defined name\ndata::Union{TimeSeries.TimeArray, DataFrames.DataFrame}: time series data\nnormalization_factor::NormalizationFactor = 1.0: optional normalization factor to apply to each data entry\nscaling_factor_multiplier::Union{Nothing, Function} = nothing: If the data are scaling factors then this function will be called on the component and applied to the data when get_time_series_array is called.\ntimestamp::Symbol = :timestamp: If a DataFrame is passed then this must be the column name that contains timestamps.\nresolution::Union{Nothing, Dates.Period} = nothing: If nothing, infer resolution from the data. Otherwise, it must be the difference between each consecutive timestamps. Resolution is required if the resolution is irregular, such as with Dates.Month or Dates.Year.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.SingleTimeSeries-Tuple{InfrastructureSystems.SingleTimeSeries, AbstractString}","page":"API","title":"InfrastructureSystems.SingleTimeSeries","text":"SingleTimeSeries(\n    src::InfrastructureSystems.SingleTimeSeries,\n    name::AbstractString;\n    scaling_factor_multiplier\n) -> InfrastructureSystems.SingleTimeSeries\n\n\nConstruct SingleTimeSeries that shares the data from an existing instance.\n\nThis is useful in cases where you want a component to use the same time series data for two different attribtues.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.SingleTimeSeries-Tuple{InfrastructureSystems.SingleTimeSeries, TimeSeries.TimeArray}","page":"API","title":"InfrastructureSystems.SingleTimeSeries","text":"SingleTimeSeries(\n    time_series::InfrastructureSystems.SingleTimeSeries,\n    data::TimeSeries.TimeArray\n) -> Any\n\n\nCreates a new SingleTimeSeries from an existing instance and a subset of data.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.SingleTimeSeries-Tuple{String, Dates.Period, Dates.DateTime, Int64}","page":"API","title":"InfrastructureSystems.SingleTimeSeries","text":"SingleTimeSeries(\n    name::String,\n    resolution::Dates.Period,\n    initial_time::Dates.DateTime,\n    time_steps::Int64\n) -> InfrastructureSystems.SingleTimeSeries\n\n\nConstruct SingleTimeSeries after constructing a TimeArray from initial_time and time_steps.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.SingleTimeSeriesMetadata","page":"API","title":"InfrastructureSystems.SingleTimeSeriesMetadata","text":"mutable struct SingleTimeSeriesMetadata <: StaticTimeSeriesMetadata\n    name::String\n    resolution::Dates.Period\n    initial_timestamp::Dates.DateTime\n    time_series_uuid::UUIDs.UUID\n    length::Int\n    scaling_factor_multiplier::Union{Nothing, Function}\n    features::Dict{String, Union{Bool, Int, String}}\n    internal::InfrastructureSystemsInternal\nend\n\nA TimeSeries Data object in contigous form.\n\nArguments\n\nname::String: user-defined name\nresolution::Dates.Period:\ninitial_timestamp::Dates.DateTime: time series availability time\ntime_series_uuid::UUIDs.UUID: reference to time series data\nlength::Int: length of this time series\nscaling_factor_multiplier::Union{Nothing, Function}: (default: nothing) Applicable when the time series data are scaling factors. Called on the associated component to convert the values.\nfeatures::Dict{String, Union{Bool, Int, String}}: (default: Dict{String, Any}()) User-defined tags that differentiate multiple time series arrays that represent the same component attribute, such as different arrays for different scenarios or years.\ninternal::InfrastructureSystemsInternal:\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.SingularComponentSelector","page":"API","title":"InfrastructureSystems.SingularComponentSelector","text":"ComponentSelector subtype that can only refer to zero or one components. get_components will always return zero or one components; get_component will return the component directly if there is one and return nothing if there is not.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.StaticTimeSeries","page":"API","title":"InfrastructureSystems.StaticTimeSeries","text":"Supertype for static time series, which has one value per time point\n\nCurrent concrete subtypes are:\n\nSingleTimeSeries\n\nSee also: Forecast\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.StaticTimeSeriesCache-Union{Tuple{T}, Tuple{Type{T}, InfrastructureSystems.InfrastructureSystemsComponent, AbstractString}} where T<:InfrastructureSystems.StaticTimeSeries","page":"API","title":"InfrastructureSystems.StaticTimeSeriesCache","text":"Construct StaticTimeSeriesCache to automatically control caching of time series data. Maintains rows of data in memory based on cache_size_bytes.\n\nCall Base.iterate or get_time_series_array to retrieve data. Each iteration will return a TimeSeries.TimeArray of size 1.\n\nArguments\n\n::Type{T}: subtype of StaticTimeSeries\ncomponent::InfrastructureSystemsComponent: component\nname::AbstractString: time series name\ncache_size_bytes = TIME_SERIES_CACHE_SIZE_BYTES: maximum size of data to keep in memory\nignore_scaling_factors = false: controls whether to ignore scaling_factor_multiplier in the time series instance\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.StaticTimeSeriesKey","page":"API","title":"InfrastructureSystems.StaticTimeSeriesKey","text":"A unique key to identify and retrieve a StaticTimeSeries\n\nSee: get_time_series_keys and get_time_series(::TimeSeriesOwners, ::TimeSeriesKey).\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.StructDefinition-Tuple{}","page":"API","title":"InfrastructureSystems.StructDefinition","text":"StructDefinition(\n;\n    struct_name,\n    fields,\n    supertype,\n    docstring,\n    is_component\n)\n\n\nConstruct a StructDefinition for code auto-generation purposes.\n\nArguments\n\nstruct_name::AbstractString: Struct name\nfields::Vector{StructField}: Struct fields. Refer to StructField.\ndocstring::AbstractString: Struct docstring. Defaults to an empty string.\nsupertype::Union{String, DataType}: Struct supertype. Defaults to no supertype.\nis_component::Bool: Set to true for component types that will be attached to a system. Do not set to Default to true.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.StructField-Tuple{}","page":"API","title":"InfrastructureSystems.StructField","text":"StructField(\n;\n    name,\n    data_type,\n    default,\n    comment,\n    needs_conversion,\n    exclude_setter,\n    valid_range,\n    validation_action,\n    null_value,\n    internal_default\n)\n\n\nConstruct a StructField for code auto-generation purposes.\n\nArguments\n\nname::String: Field name\ndata_type::Union{DataType, String}: Field type\ndefault::Any: The generated constructors will define this as a default value.\ncomment::String: Include this comment above the field name. Defaults to empty string.\nneeds_conversion::Bool: Set to true if the getter and setter functions need to apply unit conversion. The type must implement get_value(::Component, ::Type) and set_value(::Component, ::Type) for this combination of component type and field type.\nexclude_setter::Bool: Do not generate a setter function for this field. Defaults to false.\nvalid_range::Union{Nothing, String, Dict}: Enables range validation when the component is added to a system. Define this as a Dict with \"min\" and \"max\" or as a String with the field name in the struct that defines this field's valid range and InfrastructureSystems will validate any value against that range. Use nothing if one doesn't apply, such as if there is no max limit.\nvalidation_action: Define this as \"error\" or \"warn\". If it is \"error\" then InfrastructureSystems will throw an exception if the validation code detects a problem. Otherwise, it will log a warning.\nnull_value::Any: Value to indicate the field is zero or empty, such as 0.0 for Float64. If all members in the struct define this field then a \"demo\" constructor will be generated. This allows entering val = MyType(nothing) in the REPL to see the layout of a struct without worrying about valid values.\ninternal_default: Set to true for non-user-facing fields like InfrastructureSystemsInternal that have default values.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.SupplementalAttribute","page":"API","title":"InfrastructureSystems.SupplementalAttribute","text":"Base type for structs that store supplemental attributes\n\nRequired interface functions for subtypes:\n\nget_internal()\n\nOptional interface functions:\n\nget_uuid()\n\nSubtypes may contain time series. Which requires\n\nsupports_time_series(::SupplementalAttribute)\n\nAll subtypes must include an instance of ComponentUUIDs in order to track components attached to each attribute.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.SupplementalAttributeAssociations-Tuple{}","page":"API","title":"InfrastructureSystems.SupplementalAttributeAssociations","text":"SupplementalAttributeAssociations(\n;\n    create_indexes\n) -> InfrastructureSystems.SupplementalAttributeAssociations\n\n\nConstruct a new SupplementalAttributeAssociations with an in-memory database.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.SystemData","page":"API","title":"InfrastructureSystems.SystemData","text":"mutable struct SystemData <: ComponentContainer\n    components::Components\n    \"Masked components are attached to the system for overall management purposes but\n    are not exposed in the standard library calls like [`get_components`](@ref).\n    Examples are components in a subsystem.\"\n    masked_components::Components\n    validation_descriptors::Vector\n    internal::InfrastructureSystemsInternal\nend\n\nContainer for system components and time series data\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.SystemData-Tuple{}","page":"API","title":"InfrastructureSystems.SystemData","text":"SystemData(\n;\n    validation_descriptor_file,\n    time_series_in_memory,\n    time_series_directory,\n    compression\n) -> InfrastructureSystems.SystemData\n\n\nConstruct SystemData to store components and time series data.\n\nArguments\n\nvalidation_descriptor_file = nothing: Optionally, a file defining component validation descriptors.\ntime_series_in_memory = false: Controls whether time series data is stored in memory or in a file.\ntime_series_directory = nothing: Controls what directory time series data is stored in. Default is the environment variable SIENNA_TIME_SERIES_DIRECTORY or tempdir() if that isn't set.\ncompression = CompressionSettings(): Controls compression of time series data.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.TimeSeriesAssociation","page":"API","title":"InfrastructureSystems.TimeSeriesAssociation","text":"Defines an association between a time series owner (component or supplemental attribute) and the time series metadata.\n\nExamples\n\nassociation1 = TimeSeriesAssociation(component, time_series)\nassociation2 = TimeSeriesAssociation(component, time_series, scenario = \"high\")\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.TimeSeriesCounts","page":"API","title":"InfrastructureSystems.TimeSeriesCounts","text":"Provides counts of time series including attachments to components and supplemental attributes.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.TimeSeriesData","page":"API","title":"InfrastructureSystems.TimeSeriesData","text":"Abstract type for time series stored in the system. Components store references to these through TimeSeriesMetadata values so that data can reside on storage media instead of memory.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.TimeSeriesFileMetadata","page":"API","title":"InfrastructureSystems.TimeSeriesFileMetadata","text":"Describes how to construct time_series from raw time series data files.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.TimeSeriesKey","page":"API","title":"InfrastructureSystems.TimeSeriesKey","text":"Supertype for keys that can be used to access a desired time series dataset\n\nConcrete subtypes:\n\nStaticTimeSeriesKey\nForecastKey\n\nRequired methods:\n\nget_name\nget_resolution\nget_time_series_type\n\nThe default methods rely on the field names name and time_series_type.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.TimeSeriesMetadata","page":"API","title":"InfrastructureSystems.TimeSeriesMetadata","text":"Abstract type for time_series that are stored in a system. Users never create them or get access to them. Stores references to TimeSeriesData.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.TimeSeriesMetadataStore-Tuple{AbstractString}","page":"API","title":"InfrastructureSystems.TimeSeriesMetadataStore","text":"TimeSeriesMetadataStore(\n    filename::AbstractString\n) -> InfrastructureSystems.TimeSeriesMetadataStore\n\n\nLoad a TimeSeriesMetadataStore from a saved database into an in-memory database.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.TimeSeriesMetadataStore-Tuple{}","page":"API","title":"InfrastructureSystems.TimeSeriesMetadataStore","text":"TimeSeriesMetadataStore(\n\n) -> InfrastructureSystems.TimeSeriesMetadataStore\n\n\nConstruct a new TimeSeriesMetadataStore with an in-memory database.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.TimeSeriesStorage","page":"API","title":"InfrastructureSystems.TimeSeriesStorage","text":"Abstract type for time series storage implementations.\n\nAll subtypes must implement:\n\nclear_time_series!\ndeserialize_time_series\nget_compression_settings\nget_num_time_series\nremove_time_series!\nserialize_time_series!\nBase.isempty\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.TypeComponentSelector","page":"API","title":"InfrastructureSystems.TypeComponentSelector","text":"ComponentSelector represented by a type of component. Contains all the components of that type, grouped by the groupby field (see make_selector).\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.ValueCurve","page":"API","title":"InfrastructureSystems.ValueCurve","text":"Supertype that represents a unitless cost curve\n\nConcrete subtypes are:\n\nLinearCurve\nQuadraticCurve\nPiecewisePointCurve\nPiecewiseIncrementalCurve\nPiecewiseAverageCurve\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#Base.:*-Tuple{InfrastructureSystems.FunctionData, Real}","page":"API","title":"Base.:*","text":"*(fd::InfrastructureSystems.FunctionData, c::Real) -> Any\n\n\nMultiply the FunctionData by a scalar: (f * c)(x) = (c * f)(x) = c * f(x)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.:*-Tuple{Real, InfrastructureSystems.LinearFunctionData}","page":"API","title":"Base.:*","text":"*(\n    c::Real,\n    fd::InfrastructureSystems.LinearFunctionData\n) -> InfrastructureSystems.LinearFunctionData\n\n\nMultiply the LinearFunctionData by a scalar: (c * f)(x) = c * f(x)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.:*-Tuple{Real, InfrastructureSystems.PiecewiseLinearData}","page":"API","title":"Base.:*","text":"*(\n    c::Real,\n    fd::InfrastructureSystems.PiecewiseLinearData\n) -> InfrastructureSystems.PiecewiseLinearData\n\n\nMultiply the PiecewiseLinearData by a scalar: (c * f)(x) = c * f(x)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.:*-Tuple{Real, InfrastructureSystems.PiecewiseStepData}","page":"API","title":"Base.:*","text":"*(\n    c::Real,\n    fd::InfrastructureSystems.PiecewiseStepData\n) -> InfrastructureSystems.PiecewiseStepData\n\n\nMultiply the PiecewiseStepData by a scalar: (c * f)(x) = c * f(x)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.:*-Tuple{Real, InfrastructureSystems.QuadraticFunctionData}","page":"API","title":"Base.:*","text":"*(\n    c::Real,\n    fd::InfrastructureSystems.QuadraticFunctionData\n) -> InfrastructureSystems.QuadraticFunctionData\n\n\nMultiply the QuadraticFunctionData by a scalar: (c * f)(x) = c * f(x)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.:+-Tuple{InfrastructureSystems.LinearFunctionData, InfrastructureSystems.LinearFunctionData}","page":"API","title":"Base.:+","text":"+(\n    f::InfrastructureSystems.LinearFunctionData,\n    g::InfrastructureSystems.LinearFunctionData\n) -> InfrastructureSystems.LinearFunctionData\n\n\nAdd two LinearFunctionDatas: (f + g)(x) = f(x) + g(x)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.:+-Tuple{InfrastructureSystems.LinearFunctionData, Real}","page":"API","title":"Base.:+","text":"+(\n    fd::InfrastructureSystems.LinearFunctionData,\n    c::Real\n) -> InfrastructureSystems.LinearFunctionData\n\n\nAdd a scalar to the LinearFunctionData: (f + c)(x) = f(x) + c\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.:+-Tuple{InfrastructureSystems.PiecewiseLinearData, InfrastructureSystems.PiecewiseLinearData}","page":"API","title":"Base.:+","text":"+(\n    f::InfrastructureSystems.PiecewiseLinearData,\n    g::InfrastructureSystems.PiecewiseLinearData\n) -> InfrastructureSystems.PiecewiseLinearData\n\n\nAdd two PiecewiseLinearDatas: (f + g)(x) = f(x) + g(x). Errors if the x-coordinates are not the same.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.:+-Tuple{InfrastructureSystems.PiecewiseLinearData, Real}","page":"API","title":"Base.:+","text":"+(\n    fd::InfrastructureSystems.PiecewiseLinearData,\n    c::Real\n) -> InfrastructureSystems.PiecewiseLinearData\n\n\nAdd a scalar to the PiecewiseLinearData: (f + c)(x) = f(x) + c\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.:+-Tuple{InfrastructureSystems.PiecewiseStepData, InfrastructureSystems.PiecewiseStepData}","page":"API","title":"Base.:+","text":"+(\n    f::InfrastructureSystems.PiecewiseStepData,\n    g::InfrastructureSystems.PiecewiseStepData\n) -> InfrastructureSystems.PiecewiseStepData\n\n\nAdd two PiecewiseStepDatas: (f + g)(x) = f(x) + g(x). Errors if the x-coordinates are not the same.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.:+-Tuple{InfrastructureSystems.PiecewiseStepData, Real}","page":"API","title":"Base.:+","text":"+(\n    fd::InfrastructureSystems.PiecewiseStepData,\n    c::Real\n) -> InfrastructureSystems.PiecewiseStepData\n\n\nAdd a scalar to the PiecewiseStepData: (f + c)(x) = f(x) + c\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.:+-Tuple{InfrastructureSystems.QuadraticFunctionData, InfrastructureSystems.QuadraticFunctionData}","page":"API","title":"Base.:+","text":"+(\n    f::InfrastructureSystems.QuadraticFunctionData,\n    g::InfrastructureSystems.QuadraticFunctionData\n) -> InfrastructureSystems.QuadraticFunctionData\n\n\nAdd two QuadraticFunctionDatas: (f + g)(x) = f(x) + g(x)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.:+-Tuple{InfrastructureSystems.QuadraticFunctionData, Real}","page":"API","title":"Base.:+","text":"+(\n    fd::InfrastructureSystems.QuadraticFunctionData,\n    c::Real\n) -> InfrastructureSystems.QuadraticFunctionData\n\n\nAdd a scalar to the QuadraticFunctionData: (f + c)(x) = f(x) + c\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.:+-Tuple{Real, InfrastructureSystems.FunctionData}","page":"API","title":"Base.:+","text":"+(c::Real, fd::InfrastructureSystems.FunctionData) -> Any\n\n\nAdd a scalar to the FunctionData: (c + f)(x) = (f + c)(x) = f(x) + c\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.:--Tuple{InfrastructureSystems.FunctionData}","page":"API","title":"Base.:-","text":"-(fd::InfrastructureSystems.FunctionData) -> Any\n\n\nNegate the FunctionData: (-f)(x) = -f(x)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.:<<-Tuple{InfrastructureSystems.FunctionData, Real}","page":"API","title":"Base.:<<","text":"<<(fd::InfrastructureSystems.FunctionData, c::Real) -> Any\n\n\nLeft shift the FunctionData by a scalar: (f << c)(x) = (f >> -c)(x) = f(x + c)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.:>>-Tuple{InfrastructureSystems.LinearFunctionData, Real}","page":"API","title":"Base.:>>","text":">>(\n    fd::InfrastructureSystems.LinearFunctionData,\n    c::Real\n) -> InfrastructureSystems.LinearFunctionData\n\n\nRight shift the LinearFunctionData by a scalar: (f >> c)(x) = f(x - c)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.:>>-Tuple{InfrastructureSystems.PiecewiseLinearData, Real}","page":"API","title":"Base.:>>","text":">>(\n    fd::InfrastructureSystems.PiecewiseLinearData,\n    c::Real\n) -> InfrastructureSystems.PiecewiseLinearData\n\n\nRight shift the PiecewiseLinearData by a scalar: (f >> c)(x) = f(x - c)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.:>>-Tuple{InfrastructureSystems.PiecewiseStepData, Real}","page":"API","title":"Base.:>>","text":">>(\n    fd::InfrastructureSystems.PiecewiseStepData,\n    c::Real\n) -> InfrastructureSystems.PiecewiseStepData\n\n\nRight shift the PiecewiseStepData by a scalar: (f >> c)(x) = f(x - c)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.:>>-Tuple{InfrastructureSystems.QuadraticFunctionData, Real}","page":"API","title":"Base.:>>","text":">>(\n    fd::InfrastructureSystems.QuadraticFunctionData,\n    c::Real\n) -> InfrastructureSystems.QuadraticFunctionData\n\n\nRight shift the QuadraticFunctionData by a scalar: (f >> c)(x) = f(x - c)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.:~-Tuple{InfrastructureSystems.LinearFunctionData}","page":"API","title":"Base.:~","text":"~(\n    fd::InfrastructureSystems.LinearFunctionData\n) -> InfrastructureSystems.LinearFunctionData\n\n\nFlip the LinearFunctionData about the y-axis: (~f)(x) = f(-x)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.:~-Tuple{InfrastructureSystems.PiecewiseLinearData}","page":"API","title":"Base.:~","text":"~(\n    fd::InfrastructureSystems.PiecewiseLinearData\n) -> InfrastructureSystems.PiecewiseLinearData\n\n\nFlip the PiecewiseLinearData about the y-axis: (~f)(x) = f(-x)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.:~-Tuple{InfrastructureSystems.PiecewiseStepData}","page":"API","title":"Base.:~","text":"~(\n    fd::InfrastructureSystems.PiecewiseStepData\n) -> InfrastructureSystems.PiecewiseStepData\n\n\nFlip the PiecewiseStepData about the y-axis: (~f)(x) = f(-x)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.:~-Tuple{InfrastructureSystems.QuadraticFunctionData}","page":"API","title":"Base.:~","text":"~(\n    fd::InfrastructureSystems.QuadraticFunctionData\n) -> InfrastructureSystems.QuadraticFunctionData\n\n\nFlip the QuadraticFunctionData about the y-axis: (~f)(x) = f(-x)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.close-Tuple{InfrastructureSystems.MultiLogger}","page":"API","title":"Base.close","text":"close(logger::InfrastructureSystems.MultiLogger)\n\n\nEnsures that any file streams are flushed and closed.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.convert-Tuple{Type{InfrastructureSystems.QuadraticFunctionData}, InfrastructureSystems.LinearFunctionData}","page":"API","title":"Base.convert","text":"convert(\n    _::Type{InfrastructureSystems.QuadraticFunctionData},\n    data::InfrastructureSystems.LinearFunctionData\n) -> InfrastructureSystems.QuadraticFunctionData\n\n\nLosslessly convert LinearFunctionData to QuadraticFunctionData\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.flush-Tuple{InfrastructureSystems.MultiLogger}","page":"API","title":"Base.flush","text":"flush(logger::InfrastructureSystems.MultiLogger)\n\n\nFlush any file streams.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.get-Union{Tuple{K}, Tuple{InfrastructureSystems.LazyDictFromIterator, K}} where K","page":"API","title":"Base.get","text":"get(\n    container::InfrastructureSystems.LazyDictFromIterator,\n    key\n) -> Any\n\n\nReturns the item mapped to key. If the key is already stored then it will be returned with a dictionary lookup. If it has not been stored then iterate over the list until it is found.\n\nReturns nothing if key is not found.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.zero-Tuple{InfrastructureSystems.PiecewiseLinearData}","page":"API","title":"Base.zero","text":"zero(\n    fd::InfrastructureSystems.PiecewiseLinearData\n) -> InfrastructureSystems.PiecewiseLinearData\n\n\nGet a PiecewiseLinearData with the same x-coordinates as fd but y-coordinates equal to zero\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.zero-Tuple{InfrastructureSystems.PiecewiseStepData}","page":"API","title":"Base.zero","text":"zero(\n    fd::InfrastructureSystems.PiecewiseStepData\n) -> InfrastructureSystems.PiecewiseStepData\n\n\nGet a PiecewiseStepData with the same x-coordinates as fd and y-coordinates equal to zero\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.zero-Tuple{Type{InfrastructureSystems.PiecewiseLinearData}}","page":"API","title":"Base.zero","text":"zero(\n    ::Type{InfrastructureSystems.PiecewiseLinearData};\n    domain\n) -> InfrastructureSystems.PiecewiseLinearData\n\n\nGet a PiecewiseLinearData representing the function f(x) = 0; optionally specify domain tuple to set the x-coordinates of the endpoints\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.zero-Tuple{Type{InfrastructureSystems.PiecewiseStepData}}","page":"API","title":"Base.zero","text":"zero(\n    ::Type{InfrastructureSystems.PiecewiseStepData};\n    domain\n) -> InfrastructureSystems.PiecewiseStepData\n\n\nGet a PiecewiseStepData representing the function f(x) = 0; optionally specify domain tuple to set the x-coordinates of the endpoints\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.zero-Tuple{Union{InfrastructureSystems.LinearFunctionData, Type{InfrastructureSystems.LinearFunctionData}}}","page":"API","title":"Base.zero","text":"zero(\n    _::Union{InfrastructureSystems.LinearFunctionData, Type{InfrastructureSystems.LinearFunctionData}}\n) -> InfrastructureSystems.LinearFunctionData\n\n\nGet a LinearFunctionData representing the function f(x) = 0\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.zero-Tuple{Union{InfrastructureSystems.QuadraticFunctionData, Type{InfrastructureSystems.QuadraticFunctionData}}}","page":"API","title":"Base.zero","text":"zero(\n    _::Union{InfrastructureSystems.QuadraticFunctionData, Type{InfrastructureSystems.QuadraticFunctionData}}\n) -> InfrastructureSystems.QuadraticFunctionData\n\n\nGet a QuadraticFunctionData representing the function f(x) = 0\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.zero-Tuple{Union{Type{InfrastructureSystems.AverageRateCurve}, InfrastructureSystems.AverageRateCurve}}","page":"API","title":"Base.zero","text":"zero(\n    _::Union{Type{InfrastructureSystems.AverageRateCurve}, InfrastructureSystems.AverageRateCurve}\n) -> InfrastructureSystems.AverageRateCurve{InfrastructureSystems.LinearFunctionData}\n\n\nGet an AverageRateCurve representing f(x)/x = 0 with zero initial_input\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.zero-Tuple{Union{Type{InfrastructureSystems.CostCurve}, InfrastructureSystems.CostCurve}}","page":"API","title":"Base.zero","text":"zero(\n    _::Union{Type{InfrastructureSystems.CostCurve}, InfrastructureSystems.CostCurve}\n) -> InfrastructureSystems.CostCurve{LinearCurve}\n\n\nGet a CostCurve representing zero variable cost\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.zero-Tuple{Union{Type{InfrastructureSystems.FuelCurve}, InfrastructureSystems.FuelCurve}}","page":"API","title":"Base.zero","text":"zero(\n    _::Union{Type{InfrastructureSystems.FuelCurve}, InfrastructureSystems.FuelCurve}\n) -> InfrastructureSystems.FuelCurve{LinearCurve}\n\n\nGet a FuelCurve representing zero fuel usage and zero fuel cost\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.zero-Tuple{Union{Type{InfrastructureSystems.FunctionData}, InfrastructureSystems.FunctionData}}","page":"API","title":"Base.zero","text":"zero(\n    _::Union{Type{InfrastructureSystems.FunctionData}, InfrastructureSystems.FunctionData}\n) -> InfrastructureSystems.PiecewiseStepData\n\n\nGet a FunctionData representing the function f(x) = 0\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.zero-Tuple{Union{Type{InfrastructureSystems.IncrementalCurve}, InfrastructureSystems.IncrementalCurve}}","page":"API","title":"Base.zero","text":"zero(\n    _::Union{Type{InfrastructureSystems.IncrementalCurve}, InfrastructureSystems.IncrementalCurve}\n) -> InfrastructureSystems.IncrementalCurve{InfrastructureSystems.LinearFunctionData}\n\n\nGet an IncrementalCurve representing f'(x) = 0 with zero initial_input\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.zero-Tuple{Union{Type{InfrastructureSystems.InputOutputCurve}, InfrastructureSystems.InputOutputCurve}}","page":"API","title":"Base.zero","text":"zero(\n    _::Union{Type{InfrastructureSystems.InputOutputCurve}, InfrastructureSystems.InputOutputCurve}\n) -> LinearCurve\n\n\nGet an InputOutputCurve representing f(x) = 0\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.zero-Tuple{Union{Type{InfrastructureSystems.ValueCurve}, InfrastructureSystems.ValueCurve}}","page":"API","title":"Base.zero","text":"zero(\n    _::Union{Type{InfrastructureSystems.ValueCurve}, InfrastructureSystems.ValueCurve}\n) -> LinearCurve\n\n\nGet a ValueCurve representing zero variable cost\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems._check_transform_single_time_series-Tuple{InfrastructureSystems.SystemData, Type{InfrastructureSystems.DeterministicSingleTimeSeries}, Dates.Period, Dates.Period, Union{Nothing, Dates.Period}}","page":"API","title":"InfrastructureSystems._check_transform_single_time_series","text":"_check_transform_single_time_series(\n    data::InfrastructureSystems.SystemData,\n    _::Type{InfrastructureSystems.DeterministicSingleTimeSeries},\n    horizon::Dates.Period,\n    interval::Dates.Period,\n    resolution::Union{Nothing, Dates.Period}\n) -> Vector{Any}\n\n\nCheck that all existing SingleTimeSeries can be converted to DeterministicSingleTimeSeries with the given horizon and interval.\n\nThrow ConflictingInputsError if any time series cannot be converted.\n\nReturn a Vector of NamedTuple of component, time series metadata, and forecast parameters for all matches.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems._compute_convex_weights-Tuple{Vector{Float64}, Symbol}","page":"API","title":"InfrastructureSystems._compute_convex_weights","text":"_compute_convex_weights(\n    x_coords::Vector{Float64},\n    weights::Symbol\n) -> Vector{Float64}\n\n\nCompute weights for isotonic regression based on the weighting scheme.\n\nArguments\n\nx_coords::Vector{Float64}: x-coordinates of the piecewise data\nweights::Symbol: weighting scheme\n:uniform - all segments weighted equally\n:length - segments weighted by their x-length (default)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems._get_all_concrete_subtypes-Union{Tuple{T}, Tuple{Type{T}, Vector{DataType}}} where T","page":"API","title":"InfrastructureSystems._get_all_concrete_subtypes","text":"_get_all_concrete_subtypes(\n    _::Type{T},\n    sub_types::Vector{DataType}\n)\n\n\nRecursively builds a vector of subtypes.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems._make_group-NTuple{4, Any}","page":"API","title":"InfrastructureSystems._make_group","text":"_make_group(\n    all_components,\n    partition_results,\n    group_result,\n    group_name\n) -> Any\n\n\nMake a ComponentSelector containing the components in all_components whose corresponding entry of partition_results matches group_result\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems._reconstruct_points-Tuple{Vector{@NamedTuple{x::Float64, y::Float64}}, Vector{Float64}, Symbol}","page":"API","title":"InfrastructureSystems._reconstruct_points","text":"_reconstruct_points(\n    original_points::Vector{@NamedTuple{x::Float64, y::Float64}},\n    new_slopes::Vector{Float64},\n    anchor::Symbol\n) -> Vector{@NamedTuple{x::Float64, y::Float64}}\n\n\n_reconstruct_points(original_points, new_slopes, anchor) -> Vector{XY_COORDS}\n\nReconstruct points from new slopes, preserving the anchor point.\n\nAfter isotonic regression modifies the slopes, we need to reconstruct the y-coordinates. The anchor parameter determines which point to preserve exactly:\n\n:first - preserve first point, propagate forward using new slopes\n:last - preserve last point, propagate backward using new slopes\n:centroid - minimize total vertical displacement from original points\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems._validate-Union{Tuple{T}, Tuple{InfrastructureSystems.SystemData, T}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems._validate","text":"_validate(\n    data::InfrastructureSystems.SystemData,\n    component::InfrastructureSystems.InfrastructureSystemsComponent\n)\n\n\nChecks that the component exists in data and is the same object.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.add_association!-Tuple{InfrastructureSystems.SupplementalAttributeAssociations, InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}","page":"API","title":"InfrastructureSystems.add_association!","text":"add_association!(\n    associations::InfrastructureSystems.SupplementalAttributeAssociations,\n    component::InfrastructureSystems.InfrastructureSystemsComponent,\n    attribute::InfrastructureSystems.SupplementalAttribute\n)\n\n\nAdd a supplemental attribute association to the associations. The caller must check for duplicates.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.add_component!-Union{Tuple{T}, Tuple{InfrastructureSystems.Components, T}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.add_component!","text":"add_component!(\n    components::InfrastructureSystems.Components,\n    component::InfrastructureSystems.InfrastructureSystemsComponent;\n    kwargs...\n)\n\n\nAdd a component.\n\nThrows ArgumentError if the component's name is already stored for its concrete type.\n\nThrows InvalidRange if any of the component's field values are outside of defined valid range.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.add_component_to_subsystem!-Tuple{InfrastructureSystems.SystemData, AbstractString, InfrastructureSystems.InfrastructureSystemsComponent}","page":"API","title":"InfrastructureSystems.add_component_to_subsystem!","text":"add_component_to_subsystem!(\n    data::InfrastructureSystems.SystemData,\n    subsystem_name::AbstractString,\n    component::InfrastructureSystems.InfrastructureSystemsComponent\n)\n\n\nAdd a component to a subsystem.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.add_metadata!-Tuple{InfrastructureSystems.TimeSeriesMetadataStore, Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}, InfrastructureSystems.TimeSeriesMetadata}","page":"API","title":"InfrastructureSystems.add_metadata!","text":"add_metadata!(\n    store::InfrastructureSystems.TimeSeriesMetadataStore,\n    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute},\n    metadata::InfrastructureSystems.TimeSeriesMetadata\n)\n\n\nAdd metadata to the store. The caller must check if there are duplicates.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.add_serialization_metadata!-Union{Tuple{T}, Tuple{Dict, Type{T}}} where T","page":"API","title":"InfrastructureSystems.add_serialization_metadata!","text":"add_serialization_metadata!(data::Dict, _::Type{T})\n\n\nAdd type information to the dictionary that can be used to deserialize the value.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.add_subsystem!-Tuple{InfrastructureSystems.SystemData, AbstractString}","page":"API","title":"InfrastructureSystems.add_subsystem!","text":"add_subsystem!(\n    data::InfrastructureSystems.SystemData,\n    subsystem_name::AbstractString\n)\n\n\nAdd a new subsystem to the system.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.add_time_series!-Tuple{InfrastructureSystems.SystemData, Any, InfrastructureSystems.TimeSeriesData}","page":"API","title":"InfrastructureSystems.add_time_series!","text":"add_time_series!(\n    data::InfrastructureSystems.SystemData,\n    components,\n    time_series::InfrastructureSystems.TimeSeriesData;\n    features...\n) -> Union{InfrastructureSystems.ForecastKey, InfrastructureSystems.StaticTimeSeriesKey}\n\n\nAdd the same time series data to multiple components.\n\nArguments\n\ndata::SystemData: SystemData\ncomponents: iterable of components that will store the same time series reference\ntime_series::TimeSeriesData: Any object of subtype TimeSeriesData\n\nThis is significantly more efficent than calling add_time_series! for each component individually with the same data because in this case, only one time series array is stored.\n\nThrows ArgumentError if a component is not stored in the system.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.add_time_series!-Tuple{InfrastructureSystems.SystemData, Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}, InfrastructureSystems.TimeSeriesData}","page":"API","title":"InfrastructureSystems.add_time_series!","text":"add_time_series!(\n    data::InfrastructureSystems.SystemData,\n    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute},\n    time_series::InfrastructureSystems.TimeSeriesData;\n    features...\n) -> Union{InfrastructureSystems.ForecastKey, InfrastructureSystems.StaticTimeSeriesKey}\n\n\nAdd time series data to a component or supplemental attribute.\n\nArguments\n\ndata::SystemData: SystemData\nowner::InfrastructureSystemsComponent: will store the time series reference\ntime_series::TimeSeriesData: Any object of subtype TimeSeriesData\n\nThrows ArgumentError if the owner is not stored in the system.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.add_time_series_from_file_metadata!-Tuple{InfrastructureSystems.SystemData, Type{<:InfrastructureSystems.InfrastructureSystemsComponent}, Vector{InfrastructureSystems.TimeSeriesFileMetadata}}","page":"API","title":"InfrastructureSystems.add_time_series_from_file_metadata!","text":"add_time_series_from_file_metadata!(\n    data::InfrastructureSystems.SystemData,\n    component_type::Type{<:InfrastructureSystems.InfrastructureSystemsComponent},\n    file_metadata::Vector{InfrastructureSystems.TimeSeriesFileMetadata};\n    resolution\n) -> Vector{InfrastructureSystems.TimeSeriesKey}\n\n\nAdds time series data from a metadata file or metadata descriptors.\n\nArguments\n\ndata::SystemData: system\nfile_metadata::Vector{TimeSeriesFileMetadata}: metadata for time series\nresolution::DateTime.Period=nothing: skip time_series that don't match this resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.add_time_series_from_file_metadata!-Union{Tuple{T}, Tuple{InfrastructureSystems.SystemData, Type{T}, AbstractString}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.add_time_series_from_file_metadata!","text":"add_time_series_from_file_metadata!(\n    data::InfrastructureSystems.SystemData,\n    ::Type{T<:InfrastructureSystems.InfrastructureSystemsComponent},\n    metadata_file::AbstractString;\n    resolution\n) -> Vector{InfrastructureSystems.TimeSeriesKey}\n\n\nAdds time_series from a metadata file or metadata descriptors.\n\nArguments\n\ndata::SystemData: system\n::Type{T}: type of the component associated with time series data; may be abstract\nmetadata_file::AbstractString: metadata file for time series that includes an array of TimeSeriesFileMetadata instances or a vector.\nresolution::DateTime.Period=nothing: skip time_series that don't match this resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.approximation_error","page":"API","title":"InfrastructureSystems.approximation_error","text":"approximation_error(original, convexified; metric=:L2, weights=:length) -> Float64\n\nCompute the error between original piecewise data and its convex approximation.\n\nThis is useful for assessing the quality of a convexification: a lower error means the convex approximation is closer to the original non-convex curve.\n\nBoth arguments must have the same number of segments (same x-coordinates). When using make_convex_approximation, pass merge_colinear=false to preserve segment count for error computation.\n\nArguments\n\noriginal: original PiecewiseStepData or PiecewiseLinearData\nconvexified: the convex approximation (same type and same x-coordinates as original)\nmetric: error metric to use\n:L2 (default): weighted root mean square error\n:L1: weighted mean absolute error\n:Linf: maximum absolute error (unweighted)\nweights::Symbol: weighting scheme for the error computation\n:length (default): weight by segment x-extent\n:uniform: equal weights for all segments\n\nReturns\n\nThe computed error as a Float64. Returns 0.0 if the curves are identical.\n\n\n\n\n\n","category":"function"},{"location":"InfrastructureSystems/#InfrastructureSystems.assign_new_uuid_internal!-Tuple{InfrastructureSystems.InfrastructureSystemsComponent}","page":"API","title":"InfrastructureSystems.assign_new_uuid_internal!","text":"assign_new_uuid_internal!(\n    component::InfrastructureSystems.InfrastructureSystemsComponent\n)\n\n\nAssign a new UUID to the component.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.assign_new_uuid_internal!-Tuple{InfrastructureSystems.InfrastructureSystemsType}","page":"API","title":"InfrastructureSystems.assign_new_uuid_internal!","text":"assign_new_uuid_internal!(\n    obj::InfrastructureSystems.InfrastructureSystemsType\n)\n\n\nAssign a new UUID.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.available_and_fn-Tuple{Union{Nothing, Function}, Any}","page":"API","title":"InfrastructureSystems.available_and_fn","text":"available_and_fn(\n    fn::Union{Nothing, Function},\n    sys\n) -> Union{typeof(InfrastructureSystems.get_available), InfrastructureSystems.var\"#optional_and_fns##0#optional_and_fns##1\"{typeof(InfrastructureSystems.get_available), <:Function}}\n\n\nUse optional_and_fns to return a function that computes the conjunction of get_available and the given function\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.backup_to_temp-Tuple{InfrastructureSystems.TimeSeriesMetadataStore}","page":"API","title":"InfrastructureSystems.backup_to_temp","text":"backup_to_temp(\n    store::InfrastructureSystems.TimeSeriesMetadataStore\n) -> String\n\n\nBackup the database to a file on the temporary filesystem and return that filename.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.begin_supplemental_attributes_update-Tuple{Function, InfrastructureSystems.SupplementalAttributeManager}","page":"API","title":"InfrastructureSystems.begin_supplemental_attributes_update","text":"begin_supplemental_attributes_update(\n    func::Function,\n    mgr::InfrastructureSystems.SupplementalAttributeManager\n)\n\n\nBegin an update of supplemental attributes. Use this function when adding or removing many supplemental attributes in order to improve performance.\n\nIf an error occurs during the update, changes will be reverted.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.begin_time_series_update-Tuple{Function, InfrastructureSystems.TimeSeriesManager}","page":"API","title":"InfrastructureSystems.begin_time_series_update","text":"begin_time_series_update(\n    func::Function,\n    mgr::InfrastructureSystems.TimeSeriesManager\n) -> Any\n\n\nBegin an update of time series. Use this function when adding many time series arrays in order to improve performance.\n\nIf an error occurs during the update, changes will be reverted.\n\nUsing this function to remove time series is currently not supported.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.check_consistency-Tuple{InfrastructureSystems.TimeSeriesMetadataStore, Type{InfrastructureSystems.SingleTimeSeries}}","page":"API","title":"InfrastructureSystems.check_consistency","text":"check_consistency(\n    store::InfrastructureSystems.TimeSeriesMetadataStore,\n    _::Type{InfrastructureSystems.SingleTimeSeries}\n) -> Tuple{Any, Any}\n\n\nThrow InvalidValue if the SingleTimeSeries arrays have different initial times or lengths. Return the initial timestamp and length as a tuple.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.check_resolution-Tuple{Any, Dates.Period}","page":"API","title":"InfrastructureSystems.check_resolution","text":"check_resolution(timestamps, resolution::Dates.Period)\n\n\nCheck if the timestamps have a constant resolution. Handles constant periods like Second and Minute as well as irregular periods like Month and Year. Relies on the calendrical arithmetic of the Julia's Dates library. https://docs.julialang.org/en/v1/stdlib/Dates/#TimeType-Period-Arithmetic\n\nArguments\n\ntimestamps: An indexable sequence of DateTime values\nresolution: a Dates.Period value\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.clear_components!-Tuple{InfrastructureSystems.Components}","page":"API","title":"InfrastructureSystems.clear_components!","text":"clear_components!(\n    components::InfrastructureSystems.Components\n)\n\n\nRemoves all components from the system.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.clear_ext!-Tuple{InfrastructureSystems.InfrastructureSystemsInternal}","page":"API","title":"InfrastructureSystems.clear_ext!","text":"clear_ext!(\n    obj::InfrastructureSystems.InfrastructureSystemsInternal\n)\n\n\nClear any value stored in ext.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.clear_metadata!-Tuple{InfrastructureSystems.TimeSeriesMetadataStore}","page":"API","title":"InfrastructureSystems.clear_metadata!","text":"clear_metadata!(\n    store::InfrastructureSystems.TimeSeriesMetadataStore\n) -> SQLite.Query\n\n\nClear all time series metadata from the store.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.clear_supplemental_attributes!-Tuple{InfrastructureSystems.SupplementalAttributeManager}","page":"API","title":"InfrastructureSystems.clear_supplemental_attributes!","text":"clear_supplemental_attributes!(\n    mgr::InfrastructureSystems.SupplementalAttributeManager\n)\n\n\nRemoves all supplemental_attributes from the system.\n\nIgnores whether attributes are attached to components.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.clear_supplemental_attributes!-Tuple{InfrastructureSystems.SystemData}","page":"API","title":"InfrastructureSystems.clear_supplemental_attributes!","text":"clear_supplemental_attributes!(\n    data::InfrastructureSystems.SystemData\n)\n\n\nRemove all supplemental attributes.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.compare_over_fields-Union{Tuple{T}, Tuple{Any, Any, Any, T, T}} where T","page":"API","title":"InfrastructureSystems.compare_over_fields","text":"compare_over_fields(cmp_op, reduce_op, init, a, b) -> Any\n\n\nFor a and b, instances of the same concrete type, iterate over all the fields, compare a's value to b's using cmp_op, and reduce to one value using reduce_op with an initialization value of init.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.compare_values-Union{Tuple{U}, Tuple{T}, Tuple{Union{Nothing, Function}, T, U}} where {T, U}","page":"API","title":"InfrastructureSystems.compare_values","text":"compare_values(\n    match_fn::Union{Nothing, Function},\n    x,\n    y;\n    compare_uuids,\n    exclude\n) -> Bool\n\n\nRecursively compares struct values. Prints all mismatched values to stdout.\n\nArguments\n\nmatch_fn: optional, a function used to determine whether two values match in the base case of the recursion. If nothing or not specified, the default implementation uses IS.isequivalent.\nx::T: First value\ny::U: Second value\ncompare_uuids::Bool = false: Compare any UUID in the object or composed objects.\n`exclude::Set{Symbol} = Set{Symbol}(): Fields to exclude from comparison. Passed on  recursively and so applied per type.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.component_to_qualified_string-Tuple{Type{<:InfrastructureSystems.InfrastructureSystemsComponent}, AbstractString}","page":"API","title":"InfrastructureSystems.component_to_qualified_string","text":"component_to_qualified_string(\n    component_type::Type{<:InfrastructureSystems.InfrastructureSystemsComponent},\n    component_name::AbstractString\n) -> Any\n\n\nCanonical way to turn an InfrastructureSystemsComponent specification/instance into a unique-per-system string.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.compute_periods_between-Tuple{Dates.DateTime, Dates.DateTime, Dates.Period}","page":"API","title":"InfrastructureSystems.compute_periods_between","text":"compute_periods_between(\n    t1::Dates.DateTime,\n    t2::Dates.DateTime,\n    period::Dates.Period\n) -> Int64\n\n\nGiven a series of timestamps that increment by period, return the number of periods between t1 and t2.\n\nt2 must be greater than or equal to t1. There must be an even number of periods between t1 and t2. period can be regular (e.g., Hour) or irregular (e.g., Month).\n\nArguments\n\nt1: The initial timestamp.\nt2: The second timestamp.\nperiod: The period to use for the index.\n\nExamples\n\njulia> compute_periods_between(\n    DateTime(\"2024-01-01T00:00:00\"),\n    DateTime(\"2024-01-01T05:00:00\"),\n    Hour(1),\n)\n5\njulia> compute_period_index(\n    DateTime(\"2024-02-01T00:00:00\"),\n    DateTime(\"2024-04-01T00:00:00\"),\n    Month(1),\n)\n2\njulia> compute_period_index(\n    DateTime(\"2024-01-01T00:00:00\"),\n    DateTime(\"2028-01-01T00:00:00\"),\n    Year(1),\n)\n4\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.compute_sha256-Tuple{AbstractString}","page":"API","title":"InfrastructureSystems.compute_sha256","text":"compute_sha256(filename::AbstractString) -> String\n\n\nReturn the SHA 256 hash of a file.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.compute_time_array_index-Tuple{Dates.DateTime, Dates.DateTime, Dates.Period}","page":"API","title":"InfrastructureSystems.compute_time_array_index","text":"compute_time_array_index(\n    initial_time::Dates.DateTime,\n    other_time::Dates.DateTime,\n    resolution::Dates.Period\n) -> Any\n\n\nGiven a series of timestamps that start with initial_time and increment by resolution, return the index of other time in the array of timestamps.\n\nExamples\n\njulia> compute_time_array_index(\n    DateTime(\"2024-01-01T00:00:00\"),\n    DateTime(\"2024-01-01T05:00:00\"),\n    Hour(1),\n)\n6\njulia> compute_time_array_index(\n    DateTime(\"2024-01-01T00:00:00\"),\n    DateTime(\"2024-04-01T00:00:00\"),\n    Month(1),\n)\n4\njulia> compute_time_array_index(\n    DateTime(\"2024-01-01T00:00:00\"),\n    DateTime(\"2028-01-01T00:00:00\"),\n    Year(1),\n)\n5\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.configure_logging-Tuple{}","page":"API","title":"InfrastructureSystems.configure_logging","text":"configure_logging(\n;\n    console,\n    console_stream,\n    console_level,\n    progress,\n    file,\n    filename,\n    file_level,\n    file_mode,\n    tracker,\n    set_global\n) -> InfrastructureSystems.MultiLogger\n\n\nCreates console and file loggers per caller specification and returns a MultiLogger.\n\nSuppress noisy events by specifying per-event values of maxlog = X and _suppression_period = Y where X is the max number of events that can occur in Y seconds. After the period ends, messages will no longer be suppressed. Note that if you don't specify _suppression_period then maxlog applies for the for the duration of your process (standard Julia logging behavior).\n\nNote: Use of log message suppression and the LogEventTracker are not thread-safe. Please contact the package developers if you need this functionality.\n\nNote: If logging to a file users must call Base.close() on the returned MultiLogger to ensure that all events get flushed.\n\nArguments\n\nconsole::Bool=true: create console logger\nconsole_stream::IOStream=stderr: stream for console logger\nconsole_level::Logging.LogLevel=Logging.Error: level for console messages\nprogress::Bool=true: enable progress logger\nfile::Bool=true: create file logger\nfilename::Union{Nothing, String}=log.txt: log file\nfile_level::Logging.LogLevel=Logging.Info: level for file messages\nfile_mode::String=w+: mode used when opening log file\ntracker::Union{LogEventTracker, Nothing}=LogEventTracker(): optionally track log events\nset_global::Bool=true: set the created logger as the global logger\n\nExample\n\nlogger = configure_logging(filename=\"mylog.txt\")\n@info \"hello world\"\n@info \"hello world\" maxlog = 5 _suppression_period = 10\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.convert_forecast_input_time_arrays-Tuple{AbstractDict{Dates.DateTime, <:TimeSeries.TimeArray}}","page":"API","title":"InfrastructureSystems.convert_forecast_input_time_arrays","text":"convert_forecast_input_time_arrays(\n    data::AbstractDict{Dates.DateTime, <:TimeSeries.TimeArray};\n    resolution\n) -> Tuple{DataStructures.SortedDict{Dates.DateTime, _A, Base.Order.ForwardOrdering} where _A, Any}\n\n\nConvert a Dict of TimeSeries.TimeArray to a SortedDict of Arrays. Before converting, check that the resolution is consistent in all time arrays. Return the SortedDict and the resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.copy_h5_file-Tuple{AbstractString, AbstractString}","page":"API","title":"InfrastructureSystems.copy_h5_file","text":"copy_h5_file(src::AbstractString, dst::AbstractString)\n\n\nCopies an HDF5 file to a new file. This should be used instead of a system call to copy because it won't copy unused space that results from deleting datasets.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.copy_time_series!-Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}, Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}}","page":"API","title":"InfrastructureSystems.copy_time_series!","text":"copy_time_series!(\n    dst::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute},\n    src::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute};\n    name_mapping,\n    scaling_factor_multiplier_mapping\n)\n\n\nEfficiently add all time_series in one component to another by copying the underlying references.\n\nArguments\n\ndst::TimeSeriesOwners: Destination owner\nsrc::TimeSeriesOwners: Source owner\nname_mapping::Dict = nothing: Optionally map src names to different dst names. If provided and src has a time_series with a name not present in name_mapping, that time_series will not copied. If name_mapping is nothing then all time_series will be copied with src's names.\nscaling_factor_multiplier_mapping::Dict = nothing: Optionally map src multipliers to different dst multipliers.  If provided and src has a time_series with a multiplier not present in scaling_factor_multiplier_mapping, that time_series will not copied. If scaling_factor_multiplier_mapping is nothing then all time_series will be copied with src's multipliers.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.deserialize-Union{Tuple{T}, Tuple{Type{T}, Dict}} where T<:InfrastructureSystems.InfrastructureSystemsType","page":"API","title":"InfrastructureSystems.deserialize","text":"deserialize(\n    _::Type{T<:InfrastructureSystems.InfrastructureSystemsType},\n    data::Dict\n) -> InfrastructureSystems.TestComponent\n\n\nDeserialize an object from standard types stored in non-Julia formats, such as JSON, into Julia types.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.double_equals_from_fields-Union{Tuple{T}, Tuple{T, T}} where T","page":"API","title":"InfrastructureSystems.double_equals_from_fields","text":"double_equals_from_fields(a, b) -> Any\n\n\nCompute the conjunction of the == values of all the fields in a and b\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.empty_group_levels!-Tuple{InfrastructureSystems.MultiLogger}","page":"API","title":"InfrastructureSystems.empty_group_levels!","text":"empty_group_levels!(\n    logger::InfrastructureSystems.MultiLogger\n)\n\n\nEmpty the minimum log levels stored for each group.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.execute-Tuple{SQLite.DB, AbstractString, Union{Nothing, Tuple, Vector}, Symbol}","page":"API","title":"InfrastructureSystems.execute","text":"execute(\n    db::SQLite.DB,\n    query::AbstractString,\n    params::Union{Nothing, Tuple, Vector},\n    log_group::Symbol\n) -> SQLite.Query\n\n\nWrapper around SQLite.DBInterface.execute to provide caching of compiled statements as well as log messages.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.execute_count-Tuple{SQLite.DB, AbstractString, Union{Nothing, Tuple, Vector}, Symbol}","page":"API","title":"InfrastructureSystems.execute_count","text":"execute_count(\n    db::SQLite.DB,\n    query::AbstractString,\n    params::Union{Nothing, Tuple, Vector},\n    log_group::Symbol\n) -> Any\n\n\nRun a query to find a count. The query must produce a column called count with one row.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.fast_deepcopy_system-Tuple{InfrastructureSystems.SystemData}","page":"API","title":"InfrastructureSystems.fast_deepcopy_system","text":"fast_deepcopy_system(\n    data::InfrastructureSystems.SystemData;\n    skip_time_series,\n    skip_supplemental_attributes\n) -> InfrastructureSystems.SystemData\n\n\nMake a deepcopy of a SystemData more quickly by skipping the copying of time series and/or supplemental attributes.\n\nArguments\n\ndata::SystemData: the SystemData to copy\nskip_time_series::Bool = true: whether to skip copying time series\nskip_supplemental_attributes::Bool = true: whether to skip copying supplemental attributes\n\nNote that setting both skip_time_series and skip_supplemental_attributes to false results in the same behavior as deepcopy with no performance improvement.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.from-Tuple{InfrastructureSystems.SingleTimeSeries, Any}","page":"API","title":"InfrastructureSystems.from","text":"from(\n    time_series::InfrastructureSystems.SingleTimeSeries,\n    timestamp\n) -> InfrastructureSystems.SingleTimeSeries\n\n\nReturn a time_series truncated starting with timestamp.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.from_file-Tuple{Type{InfrastructureSystems.Hdf5TimeSeriesStorage}, AbstractString}","page":"API","title":"InfrastructureSystems.from_file","text":"from_file(\n    ::Type{InfrastructureSystems.Hdf5TimeSeriesStorage},\n    filename::AbstractString;\n    read_only,\n    directory\n) -> InfrastructureSystems.Hdf5TimeSeriesStorage\n\n\nConstructs Hdf5TimeSeriesStorage from an existing file.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.from_h5_file-Tuple{Type{InfrastructureSystems.TimeSeriesMetadataStore}, AbstractString, Any}","page":"API","title":"InfrastructureSystems.from_h5_file","text":"from_h5_file(\n    _::Type{InfrastructureSystems.TimeSeriesMetadataStore},\n    src::AbstractString,\n    directory\n) -> InfrastructureSystems.TimeSeriesMetadataStore\n\n\nLoad a TimeSeriesMetadataStore from an HDF5 file into an in-memory database.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.from_json-Union{Tuple{T}, Tuple{Type{T}, String}} where T<:InfrastructureSystems.InfrastructureSystemsType","page":"API","title":"InfrastructureSystems.from_json","text":"from_json(\n    _::Type{T<:InfrastructureSystems.InfrastructureSystemsType},\n    filename::String\n) -> Any\n\n\nDeserializes a InfrastructureSystemsType from a JSON filename.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.from_json-Union{Tuple{T}, Tuple{Union{IO, String}, Type{T}}} where T<:InfrastructureSystems.InfrastructureSystemsType","page":"API","title":"InfrastructureSystems.from_json","text":"from_json(\n    io::Union{IO, String},\n    _::Type{T<:InfrastructureSystems.InfrastructureSystemsType}\n) -> InfrastructureSystems.TestComponent\n\n\nDeserializes a InfrastructureSystemsType from String or IO.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.from_records-Tuple{Type{InfrastructureSystems.SupplementalAttributeAssociations}, Any}","page":"API","title":"InfrastructureSystems.from_records","text":"from_records(\n    _::Type{InfrastructureSystems.SupplementalAttributeAssociations},\n    records\n) -> InfrastructureSystems.SupplementalAttributeAssociations\n\n\nAdd records to the database. Expects output from to_records.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.generate_struct_file-Tuple{InfrastructureSystems.StructDefinition}","page":"API","title":"InfrastructureSystems.generate_struct_file","text":"generate_struct_file(\n    definition::InfrastructureSystems.StructDefinition;\n    filename,\n    output_directory\n)\n\n\nGenerate a Julia source code file for one struct from a StructDefinition.\n\nRefer to StructDefinition and StructField for descriptions of the available fields.\n\nArguments\n\ndefinition::StructDefinition: Defines the struct and all fields.\nfilename::AbstractString: Add the struct definition to this JSON file. Defaults to src/descriptors/structs.json\noutput_directory::AbstractString: Generate the files in this directory. Defaults to src/generated\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.generate_struct_files-Tuple{Any}","page":"API","title":"InfrastructureSystems.generate_struct_files","text":"generate_struct_files(\n    definitions;\n    filename,\n    output_directory\n)\n\n\nGenerate Julia source code files for multiple structs from a iterable of StructDefinition instances.\n\nRefer to StructDefinition and StructField for descriptions of the available fields.\n\nArguments\n\ndefinitions: Defines the structs and all fields.\nfilename::AbstractString: Add the struct definition to this JSON file. Defaults to src/descriptors/power_system_structs.json\noutput_directory::AbstractString: Generate the files in this directory. Defaults to src/generated\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_abstract_subtypes-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"API","title":"InfrastructureSystems.get_abstract_subtypes","text":"get_abstract_subtypes(_::Type{T}) -> Vector\n\n\nReturns an array of abstract types that are direct subtypes of T.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_all_concrete_subtypes-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"API","title":"InfrastructureSystems.get_all_concrete_subtypes","text":"get_all_concrete_subtypes(_::Type{T}) -> Any\n\n\nReturns an array of all concrete subtypes of T. Caches the values for faster lookup on repeated calls.\n\nNote that this does not find parameterized types. It will also not find types dynamically added after the first call of given type.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_assigned_subsystems-Tuple{InfrastructureSystems.SystemData, InfrastructureSystems.InfrastructureSystemsComponent}","page":"API","title":"InfrastructureSystems.get_assigned_subsystems","text":"get_assigned_subsystems(\n    data::InfrastructureSystems.SystemData,\n    component::InfrastructureSystems.InfrastructureSystemsComponent\n) -> Vector\n\n\nReturn a Vector of subsystem names that contain the component.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_associated_components-Tuple{InfrastructureSystems.SystemData, InfrastructureSystems.SupplementalAttribute}","page":"API","title":"InfrastructureSystems.get_associated_components","text":"get_associated_components(\n    data::InfrastructureSystems.SystemData,\n    attribute::InfrastructureSystems.SupplementalAttribute;\n    component_type\n) -> Any\n\n\nReturn all components associated with the attribute that match component_type.\n\nArguments\n\ndata::SystemData: the SystemData to search\nattribute::SupplementalAttribute: Only return components associated with this attribute.\ncomponent_type::Union{Nothing, Type{<:InfrastructureSystemsComponent}}: Optional, type of the components to return. Can be concrete or abstract.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_associated_supplemental_attributes-Tuple{InfrastructureSystems.SystemData, Type{<:InfrastructureSystems.InfrastructureSystemsComponent}}","page":"API","title":"InfrastructureSystems.get_associated_supplemental_attributes","text":"get_associated_supplemental_attributes(\n    data::InfrastructureSystems.SystemData,\n    component_type::Type{<:InfrastructureSystems.InfrastructureSystemsComponent};\n    attribute_type\n) -> Any\n\n\nReturn all supplemental attributes associated with the components of the given type, optionally filtered by attribute_type.\n\nArguments\n\ndata::SystemData: the SystemData to search\ncomponent_type::Type{<:InfrastructureSystemsComponent}: Only return attributes\n\nassociated with the components of this type.\n\nattribute_type::Union{Nothing, Type{<:SupplementalAttribute}}`: Optional, type of the attributes to return. Can be concrete or abstract.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_attribute_counts_by_type-Tuple{InfrastructureSystems.SupplementalAttributeAssociations}","page":"API","title":"InfrastructureSystems.get_attribute_counts_by_type","text":"get_attribute_counts_by_type(\n    associations::InfrastructureSystems.SupplementalAttributeAssociations\n) -> Vector\n\n\nReturn a Vector of OrderedDict of stored time series counts by type.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_attribute_summary_table-Tuple{InfrastructureSystems.SupplementalAttributeAssociations}","page":"API","title":"InfrastructureSystems.get_attribute_summary_table","text":"get_attribute_summary_table(\n    associations::InfrastructureSystems.SupplementalAttributeAssociations\n) -> DataFrames.DataFrame\n\n\nReturn a DataFrame with the number of supplemental attributes by type for components.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_available-Tuple{InfrastructureSystems.InfrastructureSystemsComponent}","page":"API","title":"InfrastructureSystems.get_available","text":"get_available(\n    value::InfrastructureSystems.InfrastructureSystemsComponent\n) -> Bool\n\n\nReturn true if the component is available.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_available_component","page":"API","title":"InfrastructureSystems.get_available_component","text":"Like get_component but only on components that are available.\n\n\n\n\n\n","category":"function"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_available_component-Tuple{InfrastructureSystems.ComponentSelector, Any}","page":"API","title":"InfrastructureSystems.get_available_component","text":"get_available_component(\n    selector::InfrastructureSystems.ComponentSelector,\n    sys\n) -> Union{Nothing, InfrastructureSystems.InfrastructureSystemsComponent}\n\n\nLike get_component but only operates on components for which get_available is true.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_available_component-Tuple{Union{Nothing, Function}, InfrastructureSystems.ComponentSelector, Any}","page":"API","title":"InfrastructureSystems.get_available_component","text":"get_available_component(\n    scope_limiter::Union{Nothing, Function},\n    selector::InfrastructureSystems.ComponentSelector,\n    sys\n) -> Union{Nothing, InfrastructureSystems.InfrastructureSystemsComponent}\n\n\nLike get_component but only operates on components for which get_available is true.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_available_components","page":"API","title":"InfrastructureSystems.get_available_components","text":"Like get_components but only on components that are available.\n\n\n\n\n\n","category":"function"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_available_components-Tuple{InfrastructureSystems.ComponentSelector, Any}","page":"API","title":"InfrastructureSystems.get_available_components","text":"get_available_components(\n    selector::InfrastructureSystems.ComponentSelector,\n    sys\n) -> Any\n\n\nLike get_components but only operates on components for which get_available is true.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_available_components-Tuple{Union{Nothing, Function}, InfrastructureSystems.ComponentSelector, Any}","page":"API","title":"InfrastructureSystems.get_available_components","text":"get_available_components(\n    scope_limiter::Union{Nothing, Function},\n    selector::InfrastructureSystems.ComponentSelector,\n    sys\n) -> Any\n\n\nLike get_components but only operates on components for which get_available is true.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_available_groups-Tuple{InfrastructureSystems.ComponentSelector, Any}","page":"API","title":"InfrastructureSystems.get_available_groups","text":"get_available_groups(\n    selector::InfrastructureSystems.ComponentSelector,\n    sys\n) -> Any\n\n\nLike get_groups but only operates on components for which get_available is true.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_available_groups-Tuple{Union{Nothing, Function}, InfrastructureSystems.ComponentSelector, Any}","page":"API","title":"InfrastructureSystems.get_available_groups","text":"get_available_groups(\n    scope_limiter::Union{Nothing, Function},\n    selector::InfrastructureSystems.ComponentSelector,\n    sys\n) -> Any\n\n\nLike get_groups but only operates on components for which get_available is true.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_average_rates-Tuple{PiecewiseAverageCurve}","page":"API","title":"InfrastructureSystems.get_average_rates","text":"get_average_rates(\n    vc::PiecewiseAverageCurve\n) -> Vector{Float64}\n\n\nGet the average rates that define the PiecewiseAverageCurve\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_base_component_type-Tuple{InfrastructureSystems.ComponentContainer}","page":"API","title":"InfrastructureSystems.get_base_component_type","text":"get_base_component_type(\n    _::InfrastructureSystems.ComponentContainer\n) -> Type{InfrastructureSystems.InfrastructureSystemsComponent}\n\n\nReturn the base type stored in the container.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_component","page":"API","title":"InfrastructureSystems.get_component","text":"Get the single component that matches the given specification from the ComponentContainer, or nothing if there is no match.\n\n\n\n\n\n","category":"function"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_component-Tuple{InfrastructureSystems.SingularComponentSelector, Any}","page":"API","title":"InfrastructureSystems.get_component","text":"get_component(\n    selector::InfrastructureSystems.SingularComponentSelector,\n    sys\n) -> Union{Nothing, InfrastructureSystems.InfrastructureSystemsComponent}\n\n\nGet the single component that matches the SingularComponentSelector, or nothing if there is no match.\n\nArguments\n\nselector::SingularComponentSelector: the SingularComponentSelector that specifies which component to get\nsys: the ComponentContainer-like source of components to draw from\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_component-Tuple{Union{Nothing, Function}, InfrastructureSystems.NameComponentSelector, Any}","page":"API","title":"InfrastructureSystems.get_component","text":"get_component(\n    scope_limiter::Union{Nothing, Function},\n    selector::InfrastructureSystems.NameComponentSelector,\n    sys\n) -> Union{Nothing, InfrastructureSystems.InfrastructureSystemsComponent}\n\n\nGet the component to which the NameComponentSelector points, or nothing if such a component does not exist in sys.\n\nArguments\n\nscope_limiter::Union{Function, Nothing}: see ComponentSelector\nselector::NameComponentSelector: the NameComponentSelector whose component to get\nsys: the ComponentContainer-like source of components to draw from\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_component-Union{Tuple{T}, Tuple{Type{T}, InfrastructureSystems.Components, AbstractString}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.get_component","text":"get_component(\n    _::Type{T<:InfrastructureSystems.InfrastructureSystemsComponent},\n    components::InfrastructureSystems.Components,\n    name::AbstractString\n) -> Union{Nothing, InfrastructureSystems.InfrastructureSystemsComponent}\n\n\nGet the component of type T with name. Returns nothing if no component matches. If T is an abstract type then the names of components across all subtypes of T must be unique.\n\nSee get_components_by_name for abstract types with non-unique names across subtypes.\n\nThrows ArgumentError if T is not a concrete type and there is more than one component with requested name\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_component_supplemental_attribute_pairs-Union{Tuple{U}, Tuple{T}, Tuple{Type{T}, Type{U}, InfrastructureSystems.SystemData}} where {T<:InfrastructureSystems.InfrastructureSystemsComponent, U<:InfrastructureSystems.SupplementalAttribute}","page":"API","title":"InfrastructureSystems.get_component_supplemental_attribute_pairs","text":"get_component_supplemental_attribute_pairs(\n    ::Type{T<:InfrastructureSystems.InfrastructureSystemsComponent},\n    ::Type{U<:InfrastructureSystems.SupplementalAttribute},\n    data::InfrastructureSystems.SystemData;\n    components,\n    attributes\n) -> Array{NamedTuple{(:component, :supplemental_attribute), var\"#s177\"}, 1} where var\"#s177\"<:Tuple{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}\n\n\nReturn a vector of NamedTuples with pairs of components and supplemental attributes that are associated with each other. Limit by components and attributes if provided.\n\nThe return type is NamedTuple{(:component, :supplemental_attribute), Tuple{T, U}}[] where T is the component type and U is the supplemental attribute type.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_components","page":"API","title":"InfrastructureSystems.get_components","text":"Get an iterator of components of a certain specification from the ComponentContainer.\n\n\n\n\n\n","category":"function"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_components-Tuple{InfrastructureSystems.ComponentSelector, Any}","page":"API","title":"InfrastructureSystems.get_components","text":"get_components(\n    selector::InfrastructureSystems.ComponentSelector,\n    sys\n) -> Any\n\n\nGiven a ComponentContainer-like source of components, get those components that make up the ComponentSelector.\n\nArguments\n\nselector::ComponentSelector: the ComponentSelector that specifies which components to get\nsys: the ComponentContainer-like source of components to draw from\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_components-Tuple{Union{Nothing, Function}, InfrastructureSystems.FilterComponentSelector, Any}","page":"API","title":"InfrastructureSystems.get_components","text":"get_components(\n    scope_limiter::Union{Nothing, Function},\n    selector::InfrastructureSystems.FilterComponentSelector,\n    sys\n) -> InfrastructureSystems.FlattenIteratorWrapper{T, I} where {T<:InfrastructureSystems.InfrastructureSystemsComponent, I<:(Vector)}\n\n\nGet the components to which the FilterComponentSelector points.\n\nArguments\n\nscope_limiter::Union{Function, Nothing}: see ComponentSelector\nselector::FilterComponentSelector: the FilterComponentSelector whose components to get\nsys: the ComponentContainer-like source of components to draw from\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_components-Tuple{Union{Nothing, Function}, InfrastructureSystems.ListComponentSelector, Any}","page":"API","title":"InfrastructureSystems.get_components","text":"get_components(\n    scope_limiter::Union{Nothing, Function},\n    selector::InfrastructureSystems.ListComponentSelector,\n    sys\n) -> InfrastructureSystems.FlattenIteratorWrapper\n\n\nGet the components to which the ListComponentSelector points.\n\nArguments\n\nscope_limiter::Union{Function, Nothing}: see ComponentSelector\nselector::ListComponentSelector: the ListComponentSelector whose components to get\nsys: the ComponentContainer-like source of components to draw from\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_components-Tuple{Union{Nothing, Function}, InfrastructureSystems.NameComponentSelector, Any}","page":"API","title":"InfrastructureSystems.get_components","text":"get_components(\n    scope_limiter::Union{Nothing, Function},\n    selector::InfrastructureSystems.NameComponentSelector,\n    sys\n) -> InfrastructureSystems.FlattenIteratorWrapper{T, Vector{Base.ValueIterator}} where T<:InfrastructureSystems.InfrastructureSystemsComponent\n\n\nGet the components to which the NameComponentSelector points.\n\nArguments\n\nscope_limiter::Union{Function, Nothing}: see ComponentSelector\nselector::NameComponentSelector: the NameComponentSelector whose components to get\nsys: the ComponentContainer-like source of components to draw from\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_components-Tuple{Union{Nothing, Function}, InfrastructureSystems.RegroupedComponentSelector, Any}","page":"API","title":"InfrastructureSystems.get_components","text":"get_components(\n    scope_limiter::Union{Nothing, Function},\n    selector::InfrastructureSystems.RegroupedComponentSelector,\n    sys\n) -> Any\n\n\nGet the components to which the RegroupedComponentSelector points.\n\nArguments\n\nscope_limiter::Union{Function, Nothing}: see ComponentSelector\nselector::RegroupedComponentSelector: the RegroupedComponentSelector whose components to get\nsys: the ComponentContainer-like source of components to draw from\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_components-Tuple{Union{Nothing, Function}, InfrastructureSystems.TypeComponentSelector, Any}","page":"API","title":"InfrastructureSystems.get_components","text":"get_components(\n    scope_limiter::Union{Nothing, Function},\n    selector::InfrastructureSystems.TypeComponentSelector,\n    sys\n) -> InfrastructureSystems.FlattenIteratorWrapper{T, I} where {T<:InfrastructureSystems.InfrastructureSystemsComponent, I<:(Vector)}\n\n\nGet the components to which the TypeComponentSelector points.\n\nArguments\n\nscope_limiter::Union{Function, Nothing}: see ComponentSelector\nselector::TypeComponentSelector: the TypeComponentSelector whose components to get\nsys: the ComponentContainer-like source of components to draw from\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_components-Union{Tuple{T}, Tuple{Type{T}, InfrastructureSystems.Components}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.get_components","text":"get_components(\n    ::Type{T<:InfrastructureSystems.InfrastructureSystemsComponent},\n    components::InfrastructureSystems.Components;\n    component_uuids\n) -> InfrastructureSystems.FlattenIteratorWrapper{T, I} where {T<:InfrastructureSystems.InfrastructureSystemsComponent, I<:(Vector)}\n\n\nReturns an iterator of components. T can be concrete or abstract. Call collect on the result if an array is desired.\n\nArguments\n\nT: component type\ncomponents::Components: Components of the system\nfilter_func::Union{Nothing, Function} = nothing: Optional function that accepts a component of type T and returns a Bool. Apply this function to each component and only return components where the result is true.\n\nSee also: iterate_components\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_components_by_name-Union{Tuple{T}, Tuple{Type{T}, InfrastructureSystems.Components, AbstractString}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.get_components_by_name","text":"get_components_by_name(\n    _::Type{T<:InfrastructureSystems.InfrastructureSystemsComponent},\n    components::InfrastructureSystems.Components,\n    name::AbstractString\n) -> Vector{T} where T<:InfrastructureSystems.InfrastructureSystemsComponent\n\n\nGet the components of abstract type T with name. Note that InfrastructureSystems enforces unique names on each concrete type but not across concrete types.\n\nSee get_component if the concrete type is known.\n\nThrows ArgumentError if T is not an abstract type.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_concrete_subtypes-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"API","title":"InfrastructureSystems.get_concrete_subtypes","text":"get_concrete_subtypes(_::Type{T}) -> Vector\n\n\nReturns an array of concrete types that are direct subtypes of T.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_constant_term-Tuple{LinearCurve}","page":"API","title":"InfrastructureSystems.get_constant_term","text":"get_constant_term(vc::LinearCurve) -> Float64\n\n\nGet the constant term (i.e., intercept) of the LinearCurve\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_constant_term-Tuple{QuadraticCurve}","page":"API","title":"InfrastructureSystems.get_constant_term","text":"get_constant_term(vc::QuadraticCurve) -> Float64\n\n\nGet the constant term of the QuadraticCurve\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_count-Tuple{InfrastructureSystems.DeterministicMetadata}","page":"API","title":"InfrastructureSystems.get_count","text":"get_count(\n    value::InfrastructureSystems.DeterministicMetadata\n) -> Int64\n\n\nGet DeterministicMetadata count.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_count-Tuple{InfrastructureSystems.DeterministicSingleTimeSeries}","page":"API","title":"InfrastructureSystems.get_count","text":"get_count(\n    value::InfrastructureSystems.DeterministicSingleTimeSeries\n) -> Int64\n\n\nGet DeterministicSingleTimeSeries count.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_count-Tuple{InfrastructureSystems.ProbabilisticMetadata}","page":"API","title":"InfrastructureSystems.get_count","text":"get_count(\n    value::InfrastructureSystems.ProbabilisticMetadata\n) -> Int64\n\n\nGet ProbabilisticMetadata count.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_count-Tuple{InfrastructureSystems.ScenariosMetadata}","page":"API","title":"InfrastructureSystems.get_count","text":"get_count(\n    value::InfrastructureSystems.ScenariosMetadata\n) -> Int64\n\n\nGet ScenariosMetadata count.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_data-Tuple{InfrastructureSystems.Deterministic}","page":"API","title":"InfrastructureSystems.get_data","text":"get_data(\n    value::InfrastructureSystems.Deterministic\n) -> DataStructures.SortedDict\n\n\nGet Deterministic data.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_data-Tuple{InfrastructureSystems.Probabilistic}","page":"API","title":"InfrastructureSystems.get_data","text":"get_data(\n    value::InfrastructureSystems.Probabilistic\n) -> DataStructures.SortedDict\n\n\nGet Probabilistic data.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_data-Tuple{InfrastructureSystems.Scenarios}","page":"API","title":"InfrastructureSystems.get_data","text":"get_data(\n    value::InfrastructureSystems.Scenarios\n) -> DataStructures.SortedDict\n\n\nGet Scenarios data.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_data-Tuple{InfrastructureSystems.SingleTimeSeries}","page":"API","title":"InfrastructureSystems.get_data","text":"get_data(\n    value::InfrastructureSystems.SingleTimeSeries\n) -> TimeSeries.TimeArray\n\n\nGet SingleTimeSeries data.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_data_type-Tuple{InfrastructureSystems.TimeSeriesData}","page":"API","title":"InfrastructureSystems.get_data_type","text":"get_data_type(\n    ts::InfrastructureSystems.TimeSeriesData\n) -> Any\n\n\nReturn a String for the data type of the forecast data, this implementation avoids the use of eval on arbitrary code stored in HDF dataset.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_domain-Tuple{InfrastructureSystems.PiecewiseLinearData}","page":"API","title":"InfrastructureSystems.get_domain","text":"get_domain(\n    fd::InfrastructureSystems.PiecewiseLinearData\n) -> Tuple{Float64, Float64}\n\n\nGet the domain of the function represented by the PiecewiseLinearData.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_domain-Tuple{InfrastructureSystems.PiecewiseStepData}","page":"API","title":"InfrastructureSystems.get_domain","text":"get_domain(\n    fd::InfrastructureSystems.PiecewiseStepData\n) -> Tuple{Float64, Float64}\n\n\nGet the domain of the function represented by the PiecewiseStepData.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_domain-Tuple{Union{InfrastructureSystems.LinearFunctionData, InfrastructureSystems.QuadraticFunctionData}}","page":"API","title":"InfrastructureSystems.get_domain","text":"get_domain(\n    _::Union{InfrastructureSystems.LinearFunctionData, InfrastructureSystems.QuadraticFunctionData}\n) -> Tuple{Float64, Float64}\n\n\nGet the domain of the function represented by the LinearFunctionData or QuadraticFunctionData (always (-Inf, Inf) for these types).\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_ext-Tuple{InfrastructureSystems.InfrastructureSystemsInternal}","page":"API","title":"InfrastructureSystems.get_ext","text":"get_ext(\n    obj::InfrastructureSystems.InfrastructureSystemsInternal\n) -> Union{Nothing, Dict{String, Any}}\n\n\nReturn a user-modifiable dictionary to store extra information.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_features-Tuple{InfrastructureSystems.DeterministicMetadata}","page":"API","title":"InfrastructureSystems.get_features","text":"get_features(\n    value::InfrastructureSystems.DeterministicMetadata\n) -> Dict{String, Union{Bool, Int64, String}}\n\n\nGet DeterministicMetadata features.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_features-Tuple{InfrastructureSystems.ProbabilisticMetadata}","page":"API","title":"InfrastructureSystems.get_features","text":"get_features(\n    value::InfrastructureSystems.ProbabilisticMetadata\n) -> Dict{String, Union{Bool, Int64, String}}\n\n\nGet ProbabilisticMetadata features.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_features-Tuple{InfrastructureSystems.ScenariosMetadata}","page":"API","title":"InfrastructureSystems.get_features","text":"get_features(\n    value::InfrastructureSystems.ScenariosMetadata\n) -> Dict{String, Union{Bool, Int64, String}}\n\n\nGet ScenariosMetadata features.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_features-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata}","page":"API","title":"InfrastructureSystems.get_features","text":"get_features(\n    value::InfrastructureSystems.SingleTimeSeriesMetadata\n) -> Dict{String, Union{Bool, Int64, String}}\n\n\nGet SingleTimeSeriesMetadata features.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_forecast_summary_table-Tuple{InfrastructureSystems.TimeSeriesMetadataStore}","page":"API","title":"InfrastructureSystems.get_forecast_summary_table","text":"get_forecast_summary_table(\n    store::InfrastructureSystems.TimeSeriesMetadataStore\n) -> DataFrames.DataFrame\n\n\nReturn a DataFrame with the number of forecasts for components and supplemental attributes.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_fuel_cost-Tuple{InfrastructureSystems.FuelCurve}","page":"API","title":"InfrastructureSystems.get_fuel_cost","text":"get_fuel_cost(\n    cost::InfrastructureSystems.FuelCurve\n) -> Union{Float64, InfrastructureSystems.TimeSeriesKey}\n\n\nGet the fuel cost or the name of the fuel cost time series\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_function_data-Tuple{InfrastructureSystems.ProductionVariableCostCurve}","page":"API","title":"InfrastructureSystems.get_function_data","text":"get_function_data(\n    cost::InfrastructureSystems.ProductionVariableCostCurve\n) -> Any\n\n\nGet the FunctionData representation of this ProductionVariableCostCurve's ValueCurve\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_function_data-Tuple{InfrastructureSystems.ValueCurve}","page":"API","title":"InfrastructureSystems.get_function_data","text":"get_function_data(\n    curve::InfrastructureSystems.ValueCurve\n) -> Any\n\n\nGet the underlying FunctionData representation of this ValueCurve\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_geo_json-Tuple{InfrastructureSystems.GeographicInfo}","page":"API","title":"InfrastructureSystems.get_geo_json","text":"get_geo_json(\n    geo::InfrastructureSystems.GeographicInfo\n) -> Dict{String, Any}\n\n\nget_geo_json(geo::GeographicInfo)\n\nGet the GeoJSON dictionary from a GeographicInfo attribute.\n\nArguments\n\ngeo::GeographicInfo: the GeographicInfo attribute\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_group_level-Tuple{InfrastructureSystems.MultiLogger, Symbol}","page":"API","title":"InfrastructureSystems.get_group_level","text":"get_group_level(\n    logger::InfrastructureSystems.MultiLogger,\n    group::Symbol\n) -> Union{Nothing, Base.CoreLogging.LogLevel}\n\n\nReturn the minimum logging level for a group or nothing if group is not stored.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_group_levels-Tuple{InfrastructureSystems.MultiLogger}","page":"API","title":"InfrastructureSystems.get_group_levels","text":"get_group_levels(\n    logger::InfrastructureSystems.MultiLogger\n) -> Dict{Symbol, Base.CoreLogging.LogLevel}\n\n\nReturn the minimum logging levels for groups that have been stored.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_groups-Tuple{InfrastructureSystems.ComponentSelector, Any}","page":"API","title":"InfrastructureSystems.get_groups","text":"get_groups(\n    selector::InfrastructureSystems.ComponentSelector,\n    sys\n) -> Any\n\n\nGiven a ComponentContainer-like source of components, get the groups that make up the ComponentSelector.\n\nArguments\n\nselector::ComponentSelector: the ComponentSelector whose groups should be retrieved\nsys: the ComponentContainer-like source of components to draw from\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_groups-Tuple{Union{Nothing, Function}, InfrastructureSystems.DynamicallyGroupedComponentSelector, Any}","page":"API","title":"InfrastructureSystems.get_groups","text":"get_groups(\n    scope_limiter::Union{Nothing, Function},\n    selector::InfrastructureSystems.DynamicallyGroupedComponentSelector,\n    sys\n) -> Any\n\n\nGiven a ComponentContainer-like source of components, use the groupby property (see make_selector) to get the groups that make up the DynamicallyGroupedComponentSelector.\n\nArguments\n\nscope_limiter::Union{Function, Nothing}: see ComponentSelector\nselector::DynamicallyGroupedComponentSelector: the DynamicallyGroupedComponentSelector whose groups should be retrieved\nsys: the ComponentContainer-like source of components to draw from\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_groups-Tuple{Union{Nothing, Function}, InfrastructureSystems.SingularComponentSelector, Any}","page":"API","title":"InfrastructureSystems.get_groups","text":"get_groups(\n    scope_limiter::Union{Nothing, Function},\n    selector::InfrastructureSystems.SingularComponentSelector,\n    sys\n) -> Vector{T} where T<:InfrastructureSystems.SingularComponentSelector\n\n\nGet the single group that corresponds to the SingularComponentSelector, i.e., itself.\n\nArguments\n\nscope_limiter::Union{Function, Nothing}: see ComponentSelector (unused in this case)\nselector::SingularComponentSelector: the SingularComponentSelector whose group should be retrieved\nsys: the ComponentContainer-like source of components to draw from (unused in this case)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_horizon-Tuple{InfrastructureSystems.DeterministicMetadata}","page":"API","title":"InfrastructureSystems.get_horizon","text":"get_horizon(\n    value::InfrastructureSystems.DeterministicMetadata\n) -> Dates.Period\n\n\nGet DeterministicMetadata horizon.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_horizon-Tuple{InfrastructureSystems.DeterministicSingleTimeSeries}","page":"API","title":"InfrastructureSystems.get_horizon","text":"get_horizon(\n    value::InfrastructureSystems.DeterministicSingleTimeSeries\n) -> Dates.Period\n\n\nGet DeterministicSingleTimeSeries horizon.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_horizon-Tuple{InfrastructureSystems.ProbabilisticMetadata}","page":"API","title":"InfrastructureSystems.get_horizon","text":"get_horizon(\n    value::InfrastructureSystems.ProbabilisticMetadata\n) -> Dates.Period\n\n\nGet ProbabilisticMetadata horizon.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_horizon-Tuple{InfrastructureSystems.ScenariosMetadata}","page":"API","title":"InfrastructureSystems.get_horizon","text":"get_horizon(\n    value::InfrastructureSystems.ScenariosMetadata\n) -> Dates.Period\n\n\nGet ScenariosMetadata horizon.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_initial_input-Tuple{InfrastructureSystems.ProductionVariableCostCurve}","page":"API","title":"InfrastructureSystems.get_initial_input","text":"get_initial_input(\n    cost::InfrastructureSystems.ProductionVariableCostCurve\n) -> Union{Nothing, Float64}\n\n\nGet the initial_input field of this ProductionVariableCostCurve's ValueCurve (not defined for input-output data)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_initial_input-Tuple{Union{InfrastructureSystems.AverageRateCurve, InfrastructureSystems.IncrementalCurve}}","page":"API","title":"InfrastructureSystems.get_initial_input","text":"get_initial_input(\n    curve::Union{InfrastructureSystems.AverageRateCurve, InfrastructureSystems.IncrementalCurve}\n) -> Union{Nothing, Float64}\n\n\nGet the initial_input field of this ValueCurve (not defined for InputOutputCurve)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_initial_times-Tuple{InfrastructureSystems.Forecast}","page":"API","title":"InfrastructureSystems.get_initial_times","text":"get_initial_times(\n    f::InfrastructureSystems.Forecast\n) -> DataStructures.IterableObject{C, DataStructures.EntireContainer, DataStructures.KeysIter, DataStructures.NoTokens, DataStructures.ForwardIter} where C<:(DataStructures.SortedDict{K, D, Ord} where {Ord<:Base.Order.Ordering, D, K})\n\n\nReturn the initial times in the forecast.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_initial_timestamp-Tuple{InfrastructureSystems.DeterministicMetadata}","page":"API","title":"InfrastructureSystems.get_initial_timestamp","text":"get_initial_timestamp(\n    value::InfrastructureSystems.DeterministicMetadata\n) -> Dates.DateTime\n\n\nGet DeterministicMetadata initial_timestamp.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_initial_timestamp-Tuple{InfrastructureSystems.DeterministicSingleTimeSeries}","page":"API","title":"InfrastructureSystems.get_initial_timestamp","text":"get_initial_timestamp(\n    value::InfrastructureSystems.DeterministicSingleTimeSeries\n) -> Dates.DateTime\n\n\nGet DeterministicSingleTimeSeries initial_timestamp.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_initial_timestamp-Tuple{InfrastructureSystems.ProbabilisticMetadata}","page":"API","title":"InfrastructureSystems.get_initial_timestamp","text":"get_initial_timestamp(\n    value::InfrastructureSystems.ProbabilisticMetadata\n) -> Dates.DateTime\n\n\nGet ProbabilisticMetadata initial_timestamp.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_initial_timestamp-Tuple{InfrastructureSystems.ScenariosMetadata}","page":"API","title":"InfrastructureSystems.get_initial_timestamp","text":"get_initial_timestamp(\n    value::InfrastructureSystems.ScenariosMetadata\n) -> Dates.DateTime\n\n\nGet ScenariosMetadata initial_timestamp.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_initial_timestamp-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata}","page":"API","title":"InfrastructureSystems.get_initial_timestamp","text":"get_initial_timestamp(\n    value::InfrastructureSystems.SingleTimeSeriesMetadata\n) -> Dates.DateTime\n\n\nGet SingleTimeSeriesMetadata initial_timestamp.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_input_at_zero-Tuple{InfrastructureSystems.ValueCurve}","page":"API","title":"InfrastructureSystems.get_input_at_zero","text":"get_input_at_zero(\n    curve::InfrastructureSystems.ValueCurve\n) -> Any\n\n\nGet the input_at_zero field of this ValueCurve\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_internal-Tuple{InfrastructureSystems.DeterministicMetadata}","page":"API","title":"InfrastructureSystems.get_internal","text":"get_internal(\n    value::InfrastructureSystems.DeterministicMetadata\n) -> InfrastructureSystems.InfrastructureSystemsInternal\n\n\nGet DeterministicMetadata internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_internal-Tuple{InfrastructureSystems.Deterministic}","page":"API","title":"InfrastructureSystems.get_internal","text":"get_internal(\n    value::InfrastructureSystems.Deterministic\n) -> InfrastructureSystems.InfrastructureSystemsInternal\n\n\nGet Deterministic internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_internal-Tuple{InfrastructureSystems.GeographicInfo}","page":"API","title":"InfrastructureSystems.get_internal","text":"get_internal(\n    geo::InfrastructureSystems.GeographicInfo\n) -> InfrastructureSystems.InfrastructureSystemsInternal\n\n\nget_internal(geo::GeographicInfo)\n\nGet the internal infrastructure systems data from a GeographicInfo attribute.\n\nArguments\n\ngeo::GeographicInfo: the GeographicInfo attribute\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_internal-Tuple{InfrastructureSystems.ProbabilisticMetadata}","page":"API","title":"InfrastructureSystems.get_internal","text":"get_internal(\n    value::InfrastructureSystems.ProbabilisticMetadata\n) -> InfrastructureSystems.InfrastructureSystemsInternal\n\n\nGet ProbabilisticMetadata internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_internal-Tuple{InfrastructureSystems.Probabilistic}","page":"API","title":"InfrastructureSystems.get_internal","text":"get_internal(\n    value::InfrastructureSystems.Probabilistic\n) -> InfrastructureSystems.InfrastructureSystemsInternal\n\n\nGet Probabilistic internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_internal-Tuple{InfrastructureSystems.ScenariosMetadata}","page":"API","title":"InfrastructureSystems.get_internal","text":"get_internal(\n    value::InfrastructureSystems.ScenariosMetadata\n) -> InfrastructureSystems.InfrastructureSystemsInternal\n\n\nGet ScenariosMetadata internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_internal-Tuple{InfrastructureSystems.Scenarios}","page":"API","title":"InfrastructureSystems.get_internal","text":"get_internal(\n    value::InfrastructureSystems.Scenarios\n) -> InfrastructureSystems.InfrastructureSystemsInternal\n\n\nGet Scenarios internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_internal-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata}","page":"API","title":"InfrastructureSystems.get_internal","text":"get_internal(\n    value::InfrastructureSystems.SingleTimeSeriesMetadata\n) -> InfrastructureSystems.InfrastructureSystemsInternal\n\n\nGet SingleTimeSeriesMetadata internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_internal-Tuple{InfrastructureSystems.SingleTimeSeries}","page":"API","title":"InfrastructureSystems.get_internal","text":"get_internal(\n    value::InfrastructureSystems.SingleTimeSeries\n) -> InfrastructureSystems.InfrastructureSystemsInternal\n\n\nGet SingleTimeSeries internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_interval-Tuple{InfrastructureSystems.DeterministicMetadata}","page":"API","title":"InfrastructureSystems.get_interval","text":"get_interval(\n    value::InfrastructureSystems.DeterministicMetadata\n) -> Dates.Period\n\n\nGet DeterministicMetadata interval.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_interval-Tuple{InfrastructureSystems.DeterministicSingleTimeSeries}","page":"API","title":"InfrastructureSystems.get_interval","text":"get_interval(\n    value::InfrastructureSystems.DeterministicSingleTimeSeries\n) -> Dates.Period\n\n\nGet DeterministicSingleTimeSeries interval.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_interval-Tuple{InfrastructureSystems.Deterministic}","page":"API","title":"InfrastructureSystems.get_interval","text":"get_interval(\n    value::InfrastructureSystems.Deterministic\n) -> Dates.Period\n\n\nGet Deterministic interval.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_interval-Tuple{InfrastructureSystems.ProbabilisticMetadata}","page":"API","title":"InfrastructureSystems.get_interval","text":"get_interval(\n    value::InfrastructureSystems.ProbabilisticMetadata\n) -> Dates.Period\n\n\nGet ProbabilisticMetadata interval.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_interval-Tuple{InfrastructureSystems.Probabilistic}","page":"API","title":"InfrastructureSystems.get_interval","text":"get_interval(\n    value::InfrastructureSystems.Probabilistic\n) -> Dates.Period\n\n\nGet Probabilistic interval.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_interval-Tuple{InfrastructureSystems.ScenariosMetadata}","page":"API","title":"InfrastructureSystems.get_interval","text":"get_interval(\n    value::InfrastructureSystems.ScenariosMetadata\n) -> Dates.Period\n\n\nGet ScenariosMetadata interval.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_interval-Tuple{InfrastructureSystems.Scenarios}","page":"API","title":"InfrastructureSystems.get_interval","text":"get_interval(\n    value::InfrastructureSystems.Scenarios\n) -> Dates.Period\n\n\nGet Scenarios interval.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_interval_from_initial_times-Tuple{Vector{Dates.DateTime}}","page":"API","title":"InfrastructureSystems.get_interval_from_initial_times","text":"get_interval_from_initial_times(\n    initial_times::Vector{Dates.DateTime}\n) -> Union{Dates.Millisecond, Dates.Second}\n\n\nReturn the interval by subtracting the first two initial times.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_length-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata}","page":"API","title":"InfrastructureSystems.get_length","text":"get_length(\n    value::InfrastructureSystems.SingleTimeSeriesMetadata\n) -> Int64\n\n\nGet SingleTimeSeriesMetadata length.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_log_events-Tuple{InfrastructureSystems.LogEventTracker, Base.CoreLogging.LogLevel}","page":"API","title":"InfrastructureSystems.get_log_events","text":"get_log_events(\n    tracker::InfrastructureSystems.LogEventTracker,\n    level::Base.CoreLogging.LogLevel\n) -> Union{Base.ValueIterator{Dict{Symbol, InfrastructureSystems.LogEvent}}, Vector{Any}}\n\n\nReturns an iterable of log events for a level.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_metadata-Tuple{InfrastructureSystems.TimeSeriesMetadataStore, Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}, Type{<:InfrastructureSystems.TimeSeriesData}, String}","page":"API","title":"InfrastructureSystems.get_metadata","text":"get_metadata(\n    store::InfrastructureSystems.TimeSeriesMetadataStore,\n    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute},\n    time_series_type::Type{<:InfrastructureSystems.TimeSeriesData},\n    name::String;\n    resolution,\n    features...\n) -> Any\n\n\nReturn the metadata matching the inputs. Throw an exception if there is more than one matching input.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_name-Tuple{InfrastructureSystems.ComponentSelector}","page":"API","title":"InfrastructureSystems.get_name","text":"get_name(\n    selector::InfrastructureSystems.ComponentSelector\n) -> Any\n\n\nGet the name of the ComponentSelector. This is either a user-specified name passed in at creation or a name automatically generated from the selector's specification.\n\nExamples\n\nsel = make_selector(RenewableDispatch)\nget_name(sel)  # \"RenewableDispatch\"\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_name-Tuple{InfrastructureSystems.DeterministicMetadata}","page":"API","title":"InfrastructureSystems.get_name","text":"get_name(\n    value::InfrastructureSystems.DeterministicMetadata\n) -> String\n\n\nGet DeterministicMetadata name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_name-Tuple{InfrastructureSystems.Deterministic}","page":"API","title":"InfrastructureSystems.get_name","text":"get_name(\n    value::InfrastructureSystems.Deterministic\n) -> String\n\n\nGet Deterministic name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_name-Tuple{InfrastructureSystems.InfrastructureSystemsComponent}","page":"API","title":"InfrastructureSystems.get_name","text":"get_name(\n    value::InfrastructureSystems.InfrastructureSystemsComponent\n) -> Any\n\n\nReturn the name of the component.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_name-Tuple{InfrastructureSystems.ProbabilisticMetadata}","page":"API","title":"InfrastructureSystems.get_name","text":"get_name(\n    value::InfrastructureSystems.ProbabilisticMetadata\n) -> String\n\n\nGet ProbabilisticMetadata name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_name-Tuple{InfrastructureSystems.Probabilistic}","page":"API","title":"InfrastructureSystems.get_name","text":"get_name(\n    value::InfrastructureSystems.Probabilistic\n) -> String\n\n\nGet Probabilistic name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_name-Tuple{InfrastructureSystems.ScenariosMetadata}","page":"API","title":"InfrastructureSystems.get_name","text":"get_name(\n    value::InfrastructureSystems.ScenariosMetadata\n) -> String\n\n\nGet ScenariosMetadata name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_name-Tuple{InfrastructureSystems.Scenarios}","page":"API","title":"InfrastructureSystems.get_name","text":"get_name(value::InfrastructureSystems.Scenarios) -> String\n\n\nGet Scenarios name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_name-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata}","page":"API","title":"InfrastructureSystems.get_name","text":"get_name(\n    value::InfrastructureSystems.SingleTimeSeriesMetadata\n) -> String\n\n\nGet SingleTimeSeriesMetadata name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_name-Tuple{InfrastructureSystems.SingleTimeSeries}","page":"API","title":"InfrastructureSystems.get_name","text":"get_name(\n    value::InfrastructureSystems.SingleTimeSeries\n) -> String\n\n\nGet SingleTimeSeries name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_next_time-Tuple{InfrastructureSystems.TimeSeriesCache}","page":"API","title":"InfrastructureSystems.get_next_time","text":"get_next_time(\n    cache::InfrastructureSystems.TimeSeriesCache\n) -> Any\n\n\nReturn the timestamp for the next read with get_next_time_series_array!.\n\nReturn nothing if all data has been read.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_next_time_series_array!-Tuple{InfrastructureSystems.TimeSeriesCache}","page":"API","title":"InfrastructureSystems.get_next_time_series_array!","text":"get_next_time_series_array!(\n    cache::InfrastructureSystems.TimeSeriesCache\n) -> Any\n\n\nReturn the next TimeSeries.TimeArray.\n\nReturns nothing when all data has been read. Call reset! to restart. Call get_next_time to check the start time.\n\nReads from storage if the data is not already in cache.\n\nArguments\n\ncache::StaticTimeSeriesCache: cached instance\n\nExamples\n\ncache = ForecastCache(Deterministic, component, \"max_active_power\")\nwindow1 = get_next_time_series_array!(cache)\nwindow2 = get_next_time_series_array!(cache)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_num_attributes-Tuple{InfrastructureSystems.SupplementalAttributeAssociations}","page":"API","title":"InfrastructureSystems.get_num_attributes","text":"get_num_attributes(\n    associations::InfrastructureSystems.SupplementalAttributeAssociations\n) -> Any\n\n\nReturn the number of supplemental attributes.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_num_components_with_attributes-Tuple{InfrastructureSystems.SupplementalAttributeAssociations}","page":"API","title":"InfrastructureSystems.get_num_components_with_attributes","text":"get_num_components_with_attributes(\n    associations::InfrastructureSystems.SupplementalAttributeAssociations\n) -> Any\n\n\nReturn the number of components with supplemental attributes.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_num_steps-Union{Tuple{T}, Tuple{Type{T}, CSV.File, AbstractArray}} where T<:InfrastructureSystems.TimeSeriesFileFormat","page":"API","title":"InfrastructureSystems.get_num_steps","text":"get_num_steps(\n    _::Type{T<:InfrastructureSystems.TimeSeriesFileFormat},\n    file::CSV.File,\n    period::AbstractArray\n) -> Any\n\n\nReturn the number of steps specified by the period in the file.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_num_steps-Union{Tuple{T}, Tuple{Type{T}, CSV.File, AbstractArray}} where T<:InfrastructureSystems.TimeSeriesFormatPeriodAsHeader","page":"API","title":"InfrastructureSystems.get_num_steps","text":"get_num_steps(\n    _::Type{T<:InfrastructureSystems.TimeSeriesFormatPeriodAsHeader},\n    file::CSV.File,\n    period::AbstractArray\n) -> Any\n\n\nReturn the number of steps specified by the period in the file.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_num_steps-Union{Tuple{T}, Tuple{Type{T}, CSV.File, AbstractArray}} where T<:Union{InfrastructureSystems.TimeSeriesFormatDateTimeAsColumn, InfrastructureSystems.TimeSeriesFormatPeriodAsColumn}","page":"API","title":"InfrastructureSystems.get_num_steps","text":"get_num_steps(\n    _::Type{T<:Union{InfrastructureSystems.TimeSeriesFormatDateTimeAsColumn, InfrastructureSystems.TimeSeriesFormatPeriodAsColumn}},\n    file::CSV.File,\n    period::AbstractArray\n) -> Any\n\n\nReturn the number of steps specified by the period in the file.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_num_subsystems-Tuple{InfrastructureSystems.SystemData}","page":"API","title":"InfrastructureSystems.get_num_subsystems","text":"get_num_subsystems(\n    data::InfrastructureSystems.SystemData\n) -> Int64\n\n\nReturn the number of subsystems in the system.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_num_time_series-Tuple{InfrastructureSystems.TimeSeriesMetadataStore}","page":"API","title":"InfrastructureSystems.get_num_time_series","text":"get_num_time_series(\n    store::InfrastructureSystems.TimeSeriesMetadataStore\n) -> Any\n\n\nReturn the number of unique time series arrays.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_percentiles-Tuple{InfrastructureSystems.ProbabilisticMetadata}","page":"API","title":"InfrastructureSystems.get_percentiles","text":"get_percentiles(\n    value::InfrastructureSystems.ProbabilisticMetadata\n) -> Vector{Float64}\n\n\nGet ProbabilisticMetadata percentiles.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_percentiles-Tuple{InfrastructureSystems.Probabilistic}","page":"API","title":"InfrastructureSystems.get_percentiles","text":"get_percentiles(\n    value::InfrastructureSystems.Probabilistic\n) -> Vector{Float64}\n\n\nGet Probabilistic percentiles.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_period_columns-Tuple{Type{InfrastructureSystems.TimeSeriesFormatPeriodAsColumn}, CSV.File}","page":"API","title":"InfrastructureSystems.get_period_columns","text":"get_period_columns(\n    _::Type{InfrastructureSystems.TimeSeriesFormatPeriodAsColumn},\n    file::CSV.File\n) -> Vector{Symbol}\n\n\nReturn the column names that specify the Period.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_points-Tuple{InfrastructureSystems.PiecewiseLinearData}","page":"API","title":"InfrastructureSystems.get_points","text":"get_points(\n    data::InfrastructureSystems.PiecewiseLinearData\n) -> Vector{@NamedTuple{x::Float64, y::Float64}}\n\n\nGet the points that define the piecewise data\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_points-Tuple{PiecewisePointCurve}","page":"API","title":"InfrastructureSystems.get_points","text":"get_points(\n    vc::PiecewisePointCurve\n) -> Vector{@NamedTuple{x::Float64, y::Float64}}\n\n\nGet the points that define the PiecewisePointCurve\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_power_units-Tuple{InfrastructureSystems.ProductionVariableCostCurve}","page":"API","title":"InfrastructureSystems.get_power_units","text":"get_power_units(\n    cost::InfrastructureSystems.ProductionVariableCostCurve\n) -> Any\n\n\nGet the units for the x-axis of the curve\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_proportional_term-Tuple{LinearCurve}","page":"API","title":"InfrastructureSystems.get_proportional_term","text":"get_proportional_term(vc::LinearCurve) -> Float64\n\n\nGet the proportional term (i.e., slope) of the LinearCurve\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_proportional_term-Tuple{QuadraticCurve}","page":"API","title":"InfrastructureSystems.get_proportional_term","text":"get_proportional_term(vc::QuadraticCurve) -> Float64\n\n\nGet the proportional (i.e., linear) term of the QuadraticCurve\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_quadratic_term-Tuple{QuadraticCurve}","page":"API","title":"InfrastructureSystems.get_quadratic_term","text":"get_quadratic_term(vc::QuadraticCurve) -> Float64\n\n\nGet the quadratic term of the QuadraticCurve\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_raw_data_type","page":"API","title":"InfrastructureSystems.get_raw_data_type","text":"Get from a subtype or instance of FunctionData the type of data its get_raw_data method returns\n\n\n\n\n\n","category":"function"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_resolution-Tuple{InfrastructureSystems.DeterministicMetadata}","page":"API","title":"InfrastructureSystems.get_resolution","text":"get_resolution(\n    value::InfrastructureSystems.DeterministicMetadata\n) -> Dates.Period\n\n\nGet DeterministicMetadata resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_resolution-Tuple{InfrastructureSystems.Deterministic}","page":"API","title":"InfrastructureSystems.get_resolution","text":"get_resolution(\n    value::InfrastructureSystems.Deterministic\n) -> Dates.Period\n\n\nGet Deterministic resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_resolution-Tuple{InfrastructureSystems.ProbabilisticMetadata}","page":"API","title":"InfrastructureSystems.get_resolution","text":"get_resolution(\n    value::InfrastructureSystems.ProbabilisticMetadata\n) -> Dates.Period\n\n\nGet ProbabilisticMetadata resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_resolution-Tuple{InfrastructureSystems.Probabilistic}","page":"API","title":"InfrastructureSystems.get_resolution","text":"get_resolution(\n    value::InfrastructureSystems.Probabilistic\n) -> Dates.Period\n\n\nGet Probabilistic resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_resolution-Tuple{InfrastructureSystems.ScenariosMetadata}","page":"API","title":"InfrastructureSystems.get_resolution","text":"get_resolution(\n    value::InfrastructureSystems.ScenariosMetadata\n) -> Dates.Period\n\n\nGet ScenariosMetadata resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_resolution-Tuple{InfrastructureSystems.Scenarios}","page":"API","title":"InfrastructureSystems.get_resolution","text":"get_resolution(\n    value::InfrastructureSystems.Scenarios\n) -> Dates.Period\n\n\nGet Scenarios resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_resolution-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata}","page":"API","title":"InfrastructureSystems.get_resolution","text":"get_resolution(\n    value::InfrastructureSystems.SingleTimeSeriesMetadata\n) -> Dates.Period\n\n\nGet SingleTimeSeriesMetadata resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_resolution-Tuple{InfrastructureSystems.SingleTimeSeries}","page":"API","title":"InfrastructureSystems.get_resolution","text":"get_resolution(\n    value::InfrastructureSystems.SingleTimeSeries\n) -> Dates.Period\n\n\nGet SingleTimeSeries resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_resolution-Tuple{TimeSeries.TimeArray}","page":"API","title":"InfrastructureSystems.get_resolution","text":"get_resolution(ts::TimeSeries.TimeArray) -> Any\n\n\nReturn the resolution from a TimeArray by subtracting the first two timestamps.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_scaling_factor_multiplier-Tuple{InfrastructureSystems.DeterministicMetadata}","page":"API","title":"InfrastructureSystems.get_scaling_factor_multiplier","text":"get_scaling_factor_multiplier(\n    value::InfrastructureSystems.DeterministicMetadata\n) -> Union{Nothing, Function}\n\n\nGet DeterministicMetadata scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_scaling_factor_multiplier-Tuple{InfrastructureSystems.Deterministic}","page":"API","title":"InfrastructureSystems.get_scaling_factor_multiplier","text":"get_scaling_factor_multiplier(\n    value::InfrastructureSystems.Deterministic\n) -> Union{Nothing, Function}\n\n\nGet Deterministic scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_scaling_factor_multiplier-Tuple{InfrastructureSystems.ProbabilisticMetadata}","page":"API","title":"InfrastructureSystems.get_scaling_factor_multiplier","text":"get_scaling_factor_multiplier(\n    value::InfrastructureSystems.ProbabilisticMetadata\n) -> Union{Nothing, Function}\n\n\nGet ProbabilisticMetadata scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_scaling_factor_multiplier-Tuple{InfrastructureSystems.Probabilistic}","page":"API","title":"InfrastructureSystems.get_scaling_factor_multiplier","text":"get_scaling_factor_multiplier(\n    value::InfrastructureSystems.Probabilistic\n) -> Union{Nothing, Function}\n\n\nGet Probabilistic scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_scaling_factor_multiplier-Tuple{InfrastructureSystems.ScenariosMetadata}","page":"API","title":"InfrastructureSystems.get_scaling_factor_multiplier","text":"get_scaling_factor_multiplier(\n    value::InfrastructureSystems.ScenariosMetadata\n) -> Union{Nothing, Function}\n\n\nGet ScenariosMetadata scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_scaling_factor_multiplier-Tuple{InfrastructureSystems.Scenarios}","page":"API","title":"InfrastructureSystems.get_scaling_factor_multiplier","text":"get_scaling_factor_multiplier(\n    value::InfrastructureSystems.Scenarios\n) -> Union{Nothing, Function}\n\n\nGet Scenarios scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_scaling_factor_multiplier-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata}","page":"API","title":"InfrastructureSystems.get_scaling_factor_multiplier","text":"get_scaling_factor_multiplier(\n    value::InfrastructureSystems.SingleTimeSeriesMetadata\n) -> Union{Nothing, Function}\n\n\nGet SingleTimeSeriesMetadata scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_scaling_factor_multiplier-Tuple{InfrastructureSystems.SingleTimeSeries}","page":"API","title":"InfrastructureSystems.get_scaling_factor_multiplier","text":"get_scaling_factor_multiplier(\n    value::InfrastructureSystems.SingleTimeSeries\n) -> Union{Nothing, Function}\n\n\nGet SingleTimeSeries scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_scenario_count-Tuple{InfrastructureSystems.ScenariosMetadata}","page":"API","title":"InfrastructureSystems.get_scenario_count","text":"get_scenario_count(\n    value::InfrastructureSystems.ScenariosMetadata\n) -> Int64\n\n\nGet ScenariosMetadata scenario_count.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_scenario_count-Tuple{InfrastructureSystems.Scenarios}","page":"API","title":"InfrastructureSystems.get_scenario_count","text":"get_scenario_count(\n    value::InfrastructureSystems.Scenarios\n) -> Int64\n\n\nGet Scenarios scenario_count.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_serialization_metadata-Tuple{Dict}","page":"API","title":"InfrastructureSystems.get_serialization_metadata","text":"get_serialization_metadata(data::Dict) -> Any\n\n\nReturn the type information for the serialized struct.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_single_time_series-Tuple{InfrastructureSystems.DeterministicSingleTimeSeries}","page":"API","title":"InfrastructureSystems.get_single_time_series","text":"get_single_time_series(\n    value::InfrastructureSystems.DeterministicSingleTimeSeries\n) -> InfrastructureSystems.SingleTimeSeries\n\n\nGet DeterministicSingleTimeSeries single_time_series.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_slopes-Tuple{InfrastructureSystems.PiecewiseLinearData}","page":"API","title":"InfrastructureSystems.get_slopes","text":"get_slopes(\n    pwl::InfrastructureSystems.PiecewiseLinearData\n) -> Vector{Float64}\n\n\nCalculates the slopes of the line segments defined by the PiecewiseLinearData, returning one fewer slope than the number of underlying points.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_slopes-Tuple{PiecewiseIncrementalCurve}","page":"API","title":"InfrastructureSystems.get_slopes","text":"get_slopes(vc::PiecewiseIncrementalCurve) -> Vector{Float64}\n\n\nFetch the slopes that define the PiecewiseIncrementalCurve\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_slopes-Tuple{PiecewisePointCurve}","page":"API","title":"InfrastructureSystems.get_slopes","text":"get_slopes(vc::PiecewisePointCurve) -> Vector{Float64}\n\n\nCalculate the slopes of the line segments defined by the PiecewisePointCurve\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_startup_fuel_offtake-Tuple{InfrastructureSystems.FuelCurve}","page":"API","title":"InfrastructureSystems.get_startup_fuel_offtake","text":"get_startup_fuel_offtake(\n    cost::InfrastructureSystems.FuelCurve\n) -> LinearCurve\n\n\nGet the function for the fuel consumption at startup\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_static_time_series_summary_table-Tuple{InfrastructureSystems.TimeSeriesMetadataStore}","page":"API","title":"InfrastructureSystems.get_static_time_series_summary_table","text":"get_static_time_series_summary_table(\n    store::InfrastructureSystems.TimeSeriesMetadataStore\n) -> DataFrames.DataFrame\n\n\nReturn a DataFrame with the number of static time series for components and supplemental attributes.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_subsystem_components-Tuple{InfrastructureSystems.SystemData, AbstractString}","page":"API","title":"InfrastructureSystems.get_subsystem_components","text":"get_subsystem_components(\n    data::InfrastructureSystems.SystemData,\n    subsystem_name::AbstractString\n) -> Base.Generator{Set{Base.UUID}, InfrastructureSystems.var\"#get_subsystem_components##0#get_subsystem_components##1\"{InfrastructureSystems.SystemData}}\n\n\nReturn a Generator of all components in the subsystem.\n\nThrows ArgumentError if the subsystem name is not stored.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_subsystems-Tuple{InfrastructureSystems.SystemData}","page":"API","title":"InfrastructureSystems.get_subsystems","text":"get_subsystems(\n    data::InfrastructureSystems.SystemData\n) -> Base.KeySet{String, Dict{String, Set{Base.UUID}}}\n\n\nReturn an iterator of all subsystem names in the system.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_supplemental_attributes-Union{Tuple{T}, Tuple{Function, Type{T}, InfrastructureSystems.SupplementalAttributeManager}} where T<:InfrastructureSystems.SupplementalAttribute","page":"API","title":"InfrastructureSystems.get_supplemental_attributes","text":"get_supplemental_attributes(\n    filter_func::Function,\n    _::Type{T<:InfrastructureSystems.SupplementalAttribute},\n    mgr::InfrastructureSystems.SupplementalAttributeManager\n) -> InfrastructureSystems.FlattenIteratorWrapper{T, I} where {T<:InfrastructureSystems.SupplementalAttribute, I<:(Vector)}\n\n\nReturns an iterator of supplemental_attributes. T can be concrete or abstract. Call collect on the result if an array is desired.\n\nArguments\n\nT: supplemental_attribute type\nmgr::SupplementalAttributeManager: SupplementalAttributeManager in the system\nfilter_func::Union{Nothing, Function} = nothing: Optional function that accepts a component of type T and returns a Bool. Apply this function to each component and only return components where the result is true.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_supplemental_attributes-Union{Tuple{T}, Tuple{Type{T}, InfrastructureSystems.InfrastructureSystemsComponent}} where T<:InfrastructureSystems.SupplementalAttribute","page":"API","title":"InfrastructureSystems.get_supplemental_attributes","text":"get_supplemental_attributes(\n    _::Type{T<:InfrastructureSystems.SupplementalAttribute},\n    component::InfrastructureSystems.InfrastructureSystemsComponent\n) -> Any\n\n\nReturn a Vector of supplemental_attributes. T can be concrete or abstract.\n\nArguments\n\nT: supplemental_attribute type\nsupplemental_attributes::SupplementalAttributes: SupplementalAttributes in the system\nfilter_func::Union{Nothing, Function} = nothing: Optional function that accepts a component of type T and returns a Bool. Apply this function to each component and only return components where the result is true.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series-Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}, InfrastructureSystems.TimeSeriesKey}","page":"API","title":"InfrastructureSystems.get_time_series","text":"get_time_series(\n    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute},\n    key::InfrastructureSystems.TimeSeriesKey;\n    start_time,\n    len,\n    count\n) -> Any\n\n\nReturn the exact stored data in a time series, using a time series key.\n\nThis will load all forecast windows into memory by default. Be aware of how much data is stored.\n\nSpecify start_time and len if you only need a subset of data.\n\nDoes not apply a scaling factor multiplier.\n\nArguments\n\nowner::TimeSeriesOwners: Component or attribute containing the time series\nkey::TimeSeriesKey: the time series' key\nstart_time::Union{Nothing, Dates.DateTime} = nothing: If nothing, use the initial_timestamp of the time series. If the time series is a subtype of Forecast then start_time must be the first timestamp of a window.\nlen::Union{Nothing, Int} = nothing: Length in the time dimension. If nothing, use the entire length.\ncount::Union{Nothing, Int} = nothing: Only applicable to subtypes of Forecast. Number of forecast windows starting at start_time to return. Defaults to all available.\nfeatures...: User-defined tags that differentiate multiple time series arrays for the same component attribute, such as different arrays for different scenarios or years\n\nSee also: get_time_series by name\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series-Union{Tuple{T}, Tuple{Type{T}, Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}, AbstractString}} where T<:InfrastructureSystems.TimeSeriesData","page":"API","title":"InfrastructureSystems.get_time_series","text":"get_time_series(\n    ::Type{T<:InfrastructureSystems.TimeSeriesData},\n    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute},\n    name::AbstractString;\n    start_time,\n    len,\n    count,\n    resolution,\n    features...\n) -> Any\n\n\nReturn the exact stored data in a time series\n\nThis will load all forecast windows into memory by default. Be aware of how much data is stored.\n\nSpecify start_time and len if you only need a subset of data.\n\nDoes not apply a scaling factor multiplier.\n\nArguments\n\n::Type{T}: Concrete subtype of TimeSeriesData to return\nowner::TimeSeriesOwners: Component or attribute containing the time series\nname::AbstractString: name of time series\nresolution::Union{Nothing, Dates.Period} = nothing: Required if resolution is needed  to uniquely identify the time series.\nstart_time::Union{Nothing, Dates.DateTime} = nothing: If nothing, use the initial_timestamp of the time series. If T is a subtype of Forecast then start_time must be the first timestamp of a window.\nlen::Union{Nothing, Int} = nothing: Length in the time dimension. If nothing, use the entire length.\ncount::Union{Nothing, Int} = nothing: Only applicable to subtypes of Forecast. Number of forecast windows starting at start_time to return. Defaults to all available.\nfeatures...: User-defined tags that differentiate multiple time series arrays for the same component attribute, such as different arrays for different scenarios or years\n\nSee also: get_time_series_array, get_time_series_values, get_time_series by key\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_array!-Tuple{InfrastructureSystems.TimeSeriesCache, Dates.DateTime}","page":"API","title":"InfrastructureSystems.get_time_series_array!","text":"get_time_series_array!(\n    cache::InfrastructureSystems.TimeSeriesCache,\n    timestamp::Dates.DateTime\n) -> Any\n\n\nReturn the TimeSeries.TimeArray starting at timestamp. Reads from storage if the data is not already in cache.\n\nTimestamps must be read sequentially. Repeated reads are allowed. Random access may be added in the future.\n\nArguments\n\ncache::StaticTimeSeriesCache: cached instance\ntimestamp::Dates.DateTime: starting timestamp for the time series array\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_array-Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}, InfrastructureSystems.Forecast}","page":"API","title":"InfrastructureSystems.get_time_series_array","text":"get_time_series_array(\n    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute},\n    forecast::InfrastructureSystems.Forecast;\n    start_time,\n    len,\n    ignore_scaling_factors\n) -> Any\n\n\nReturn a TimeSeries.TimeArray for one forecast window from a cached Forecast instance\n\nIf the time series data are scaling factors, the returned data will be scaled by the scaling factor multiplier by default.\n\nArguments\n\nowner::TimeSeriesOwners: Component or attribute containing the time series\nforecast::Forecast: a concrete subtype of Forecast\nstart_time::Union{Nothing, Dates.DateTime} = nothing: the first timestamp of one of the forecast windows\nlen::Union{Nothing, Int} = nothing: Length of time-series to retrieve (i.e. number of timestamps). If nothing, use the entire length.\nignore_scaling_factors = false: If true, the time-series data will be multiplied by the result of calling the stored scaling_factor_multiplier function on the owner\n\nSee also get_time_series_values, get_time_series_timestamps, ForecastCache, get_time_series_array by name from storage, get_time_series_array from a StaticTimeSeriesCache\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_array-Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}, InfrastructureSystems.StaticTimeSeries}","page":"API","title":"InfrastructureSystems.get_time_series_array","text":"get_time_series_array(\n    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute},\n    time_series::InfrastructureSystems.StaticTimeSeries;\n    start_time,\n    len,\n    ignore_scaling_factors\n) -> Any\n\n\nReturn a TimeSeries.TimeArray from a cached StaticTimeSeries instance.\n\nIf the time series data are scaling factors, the returned data will be scaled by the scaling factor multiplier by default.\n\nArguments\n\nowner::TimeSeriesOwners: Component or attribute containing the time series\ntime_series::StaticTimeSeries: subtype of StaticTimeSeries (e.g., SingleTimeSeries)\nstart_time::Union{Nothing, Dates.DateTime} = nothing: the first timestamp to retrieve. If nothing, use the initial_timestamp of the time series.\nlen::Union{Nothing, Int} = nothing: Length of time-series to retrieve (i.e. number of timestamps). If nothing, use the entire length\nignore_scaling_factors = false: If true, the time-series data will be multiplied by the result of calling the stored scaling_factor_multiplier function on the owner\n\nSee also: get_time_series_values, get_time_series_timestamps, StaticTimeSeriesCache, get_time_series_array by name from storage, get_time_series_array from a ForecastCache\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_array-Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}, InfrastructureSystems.TimeSeriesKey}","page":"API","title":"InfrastructureSystems.get_time_series_array","text":"get_time_series_array(\n    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute},\n    key::InfrastructureSystems.TimeSeriesKey;\n    start_time,\n    len,\n    ignore_scaling_factors\n) -> Any\n\n\nReturn a TimeSeries.TimeArray from storage, using a time series key.\n\nIf the time series data are scaling factors, the returned data will be scaled by the scaling factor multiplier by default.\n\nArguments\n\nowner::TimeSeriesOwners: Component or attribute containing the time series\nkey::TimeSeriesKey: the time series key\nstart_time::Union{Nothing, Dates.DateTime} = nothing: If nothing, use the initial_timestamp of the time series. If the time series is a subtype of Forecast then start_time must be the first timestamp of a window.\nlen::Union{Nothing, Int} = nothing: Length of time-series to retrieve (i.e. number of timestamps). If nothing, use the entire length.\nignore_scaling_factors = false: If true, the time-series data will be multiplied by the result of calling the stored scaling_factor_multiplier function on the owner\n\nSee also: get_time_series_array by name, get_time_series_values, get_time_series_timestamps\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_array-Union{Tuple{T}, Tuple{Type{T}, Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}, AbstractString}} where T<:InfrastructureSystems.TimeSeriesData","page":"API","title":"InfrastructureSystems.get_time_series_array","text":"get_time_series_array(\n    ::Type{T<:InfrastructureSystems.TimeSeriesData},\n    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute},\n    name::AbstractString;\n    resolution,\n    start_time,\n    len,\n    ignore_scaling_factors,\n    features...\n) -> Any\n\n\nReturn a TimeSeries.TimeArray from storage for the given time series parameters.\n\nIf the time series data are scaling factors, the returned data will be scaled by the scaling factor multiplier by default.\n\nThis will load all forecast windows into memory by default. Be aware of how much data is stored.\n\nSpecify start_time and len if you only need a subset of data.\n\nArguments\n\n::Type{T}: the type of time series (a concrete subtype of TimeSeriesData)\nowner::TimeSeriesOwners: Component or attribute containing the time series\nname::AbstractString: name of time series\nresolution::Union{Nothing, Dates.Period} = nothing: Required if resolution is needed  to uniquely identify the time series.\nstart_time::Union{Nothing, Dates.DateTime} = nothing: If nothing, use the initial_timestamp of the time series. If T is a subtype of Forecast then start_time must be the first timestamp of a window.\nlen::Union{Nothing, Int} = nothing: Length of time-series to retrieve (i.e. number of timestamps). If nothing, use the entire length.\nignore_scaling_factors = false: If true, the time-series data will be multiplied by the result of calling the stored scaling_factor_multiplier function on the owner\nfeatures...: User-defined tags that differentiate multiple time series arrays for the same component attribute, such as different arrays for different scenarios or years\n\nSee also: get_time_series_values, get_time_series_timestamps, get_time_series_array from a StaticTimeSeriesCache, get_time_series_array from a ForecastCache\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_counts-Tuple{InfrastructureSystems.TimeSeriesMetadataStore}","page":"API","title":"InfrastructureSystems.get_time_series_counts","text":"get_time_series_counts(\n    store::InfrastructureSystems.TimeSeriesMetadataStore\n) -> InfrastructureSystems.TimeSeriesCounts\n\n\nReturn an instance of TimeSeriesCounts.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_counts_by_type-Tuple{InfrastructureSystems.TimeSeriesMetadataStore}","page":"API","title":"InfrastructureSystems.get_time_series_counts_by_type","text":"get_time_series_counts_by_type(\n    store::InfrastructureSystems.TimeSeriesMetadataStore\n) -> Vector\n\n\nReturn a Vector of OrderedDict of stored time series counts by type.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_format-Tuple{CSV.File}","page":"API","title":"InfrastructureSystems.get_time_series_format","text":"get_time_series_format(file::CSV.File) -> Type\n\n\nReturn the time series format used in the CSV file.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_keys-Tuple{InfrastructureSystems.TimeSeriesMetadataStore, Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}}","page":"API","title":"InfrastructureSystems.get_time_series_keys","text":"get_time_series_keys(\n    store::InfrastructureSystems.TimeSeriesMetadataStore,\n    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}\n) -> Vector\n\n\nReturn information about each time series array attached to the owner. This information can be used to call get_time_series.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_keys-Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}}","page":"API","title":"InfrastructureSystems.get_time_series_keys","text":"get_time_series_keys(\n    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}\n) -> Vector\n\n\nReturn information about each time series array attached to the owner. This information can be used to call get_time_series(::TimeSeriesOwners, ::TimeSeriesKey).\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_manager-Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}}","page":"API","title":"InfrastructureSystems.get_time_series_manager","text":"get_time_series_manager(\n    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}\n) -> Any\n\n\nReturn the TimeSeriesManager or nothing if the component/attribute does not support time series.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_multiple","page":"API","title":"InfrastructureSystems.get_time_series_multiple","text":"get_time_series_multiple(\n    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute};\n    ...\n) -> Union{Tuple{}, Channel{Any}}\nget_time_series_multiple(\n    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute},\n    filter_func;\n    type,\n    name,\n    resolution\n) -> Union{Tuple{}, Channel{Any}}\n\n\nReturns an iterator of TimeSeriesData instances attached to the component or attribute.\n\nNote that passing a filter function can be much slower than the other filtering parameters because it reads time series data from media.\n\nCall collect on the result to get an array.\n\nArguments\n\nowner::TimeSeriesOwners: component or attribute from which to get time_series\nfilter_func = nothing: Only return time_series for which this returns true.\ntype::Union{Nothing, ::Type{<:TimeSeriesData}} = nothing: Only return time_series with this type.\nname::Union{Nothing, AbstractString} = nothing: Only return time_series matching this value.\nresolution::Union{Nothing, Dates.Period} = nothing: Only return time_series matching this value.\n\nSee also: get_time_series_multiple from a System\n\n\n\n\n\n","category":"function"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_multiple-2","page":"API","title":"InfrastructureSystems.get_time_series_multiple","text":"get_time_series_multiple(\n    data::InfrastructureSystems.SystemData;\n    ...\n) -> Channel{Any}\nget_time_series_multiple(\n    data::InfrastructureSystems.SystemData,\n    filter_func;\n    type,\n    name\n) -> Channel{Any}\n\n\nReturns an iterator of TimeSeriesData instances attached to the system.\n\nNote that passing a filter function can be much slower than the other filtering parameters because it reads time series data from media.\n\nCall collect on the result to get an array.\n\nArguments\n\ndata::SystemData: system\nfilter_func = nothing: Only return time_series for which this returns true.\ntype = nothing: Only return time_series with this type.\nname = nothing: Only return time_series matching this value.\n\nSee also: get_time_series_multiple from an individual component or attribute\n\n\n\n\n\n","category":"function"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_resolutions-Tuple{InfrastructureSystems.TimeSeriesMetadataStore}","page":"API","title":"InfrastructureSystems.get_time_series_resolutions","text":"get_time_series_resolutions(\n    store::InfrastructureSystems.TimeSeriesMetadataStore;\n    time_series_type\n) -> Any\n\n\nReturn a sorted Vector of distinct resolutions for all time series of the given type (or all types).\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_timestamps-Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}, InfrastructureSystems.Forecast}","page":"API","title":"InfrastructureSystems.get_time_series_timestamps","text":"get_time_series_timestamps(\n    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute},\n    forecast::InfrastructureSystems.Forecast;\n    start_time,\n    len\n) -> Vector{D} where D<:Dates.TimeType\n\n\nReturn a vector of timestamps from a cached Forecast instance.\n\nArguments\n\nowner::TimeSeriesOwners: Component or attribute containing the time series\nforecast::Forecast: a concrete subtype of Forecast\nstart_time::Union{Nothing, Dates.DateTime} = nothing: the first timestamp of one of the forecast windows\nlen::Union{Nothing, Int} = nothing: Length of time-series to retrieve (i.e. number of timestamps). If nothing, use the entire length.\n\nSee also: get_time_series_array, get_time_series_values, ForecastCache, get_time_series_timestamps by name from storage, get_time_series_timestamps from a StaticTimeSeriesCache\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_timestamps-Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}, InfrastructureSystems.StaticTimeSeries}","page":"API","title":"InfrastructureSystems.get_time_series_timestamps","text":"get_time_series_timestamps(\n    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute},\n    time_series::InfrastructureSystems.StaticTimeSeries;\n    start_time,\n    len\n) -> Vector{D} where D<:Dates.TimeType\n\n\nReturn a vector of timestamps from a cached StaticTimeSeries instance.\n\nArguments\n\nowner::TimeSeriesOwners: Component or attribute containing the time series\ntime_series::StaticTimeSeries: subtype of StaticTimeSeries (e.g., SingleTimeSeries)\nstart_time::Union{Nothing, Dates.DateTime} = nothing: the first timestamp to retrieve. If nothing, use the initial_timestamp of the time series.\nlen::Union{Nothing, Int} = nothing: Length of time-series to retrieve (i.e. number of timestamps). If nothing, use the entire length\n\nSee also: get_time_series_array, get_time_series_values, StaticTimeSeriesCache, get_time_series_timestamps by name from storage, get_time_series_timestamps from a ForecastCache\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_timestamps-Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}, InfrastructureSystems.TimeSeriesKey}","page":"API","title":"InfrastructureSystems.get_time_series_timestamps","text":"get_time_series_timestamps(\n    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute},\n    key::InfrastructureSystems.TimeSeriesKey;\n    start_time,\n    len\n) -> Vector{D} where D<:Dates.TimeType\n\n\nReturn a vector of timestamps from storage, using a time series key.\n\nArguments\n\nowner::TimeSeriesOwners: Component or attribute containing the time series\nkey::TimeSeriesKey: the time series key\nstart_time::Union{Nothing, Dates.DateTime} = nothing: If nothing, use the initial_timestamp of the time series. If the time series is a subtype of Forecast then start_time must be the first timestamp of a window.\nlen::Union{Nothing, Int} = nothing: Length of time-series to retrieve (i.e. number of timestamps). If nothing, use the entire length.\n\nSee also: get_time_series_timestamps by name, get_time_series_array, get_time_series_values\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_timestamps-Union{Tuple{T}, Tuple{Type{T}, Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}, AbstractString}} where T<:InfrastructureSystems.TimeSeriesData","page":"API","title":"InfrastructureSystems.get_time_series_timestamps","text":"get_time_series_timestamps(\n    ::Type{T<:InfrastructureSystems.TimeSeriesData},\n    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute},\n    name::AbstractString;\n    resolution,\n    start_time,\n    len,\n    features...\n) -> Vector{D} where D<:Dates.TimeType\n\n\nReturn a vector of timestamps from storage for the given time series parameters.\n\nArguments\n\n::Type{T}: the type of time series (a concrete subtype of TimeSeriesData)\nowner::TimeSeriesOwners: Component or attribute containing the time series\nname::AbstractString: name of time series\nresolution::Union{Nothing, Dates.Period} = nothing: Required if resolution is needed  to uniquely identify the time series.\nstart_time::Union{Nothing, Dates.DateTime} = nothing: If nothing, use the initial_timestamp of the time series. If T is a subtype of Forecast then start_time must be the first timestamp of a window.\nlen::Union{Nothing, Int} = nothing: Length of time-series to retrieve (i.e. number of timestamps). If nothing, use the entire length.\nfeatures...: User-defined tags that differentiate multiple time series arrays for the same component attribute, such as different arrays for different scenarios or years\n\nSee also: get_time_series_array, get_time_series_values, get_time_series_timestamps from a StaticTimeSeriesCache, get_time_series_timestamps from a ForecastCache\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_type-Tuple{InfrastructureSystems.DeterministicMetadata}","page":"API","title":"InfrastructureSystems.get_time_series_type","text":"get_time_series_type(\n    value::InfrastructureSystems.DeterministicMetadata\n) -> Type{<:InfrastructureSystems.AbstractDeterministic}\n\n\nGet DeterministicMetadata time_series_type.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_uuid-Tuple{InfrastructureSystems.DeterministicMetadata}","page":"API","title":"InfrastructureSystems.get_time_series_uuid","text":"get_time_series_uuid(\n    value::InfrastructureSystems.DeterministicMetadata\n) -> Base.UUID\n\n\nGet DeterministicMetadata time_series_uuid.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_uuid-Tuple{InfrastructureSystems.ProbabilisticMetadata}","page":"API","title":"InfrastructureSystems.get_time_series_uuid","text":"get_time_series_uuid(\n    value::InfrastructureSystems.ProbabilisticMetadata\n) -> Base.UUID\n\n\nGet ProbabilisticMetadata time_series_uuid.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_uuid-Tuple{InfrastructureSystems.ScenariosMetadata}","page":"API","title":"InfrastructureSystems.get_time_series_uuid","text":"get_time_series_uuid(\n    value::InfrastructureSystems.ScenariosMetadata\n) -> Base.UUID\n\n\nGet ScenariosMetadata time_series_uuid.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_uuid-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata}","page":"API","title":"InfrastructureSystems.get_time_series_uuid","text":"get_time_series_uuid(\n    value::InfrastructureSystems.SingleTimeSeriesMetadata\n) -> Base.UUID\n\n\nGet SingleTimeSeriesMetadata time_series_uuid.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_values-Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}, InfrastructureSystems.Forecast}","page":"API","title":"InfrastructureSystems.get_time_series_values","text":"get_time_series_values(\n    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute},\n    forecast::InfrastructureSystems.Forecast;\n    start_time,\n    len,\n    ignore_scaling_factors\n) -> Any\n\n\nReturn an vector of timeseries data without timestamps for one forecast window from a cached Forecast instance.\n\nArguments\n\nowner::TimeSeriesOwners: Component or attribute containing the time series\nforecast::Forecast: a concrete subtype of Forecast\nstart_time::Union{Nothing, Dates.DateTime} = nothing: the first timestamp of one of the forecast windows\nlen::Union{Nothing, Int} = nothing: Length of time-series to retrieve (i.e. number of timestamps). If nothing, use the entire length.\nignore_scaling_factors = false: If true, the time-series data will be multiplied by the result of calling the stored scaling_factor_multiplier function on the owner\n\nSee also: get_time_series_array, get_time_series_timestamps, ForecastCache, get_time_series_values by name from storage, get_time_series_values from a StaticTimeSeriesCache\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_values-Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}, InfrastructureSystems.StaticTimeSeries}","page":"API","title":"InfrastructureSystems.get_time_series_values","text":"get_time_series_values(\n    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute},\n    time_series::InfrastructureSystems.StaticTimeSeries;\n    start_time,\n    len,\n    ignore_scaling_factors\n) -> Any\n\n\nReturn an vector of timeseries data without timestamps from a cached StaticTimeSeries instance\n\nArguments\n\nowner::TimeSeriesOwners: Component or attribute containing the time series\ntime_series::StaticTimeSeries: subtype of StaticTimeSeries (e.g., SingleTimeSeries)\nstart_time::Union{Nothing, Dates.DateTime} = nothing: the first timestamp to retrieve. If nothing, use the initial_timestamp of the time series.\nlen::Union{Nothing, Int} = nothing: Length of time-series to retrieve (i.e. number of timestamps). If nothing, use the entire length\nignore_scaling_factors = false: If true, the time-series data will be multiplied by the result of calling the stored scaling_factor_multiplier function on the owner\n\nSee also: get_time_series_array, get_time_series_timestamps, StaticTimeSeriesCache, get_time_series_values by name from storage, get_time_series_values from a ForecastCache\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_values-Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}, InfrastructureSystems.TimeSeriesKey}","page":"API","title":"InfrastructureSystems.get_time_series_values","text":"get_time_series_values(\n    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute},\n    key::InfrastructureSystems.TimeSeriesKey;\n    start_time,\n    len,\n    ignore_scaling_factors\n) -> Any\n\n\nReturn a vector of time series data without timestamps from storage, using a time series key.\n\nArguments\n\nowner::TimeSeriesOwners: Component or attribute containing the time series\nkey::TimeSeriesKey: the time series key\nstart_time::Union{Nothing, Dates.DateTime} = nothing: If nothing, use the initial_timestamp of the time series. If the time series is a subtype of Forecast then start_time must be the first timestamp of a window.\nlen::Union{Nothing, Int} = nothing: Length of time-series to retrieve (i.e. number of timestamps). If nothing, use the entire length.\nignore_scaling_factors = false: If true, the time-series data will be multiplied by the result of calling the stored scaling_factor_multiplier function on the owner\n\nSee also: get_time_series_values by name, get_time_series_array, get_time_series_timestamps\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_values-Union{Tuple{T}, Tuple{Type{T}, Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}, AbstractString}} where T<:InfrastructureSystems.TimeSeriesData","page":"API","title":"InfrastructureSystems.get_time_series_values","text":"get_time_series_values(\n    ::Type{T<:InfrastructureSystems.TimeSeriesData},\n    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute},\n    name::AbstractString;\n    resolution,\n    start_time,\n    len,\n    ignore_scaling_factors,\n    features...\n) -> Any\n\n\nReturn an vector of timeseries data without timestamps from storage\n\nIf the data size is small and this will be called many times, consider using the version that accepts a cached TimeSeriesData instance.\n\nArguments\n\n::Type{T}: type of the time series (a concrete subtype of TimeSeriesData)\nowner::TimeSeriesOwners: Component or attribute containing the time series\nname::AbstractString: name of time series\nresolution::Union{Nothing, Dates.Period} = nothing: Required if resolution is needed  to uniquely identify the time series.\nstart_time::Union{Nothing, Dates.DateTime} = nothing: If nothing, use the initial_timestamp of the time series. If T is a subtype of Forecast then start_time must be the first timestamp of a window.\nlen::Union{Nothing, Int} = nothing: Length of time-series to retrieve (i.e. number of timestamps). If nothing, use the entire length.\nignore_scaling_factors = false: If true, the time-series data will be multiplied by the result of calling the stored scaling_factor_multiplier function on the owner\nfeatures...: User-defined tags that differentiate multiple time series arrays for the same component attribute, such as different arrays for different scenarios or years\n\nSee also: get_time_series_array, get_time_series_timestamps, get_time_series, get_time_series_values from a StaticTimeSeriesCache, get_time_series_values from a ForecastCache\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_timestamp-Tuple{Type{InfrastructureSystems.TimeSeriesFormatYMDPeriodAsColumn}, CSV.File, Int64}","page":"API","title":"InfrastructureSystems.get_timestamp","text":"get_timestamp(\n    _::Type{InfrastructureSystems.TimeSeriesFormatYMDPeriodAsColumn},\n    file::CSV.File,\n    row_index::Int64\n) -> Any\n\n\nReturn a Dates.DateTime for the row in the CSV file.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_total_period-Tuple{InfrastructureSystems.Forecast}","page":"API","title":"InfrastructureSystems.get_total_period","text":"get_total_period(f::InfrastructureSystems.Forecast) -> Any\n\n\nReturn the total period covered by the forecast.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_unique_timestamps-Union{Tuple{T}, Tuple{Type{T}, CSV.File}} where T<:InfrastructureSystems.TimeSeriesFileFormat","page":"API","title":"InfrastructureSystems.get_unique_timestamps","text":"get_unique_timestamps(\n    _::Type{T<:InfrastructureSystems.TimeSeriesFileFormat},\n    file::CSV.File\n) -> Vector{Dict{String, Any}}\n\n\nReturn a vector of dicts of unique timestamps and their counts.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_uuid-Tuple{InfrastructureSystems.GeographicInfo}","page":"API","title":"InfrastructureSystems.get_uuid","text":"get_uuid(\n    geo::InfrastructureSystems.GeographicInfo\n) -> Base.UUID\n\n\nget_uuid(geo::GeographicInfo)\n\nGet the UUID from a GeographicInfo attribute.\n\nArguments\n\ngeo::GeographicInfo: the GeographicInfo attribute\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_uuid-Tuple{InfrastructureSystems.InfrastructureSystemsType}","page":"API","title":"InfrastructureSystems.get_uuid","text":"get_uuid(\n    obj::InfrastructureSystems.InfrastructureSystemsType\n) -> Base.UUID\n\n\nGets the UUID for any InfrastructureSystemsType.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_value_columns-Tuple{Type{InfrastructureSystems.TimeSeriesFormatComponentsAsColumnsNoTime}, CSV.File}","page":"API","title":"InfrastructureSystems.get_value_columns","text":"get_value_columns(\n    _::Type{InfrastructureSystems.TimeSeriesFormatComponentsAsColumnsNoTime},\n    file::CSV.File\n) -> Vector{Symbol}\n\n\nReturn the column names with values.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_value_columns-Tuple{Type{InfrastructureSystems.TimeSeriesFormatYMDPeriodAsColumn}, CSV.File}","page":"API","title":"InfrastructureSystems.get_value_columns","text":"get_value_columns(\n    _::Type{InfrastructureSystems.TimeSeriesFormatYMDPeriodAsColumn},\n    file::CSV.File\n) -> Vector{Symbol}\n\n\nReturn the column names with values (components).\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_value_curve-Tuple{InfrastructureSystems.ProductionVariableCostCurve}","page":"API","title":"InfrastructureSystems.get_value_curve","text":"get_value_curve(\n    cost::InfrastructureSystems.ProductionVariableCostCurve\n) -> Any\n\n\nGet the underlying ValueCurve representation of this ProductionVariableCostCurve\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_vom_cost-Tuple{InfrastructureSystems.ProductionVariableCostCurve}","page":"API","title":"InfrastructureSystems.get_vom_cost","text":"get_vom_cost(\n    cost::InfrastructureSystems.ProductionVariableCostCurve\n) -> Any\n\n\nGet the variable operation and maintenance cost in currency/(power_units h)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_window-Tuple{InfrastructureSystems.Forecast, Int64}","page":"API","title":"InfrastructureSystems.get_window","text":"get_window(\n    forecast::InfrastructureSystems.Forecast,\n    index::Int64;\n    len\n) -> Any\n\n\nReturn the forecast window corresponsing to interval index.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_x_coords-Tuple{InfrastructureSystems.PiecewiseLinearData}","page":"API","title":"InfrastructureSystems.get_x_coords","text":"get_x_coords(\n    data::InfrastructureSystems.PiecewiseLinearData\n) -> Vector{Float64}\n\n\nGet the x-coordinates of the points that define the piecewise data\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_x_coords-Tuple{InfrastructureSystems.PiecewiseStepData}","page":"API","title":"InfrastructureSystems.get_x_coords","text":"get_x_coords(\n    data::InfrastructureSystems.PiecewiseStepData\n) -> Vector{Float64}\n\n\nGet the x-coordinates of the points that define the piecewise data\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_x_coords-Tuple{PiecewiseAverageCurve}","page":"API","title":"InfrastructureSystems.get_x_coords","text":"get_x_coords(vc::PiecewiseAverageCurve) -> Vector{Float64}\n\n\nGet the x-coordinates that define the PiecewiseAverageCurve\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_x_coords-Tuple{PiecewiseIncrementalCurve}","page":"API","title":"InfrastructureSystems.get_x_coords","text":"get_x_coords(\n    vc::PiecewiseIncrementalCurve\n) -> Vector{Float64}\n\n\nGet the x-coordinates that define the PiecewiseIncrementalCurve\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_x_coords-Tuple{PiecewisePointCurve}","page":"API","title":"InfrastructureSystems.get_x_coords","text":"get_x_coords(vc::PiecewisePointCurve) -> Vector{Float64}\n\n\nGet the x-coordinates of the points that define the PiecewisePointCurve\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_x_lengths-Tuple{Union{InfrastructureSystems.PiecewiseLinearData, InfrastructureSystems.PiecewiseStepData}}","page":"API","title":"InfrastructureSystems.get_x_lengths","text":"get_x_lengths(\n    pwl::Union{InfrastructureSystems.PiecewiseLinearData, InfrastructureSystems.PiecewiseStepData}\n) -> Vector{Float64}\n\n\nCalculates the x-length of each segment of a piecewise curve.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_y_coords-Tuple{InfrastructureSystems.PiecewiseLinearData}","page":"API","title":"InfrastructureSystems.get_y_coords","text":"get_y_coords(\n    data::InfrastructureSystems.PiecewiseLinearData\n) -> Vector{Float64}\n\n\nGet the y-coordinates of the points that define the PiecewiseLinearData\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_y_coords-Tuple{InfrastructureSystems.PiecewiseStepData}","page":"API","title":"InfrastructureSystems.get_y_coords","text":"get_y_coords(\n    data::InfrastructureSystems.PiecewiseStepData\n) -> Vector{Float64}\n\n\nGet the y-coordinates of the segments in the PiecewiseStepData\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_y_coords-Tuple{PiecewisePointCurve}","page":"API","title":"InfrastructureSystems.get_y_coords","text":"get_y_coords(vc::PiecewisePointCurve) -> Vector{Float64}\n\n\nGet the y-coordinates of the points that define the PiecewisePointCurve\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.has_association-Tuple{InfrastructureSystems.SupplementalAttributeAssociations, InfrastructureSystems.SupplementalAttribute}","page":"API","title":"InfrastructureSystems.has_association","text":"has_association(\n    associations::InfrastructureSystems.SupplementalAttributeAssociations,\n    attribute::InfrastructureSystems.SupplementalAttribute\n) -> Bool\n\n\nReturn true if there is at least one association matching the inputs.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.has_component-Tuple{InfrastructureSystems.Components, Type{<:InfrastructureSystems.InfrastructureSystemsComponent}, AbstractString}","page":"API","title":"InfrastructureSystems.has_component","text":"has_component(\n    components::InfrastructureSystems.Components,\n    T::Type{<:InfrastructureSystems.InfrastructureSystemsComponent},\n    name::AbstractString\n) -> Bool\n\n\nCheck to see if a component with name exists.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.has_component-Tuple{InfrastructureSystems.SystemData, AbstractString, InfrastructureSystems.InfrastructureSystemsComponent}","page":"API","title":"InfrastructureSystems.has_component","text":"has_component(\n    data::InfrastructureSystems.SystemData,\n    subsystem_name::AbstractString,\n    component::InfrastructureSystems.InfrastructureSystemsComponent\n) -> Bool\n\n\nReturn true if the component is in the subsystem.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.has_component-Tuple{InfrastructureSystems.SystemData, Type{<:InfrastructureSystems.InfrastructureSystemsComponent}, AbstractString}","page":"API","title":"InfrastructureSystems.has_component","text":"has_component(\n    data::InfrastructureSystems.SystemData,\n    T::Type{<:InfrastructureSystems.InfrastructureSystemsComponent},\n    name::AbstractString\n) -> Bool\n\n\nCheck to see if a component exists.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.has_components-Tuple{InfrastructureSystems.Components, Type{<:InfrastructureSystems.InfrastructureSystemsComponent}}","page":"API","title":"InfrastructureSystems.has_components","text":"has_components(\n    components::InfrastructureSystems.Components,\n    T::Type{<:InfrastructureSystems.InfrastructureSystemsComponent}\n) -> Bool\n\n\nCheck to see if a component if the given type exists.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.has_metadata-Tuple{InfrastructureSystems.TimeSeriesMetadataStore, Base.UUID}","page":"API","title":"InfrastructureSystems.has_metadata","text":"has_metadata(\n    store::InfrastructureSystems.TimeSeriesMetadataStore,\n    time_series_uuid::Base.UUID\n) -> Bool\n\n\nReturn True if there is time series matching the UUID.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.has_supplemental_attributes-Tuple{InfrastructureSystems.InfrastructureSystemsComponent}","page":"API","title":"InfrastructureSystems.has_supplemental_attributes","text":"has_supplemental_attributes(\n    component::InfrastructureSystems.InfrastructureSystemsComponent\n) -> Bool\n\n\nReturn true if the component has supplemental attributes.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.has_supplemental_attributes-Union{Tuple{T}, Tuple{InfrastructureSystems.InfrastructureSystemsComponent, Type{T}}} where T<:InfrastructureSystems.SupplementalAttribute","page":"API","title":"InfrastructureSystems.has_supplemental_attributes","text":"has_supplemental_attributes(\n    component::InfrastructureSystems.InfrastructureSystemsComponent,\n    _::Type{T<:InfrastructureSystems.SupplementalAttribute}\n) -> Bool\n\n\nReturn true if the component has supplemental attributes of the given type.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.has_time_series-Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}}","page":"API","title":"InfrastructureSystems.has_time_series","text":"has_time_series(\n    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute};\n    kwargs...\n) -> Bool\n\n\nReturn true if the component or supplemental attribute has time series data.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.has_time_series-Union{Tuple{T}, Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}, Type{T}}} where T<:InfrastructureSystems.TimeSeriesData","page":"API","title":"InfrastructureSystems.has_time_series","text":"has_time_series(\n    val::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute},\n    _::Type{T<:InfrastructureSystems.TimeSeriesData}\n) -> Bool\n\n\nReturn true if the component or supplemental attribute has time series data of type T.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.hash_from_fields-Tuple{Any}","page":"API","title":"InfrastructureSystems.hash_from_fields","text":"hash_from_fields(a) -> Any\n\n\nCompute a hash of the instance a by combining hashes of all its fields\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.head-Tuple{InfrastructureSystems.SingleTimeSeries}","page":"API","title":"InfrastructureSystems.head","text":"head(\n    time_series::InfrastructureSystems.SingleTimeSeries\n) -> Any\n\n\nReturn a time_series with only the first num values.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.increment_count!-Tuple{InfrastructureSystems.LogEventTracker, InfrastructureSystems.LogEvent, Bool}","page":"API","title":"InfrastructureSystems.increment_count!","text":"increment_count!(\n    tracker::InfrastructureSystems.LogEventTracker,\n    event::InfrastructureSystems.LogEvent,\n    suppressed::Bool\n) -> Union{Nothing, Int64, InfrastructureSystems.LogEvent}\n\n\nIncrements the count of a log event.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.index_to_initial_time-Tuple{InfrastructureSystems.Forecast, Int64}","page":"API","title":"InfrastructureSystems.index_to_initial_time","text":"index_to_initial_time(\n    forecast::InfrastructureSystems.Forecast,\n    index::Int64\n) -> Any\n\n\nReturn the Dates.DateTime corresponding to an interval index.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.is_assigned_to_subsystem-Tuple{InfrastructureSystems.SystemData, InfrastructureSystems.InfrastructureSystemsComponent, AbstractString}","page":"API","title":"InfrastructureSystems.is_assigned_to_subsystem","text":"is_assigned_to_subsystem(\n    data::InfrastructureSystems.SystemData,\n    component::InfrastructureSystems.InfrastructureSystemsComponent,\n    subsystem_name::AbstractString\n) -> Bool\n\n\nReturn true if the component is assigned to the subsystem.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.is_assigned_to_subsystem-Tuple{InfrastructureSystems.SystemData, InfrastructureSystems.InfrastructureSystemsComponent}","page":"API","title":"InfrastructureSystems.is_assigned_to_subsystem","text":"is_assigned_to_subsystem(\n    data::InfrastructureSystems.SystemData,\n    component::InfrastructureSystems.InfrastructureSystemsComponent\n) -> Bool\n\n\nReturn true if the component is assigned to any subsystems.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.is_concave-Tuple{InfrastructureSystems.InputOutputCurve}","page":"API","title":"InfrastructureSystems.is_concave","text":"is_concave(\n    curve::InfrastructureSystems.InputOutputCurve\n) -> Bool\n\n\nis_concave(curve::ValueCurve) -> Bool\n\nCheck if a ValueCurve is concave.\n\nInputOutputCurve (including LinearCurve, QuadraticCurve, PiecewisePointCurve):  Delegates to concavity check of the underlying FunctionData.\nIncrementalCurve (including PiecewiseIncrementalCurve): Delegates to concavity check  of the underlying FunctionData. This works because for IncrementalCurve, the  FunctionData y-coordinates represent marginal rates (slopes), so checking if they are  non-increasing is equivalent to checking concavity of the original curve.\nAverageRateCurve (including PiecewiseAverageCurve): Converts to InputOutputCurve  first, then checks. This is necessary because average rates are NOT the same as slopes;  non-increasing average rates do not imply concavity.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.is_concave-Tuple{InfrastructureSystems.LinearFunctionData}","page":"API","title":"InfrastructureSystems.is_concave","text":"is_concave(\n    _::InfrastructureSystems.LinearFunctionData\n) -> Bool\n\n\nis_concave(data::FunctionData) -> Bool\n\nReturns true if the function data is concave, false otherwise. Linear functions (straight lines) are considered concave.\n\nLinearFunctionData: Always returns true\nQuadraticFunctionData: Returns true if quadratic_term â‰¤ 0\nPiecewiseLinearData: Returns true if slopes are non-increasing\nPiecewiseStepData: Returns true if y-coordinates are non-increasing\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.is_concave-Tuple{InfrastructureSystems.ProductionVariableCostCurve}","page":"API","title":"InfrastructureSystems.is_concave","text":"is_concave(\n    cost::InfrastructureSystems.ProductionVariableCostCurve\n) -> Any\n\n\nCalculate the concavity of the underlying data\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.is_convex-Tuple{InfrastructureSystems.InputOutputCurve}","page":"API","title":"InfrastructureSystems.is_convex","text":"is_convex(\n    curve::InfrastructureSystems.InputOutputCurve\n) -> Bool\n\n\nis_convex(curve::ValueCurve) -> Bool\n\nCheck if a ValueCurve is convex.\n\nInputOutputCurve (including LinearCurve, QuadraticCurve, PiecewisePointCurve):  Delegates to convexity check of the underlying FunctionData.\nIncrementalCurve (including PiecewiseIncrementalCurve): Delegates to convexity check  of the underlying FunctionData. This works because for IncrementalCurve, the  FunctionData y-coordinates represent marginal rates (slopes), so checking if they are  non-decreasing is equivalent to checking convexity of the original curve.\nAverageRateCurve (including PiecewiseAverageCurve): Converts to InputOutputCurve  first, then checks. This is necessary because average rates are NOT the same as slopes;  non-decreasing average rates do not imply convexity.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.is_convex-Tuple{InfrastructureSystems.LinearFunctionData}","page":"API","title":"InfrastructureSystems.is_convex","text":"is_convex(\n    _::InfrastructureSystems.LinearFunctionData\n) -> Bool\n\n\nis_convex(data::FunctionData) -> Bool\n\nReturns true if the function data is convex, false otherwise. Linear functions (straight lines) are considered convex.\n\nLinearFunctionData: Always returns true\nQuadraticFunctionData: Returns true if quadratic_term â‰¥ 0\nPiecewiseLinearData: Returns true if slopes are non-decreasing\nPiecewiseStepData: Returns true if y-coordinates are non-decreasing\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.is_convex-Tuple{InfrastructureSystems.ProductionVariableCostCurve}","page":"API","title":"InfrastructureSystems.is_convex","text":"is_convex(\n    cost::InfrastructureSystems.ProductionVariableCostCurve\n) -> Any\n\n\nCalculate the convexity of the underlying data\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.is_cost_alias-Tuple{Union{Type{<:InfrastructureSystems.ValueCurve}, InfrastructureSystems.ValueCurve}}","page":"API","title":"InfrastructureSystems.is_cost_alias","text":"is_cost_alias(\n    _::Union{Type{<:InfrastructureSystems.ValueCurve}, InfrastructureSystems.ValueCurve}\n) -> Bool\n\n\nWhether there is a cost alias for the instance or type under consideration\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.is_ext_valid_for_serialization-Tuple{Any}","page":"API","title":"InfrastructureSystems.is_ext_valid_for_serialization","text":"is_ext_valid_for_serialization(value) -> Bool\n\n\nPerform a test to see if JSON3 can convert this value so that the code can give the user a a comprehensible corrective action.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.is_strictly_decreasing","page":"API","title":"InfrastructureSystems.is_strictly_decreasing","text":"is_strictly_decreasing(data::FunctionData) -> Bool\nis_strictly_decreasing(curve::ValueCurve) -> Bool\n\nReturns true if all slopes are non-positive (<= 0 within tolerance), false otherwise.\n\nFunctionData types\n\nDefined for:\n\nLinearFunctionData: true iff proportional term <= 0\nPiecewiseLinearData: true iff all segment slopes <= 0\nPiecewiseStepData: true iff all marginal rates <= 0\n\nNot defined for QuadraticFunctionData (slope varies with x).\n\nValueCurve types\n\nDefined for:\n\nInputOutputCurve: delegates to underlying FunctionData\nIncrementalCurve: delegates to underlying FunctionData (y-coords are slopes)\nAverageRateCurve: converts to InputOutputCurve first (average rates â‰  slopes)\n\n\n\n\n\n","category":"function"},{"location":"InfrastructureSystems/#InfrastructureSystems.is_strictly_increasing","page":"API","title":"InfrastructureSystems.is_strictly_increasing","text":"is_strictly_increasing(data::FunctionData) -> Bool\nis_strictly_increasing(curve::ValueCurve) -> Bool\n\nReturns true if all slopes are non-negative (>= 0 within tolerance), false otherwise.\n\nFunctionData types\n\nDefined for:\n\nLinearFunctionData: true iff proportional term >= 0\nPiecewiseLinearData: true iff all segment slopes >= 0\nPiecewiseStepData: true iff all marginal rates >= 0\n\nNot defined for QuadraticFunctionData (slope varies with x).\n\nValueCurve types\n\nDefined for:\n\nInputOutputCurve: delegates to underlying FunctionData\nIncrementalCurve: delegates to underlying FunctionData (y-coords are slopes)\nAverageRateCurve: converts to InputOutputCurve first (average rates â‰  slopes)\n\n\n\n\n\n","category":"function"},{"location":"InfrastructureSystems/#InfrastructureSystems.is_transform_array_for_hdf_supported-Union{Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"API","title":"InfrastructureSystems.is_transform_array_for_hdf_supported","text":"is_transform_array_for_hdf_supported(\n    _::Type{T<:Real}\n) -> Bool\n\n\nCheck if the element type T is supported by transformarrayfor_hdf. Returns true if supported, false otherwise. Uses multiple dispatch for a more Julian approach.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.is_valid_data","page":"API","title":"InfrastructureSystems.is_valid_data","text":"is_valid_data(data::FunctionData) -> Bool\nis_valid_data(curve::ValueCurve) -> Bool\n\nCheck if the function data or curve is valid and suitable for convexification. Returns true if data is valid, false otherwise.\n\nThis validation should be called before attempting to convexify curves, as some data is not just non-convex but fundamentally wrong (e.g., unrealistic or inconsistent values).\n\nWhen validation fails, an error is logged with details about the specific issue.\n\nQuality Checks\n\nX-coordinates ordering: Must be strictly ascending\nExcessive slopes: Unreasonably large slopes (in absolute value) may indicate unit conversion errors\nNegative costs: Production costs should generally be non-negative\nExcessive magnitudes: Very large values may indicate wrong units or data errors\n\nNote: Slope sign is NOT checked here. Use is_strictly_increasing or is_strictly_decreasing to validate slope direction when needed.\n\n\n\n\n\n","category":"function"},{"location":"InfrastructureSystems/#InfrastructureSystems.is_valid_data-Tuple{InfrastructureSystems.InputOutputCurve}","page":"API","title":"InfrastructureSystems.is_valid_data","text":"is_valid_data(\n    curve::InfrastructureSystems.InputOutputCurve\n) -> Bool\n\n\nis_valid_data(curve::ValueCurve) -> Bool\n\nCheck if a ValueCurve has valid data suitable for convexification.\n\nFor InputOutputCurve and IncrementalCurve, delegates to the underlying FunctionData check. For AverageRateCurve, converts to InputOutputCurve first since average rates are NOT  the same as slopes - the actual slopes must be validated.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.isequal_from_fields-Union{Tuple{T}, Tuple{T, T}} where T","page":"API","title":"InfrastructureSystems.isequal_from_fields","text":"isequal_from_fields(a, b) -> Any\n\n\nCompute the conjunction of the isequal values of all the fields in a and b\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.isequivalent-Tuple{Any, Any}","page":"API","title":"InfrastructureSystems.isequivalent","text":"isequivalent(x, y) -> Any\n\n\nAn equality predicate that is true for NaN, NaN (unlike ==) and for -0.0, 0.0 (unlike isequal)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.isotonic_regression-Tuple{Vector{Float64}, Vector{Float64}}","page":"API","title":"InfrastructureSystems.isotonic_regression","text":"isotonic_regression(\n    values::Vector{Float64},\n    weights::Vector{Float64}\n) -> Vector{Float64}\n\n\nisotonic_regression(values::Vector{Float64}, weights::Vector{Float64}) -> Vector{Float64}\n\nPool Adjacent Violators Algorithm (PAVA) for weighted isotonic regression. Returns the closest (weighted L2) non-decreasing sequence to values.\n\nThis is an O(n) algorithm that finds the optimal monotonically non-decreasing approximation to the input values.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.iterate_components-Tuple{InfrastructureSystems.Components}","page":"API","title":"InfrastructureSystems.iterate_components","text":"iterate_components(\n    components::InfrastructureSystems.Components\n) -> InfrastructureSystems.FlattenIteratorWrapper{InfrastructureSystems.InfrastructureSystemsComponent, I} where I<:(Vector)\n\n\nIterates over all components.\n\nExamples\n\nfor component in iterate_components(obj)\n    @show component\nend\n\nSee also: get_components\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.iterate_container-Tuple{InfrastructureSystems.InfrastructureSystemsContainer}","page":"API","title":"InfrastructureSystems.iterate_container","text":"iterate_container(\n    container::InfrastructureSystems.InfrastructureSystemsContainer\n) -> InfrastructureSystems.FlattenIteratorWrapper{InfrastructureSystems.InfrastructureSystemsComponent, I} where I<:(Vector)\n\n\nIterates over all data in the container.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.iterate_supplemental_attributes-Tuple{InfrastructureSystems.SupplementalAttributeManager}","page":"API","title":"InfrastructureSystems.iterate_supplemental_attributes","text":"iterate_supplemental_attributes(\n    mgr::InfrastructureSystems.SupplementalAttributeManager\n) -> Base.Iterators.Flatten{Base.Generator{Base.ValueIterator{Dict{DataType, Dict{Base.UUID, <:InfrastructureSystems.SupplementalAttribute}}}, InfrastructureSystems.var\"#iterate_container##0#iterate_container##1\"}}\n\n\nIterates over all supplemental_attributes.\n\nExamples\n\nfor supplemental_attribute in iterate_supplemental_attributes(obj)\n    @show supplemental_attribute\nend\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.iterate_windows-Tuple{InfrastructureSystems.DeterministicSingleTimeSeries}","page":"API","title":"InfrastructureSystems.iterate_windows","text":"iterate_windows(\n    forecast::InfrastructureSystems.DeterministicSingleTimeSeries\n) -> Union{Tuple{Any}, Base.Generator{I, InfrastructureSystems.var\"#iterate_windows##0#iterate_windows##1\"{InfrastructureSystems.DeterministicSingleTimeSeries}} where I<:(StepRangeLen{T, R, S, Int64} where {T, R>:Dates.DateTime, S})}\n\n\nIterate over the windows in a forecast\n\nExamples\n\nfor window in iterate_windows(forecast)\n    @show values(maximum(window))\nend\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.iterate_windows-Tuple{InfrastructureSystems.Deterministic}","page":"API","title":"InfrastructureSystems.iterate_windows","text":"iterate_windows(\n    forecast::InfrastructureSystems.Deterministic\n) -> Base.Generator{I, InfrastructureSystems.var\"#iterate_windows_common##0#iterate_windows_common##1\"{InfrastructureSystems.Deterministic}} where I<:(DataStructures.IterableObject{C, DataStructures.EntireContainer, DataStructures.KeysIter, DataStructures.NoTokens, DataStructures.ForwardIter} where C<:(DataStructures.SortedDict{K, D, Ord} where {Ord<:Base.Order.Ordering, D, K}))\n\n\nIterate over the windows in a forecast\n\nExamples\n\nfor window in iterate_windows(forecast)\n    @show values(maximum(window))\nend\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.iterate_windows-Tuple{InfrastructureSystems.Probabilistic}","page":"API","title":"InfrastructureSystems.iterate_windows","text":"iterate_windows(\n    forecast::InfrastructureSystems.Probabilistic\n) -> Base.Generator{I, InfrastructureSystems.var\"#iterate_windows_common##0#iterate_windows_common##1\"{InfrastructureSystems.Probabilistic}} where I<:(DataStructures.IterableObject{C, DataStructures.EntireContainer, DataStructures.KeysIter, DataStructures.NoTokens, DataStructures.ForwardIter} where C<:(DataStructures.SortedDict{K, D, Ord} where {Ord<:Base.Order.Ordering, D, K}))\n\n\nIterate over the windows in a forecast\n\nExamples\n\nfor window in iterate_windows(forecast)\n    @show values(maximum(window))\nend\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.iterate_windows-Tuple{InfrastructureSystems.Scenarios}","page":"API","title":"InfrastructureSystems.iterate_windows","text":"iterate_windows(\n    forecast::InfrastructureSystems.Scenarios\n) -> Base.Generator{I, InfrastructureSystems.var\"#iterate_windows_common##0#iterate_windows_common##1\"{InfrastructureSystems.Scenarios}} where I<:(DataStructures.IterableObject{C, DataStructures.EntireContainer, DataStructures.KeysIter, DataStructures.NoTokens, DataStructures.ForwardIter} where C<:(DataStructures.SortedDict{K, D, Ord} where {Ord<:Base.Order.Ordering, D, K}))\n\n\nIterate over the windows in a forecast\n\nExamples\n\nfor window in iterate_windows(forecast)\n    @show values(maximum(window))\nend\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.list_associated_component_uuids-Tuple{InfrastructureSystems.SupplementalAttributeAssociations, InfrastructureSystems.SupplementalAttribute, Nothing}","page":"API","title":"InfrastructureSystems.list_associated_component_uuids","text":"list_associated_component_uuids(\n    associations::InfrastructureSystems.SupplementalAttributeAssociations,\n    attribute::InfrastructureSystems.SupplementalAttribute,\n    _::Nothing\n) -> Any\n\n\nReturn the distinct component UUIDs associated with the attribute.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.list_associated_component_uuids-Tuple{InfrastructureSystems.SupplementalAttributeAssociations, InfrastructureSystems.SupplementalAttribute, Type{<:InfrastructureSystems.InfrastructureSystemsComponent}}","page":"API","title":"InfrastructureSystems.list_associated_component_uuids","text":"list_associated_component_uuids(\n    associations::InfrastructureSystems.SupplementalAttributeAssociations,\n    attribute::InfrastructureSystems.SupplementalAttribute,\n    component_type::Type{<:InfrastructureSystems.InfrastructureSystemsComponent}\n) -> Any\n\n\nReturn the distinct component UUIDs associated with the attribute, filter by component type.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.list_associated_component_uuids-Tuple{InfrastructureSystems.SupplementalAttributeAssociations, Type{<:InfrastructureSystems.SupplementalAttribute}, Nothing}","page":"API","title":"InfrastructureSystems.list_associated_component_uuids","text":"list_associated_component_uuids(\n    associations::InfrastructureSystems.SupplementalAttributeAssociations,\n    attribute_type::Type{<:InfrastructureSystems.SupplementalAttribute},\n    _::Nothing\n) -> Any\n\n\nReturn the distinct component UUIDs associated with the attribute type.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.list_associated_component_uuids-Tuple{InfrastructureSystems.SupplementalAttributeAssociations, Type{<:InfrastructureSystems.SupplementalAttribute}, Type{<:InfrastructureSystems.InfrastructureSystemsComponent}}","page":"API","title":"InfrastructureSystems.list_associated_component_uuids","text":"list_associated_component_uuids(\n    associations::InfrastructureSystems.SupplementalAttributeAssociations,\n    attribute_type::Type{<:InfrastructureSystems.SupplementalAttribute},\n    component_type::Type{<:InfrastructureSystems.InfrastructureSystemsComponent}\n) -> Any\n\n\nReturn the distinct component UUIDs associated with the attribute type, filter by component_type.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.list_associated_pair_uuids-Tuple{InfrastructureSystems.SupplementalAttributeAssociations, Type{<:InfrastructureSystems.SupplementalAttribute}, Type{<:InfrastructureSystems.InfrastructureSystemsComponent}}","page":"API","title":"InfrastructureSystems.list_associated_pair_uuids","text":"list_associated_pair_uuids(\n    associations::InfrastructureSystems.SupplementalAttributeAssociations,\n    attribute_type::Type{<:InfrastructureSystems.SupplementalAttribute},\n    component_type::Type{<:InfrastructureSystems.InfrastructureSystemsComponent}\n) -> Vector\n\n\nReturn the component and attribute UUIDs that are associated with the given types.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.list_associated_supplemental_attribute_uuids-Tuple{InfrastructureSystems.SupplementalAttributeAssociations, InfrastructureSystems.InfrastructureSystemsComponent, Nothing}","page":"API","title":"InfrastructureSystems.list_associated_supplemental_attribute_uuids","text":"list_associated_supplemental_attribute_uuids(\n    associations::InfrastructureSystems.SupplementalAttributeAssociations,\n    component::InfrastructureSystems.InfrastructureSystemsComponent,\n    _::Nothing\n) -> Any\n\n\nReturn the distinct attribute UUIDs associated with the component.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.list_associated_supplemental_attribute_uuids-Tuple{InfrastructureSystems.SupplementalAttributeAssociations, InfrastructureSystems.InfrastructureSystemsComponent, Type{<:InfrastructureSystems.SupplementalAttribute}}","page":"API","title":"InfrastructureSystems.list_associated_supplemental_attribute_uuids","text":"list_associated_supplemental_attribute_uuids(\n    associations::InfrastructureSystems.SupplementalAttributeAssociations,\n    component::InfrastructureSystems.InfrastructureSystemsComponent,\n    attribute_type::Type{<:InfrastructureSystems.SupplementalAttribute}\n) -> Any\n\n\nReturn the distinct attribute UUIDs associated with the component, filter by attribute type.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.list_associated_supplemental_attribute_uuids-Tuple{InfrastructureSystems.SupplementalAttributeAssociations, Type{<:InfrastructureSystems.InfrastructureSystemsComponent}, Nothing}","page":"API","title":"InfrastructureSystems.list_associated_supplemental_attribute_uuids","text":"list_associated_supplemental_attribute_uuids(\n    associations::InfrastructureSystems.SupplementalAttributeAssociations,\n    component_type::Type{<:InfrastructureSystems.InfrastructureSystemsComponent},\n    _::Nothing\n) -> Any\n\n\nReturn the distinct attribute UUIDs associated with the component type.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.list_associated_supplemental_attribute_uuids-Tuple{InfrastructureSystems.SupplementalAttributeAssociations, Type{<:InfrastructureSystems.InfrastructureSystemsComponent}, Type{<:InfrastructureSystems.SupplementalAttribute}}","page":"API","title":"InfrastructureSystems.list_associated_supplemental_attribute_uuids","text":"list_associated_supplemental_attribute_uuids(\n    associations::InfrastructureSystems.SupplementalAttributeAssociations,\n    component_type::Type{<:InfrastructureSystems.InfrastructureSystemsComponent},\n    attribute_type::Type{<:InfrastructureSystems.SupplementalAttribute}\n) -> Any\n\n\nReturn the distinct attribute UUIDs associated with the component type, filter by attribute_type.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.list_existing_time_series_uuids-Tuple{InfrastructureSystems.TimeSeriesMetadataStore, Any}","page":"API","title":"InfrastructureSystems.list_existing_time_series_uuids","text":"list_existing_time_series_uuids(\n    store::InfrastructureSystems.TimeSeriesMetadataStore,\n    uuids\n) -> Any\n\n\nReturn the time series UUIDs specified in the passed uuids that are already stored.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.list_matching_time_series_uuids-Tuple{InfrastructureSystems.TimeSeriesMetadataStore}","page":"API","title":"InfrastructureSystems.list_matching_time_series_uuids","text":"list_matching_time_series_uuids(\n    store::InfrastructureSystems.TimeSeriesMetadataStore;\n    time_series_type,\n    name,\n    resolution,\n    features...\n) -> Any\n\n\nReturn the time series UUIDs that match the inputs.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.list_metadata_with_owner_uuid-Tuple{InfrastructureSystems.TimeSeriesMetadataStore, Type{<:Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}}}","page":"API","title":"InfrastructureSystems.list_metadata_with_owner_uuid","text":"list_metadata_with_owner_uuid(\n    store::InfrastructureSystems.TimeSeriesMetadataStore,\n    owner_type::Type{<:Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}};\n    time_series_type,\n    name,\n    resolution,\n    features...\n) -> Vector\n\n\nReturn a Vector of NamedTuple of owner UUID and time series metadata matching the inputs.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.list_recorder_events-Union{Tuple{T}, Tuple{Type{T}, AbstractString}, Tuple{Type{T}, AbstractString, Union{Nothing, Function}}} where T<:InfrastructureSystems.AbstractRecorderEvent","page":"API","title":"InfrastructureSystems.list_recorder_events","text":"list_recorder_events(\n    ::Type{T<:InfrastructureSystems.AbstractRecorderEvent},\n    filename::AbstractString\n) -> Vector{T} where T<:InfrastructureSystems.AbstractRecorderEvent\nlist_recorder_events(\n    ::Type{T<:InfrastructureSystems.AbstractRecorderEvent},\n    filename::AbstractString,\n    filter_func::Union{Nothing, Function}\n) -> Vector{T} where T<:InfrastructureSystems.AbstractRecorderEvent\n\n\nReturn the events of type T in filename.\n\nArguments\n\nT: event type\nfilename::AbstractString: filename containing recorder events\nfilter_func::Union{Nothing, Function} = nothing: Optional function that accepts an event of type T and returns a Bool. Apply this function to each event and only return events where the result is true.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.make_convex_approximation","page":"API","title":"InfrastructureSystems.make_convex_approximation","text":"make_convex_approximation(curve::ValueCurve; kwargs...) -> Union{ValueCurve, Nothing}\n\nTransform a ValueCurve into a convex form, with data quality validation.\n\nThis function first validates that the curve data is reasonable and physically meaningful using is_valid_data. If the data has fundamental quality issues (negative slopes,  excessive values, unordered coordinates, etc.), the function logs an error and returns  nothing to trigger a fallback path.\n\nIf the data passes validation and is already convex, returns the original curve  (optionally with colinear segments merged).\n\nIf the data passes validation but is non-convex, applies isotonic regression to  produce a convex approximation.\n\nSupported curve types\n\nInputOutputCurve{PiecewiseLinearData}: Isotonic regression on slopes\nIncrementalCurve{PiecewiseStepData}: Converts to IO curve, makes convex, converts back\nAverageRateCurve{PiecewiseStepData}: Converts to IO curve, makes convex, converts back\n\nNote 1: IncrementalCurve{LinearFunctionData} and AverageRateCurve{LinearFunctionData} are intentionally NOT supported. These represent derivatives of quadratic functions and rarely appear in real data. The arbitrary projection approach used for quadratics is not appropriate. Note 2: InputOutputCurve{LinearFunctionData} is not supported because it never presents convexity issues.  Note 3: InputOutputCurve{QuadraticFunctionData} is not supported given that it represents a significant change on the curve\n\nKeyword Arguments\n\nweights::Symbol: Weighting scheme for isotonic regression (affects how violations are resolved)\n:length (default): weight segments by x-extent (wider segments have more influence)\n:uniform: all segments equally weighted\nanchor: Point preservation strategy for reconstructing points from new slopes\n:first (default): preserve first point, propagate forward\n:last: preserve last point, propagate backward\n:centroid: minimize total vertical displacement\nmerge_colinear: Whether to merge colinear segments before convexification (default: true)\nColinear segments are those where consecutive slopes differ by less than a tolerance\nThis cleanup step removes artificial segmentation that can cause false non-convex detections\n\nReturns\n\nThe convex curve (original or approximation) if successful\nnothing if data quality validation fails\n\n\n\n\n\n","category":"function"},{"location":"InfrastructureSystems/#InfrastructureSystems.make_convex_approximation-Tuple{InfrastructureSystems.CostCurve}","page":"API","title":"InfrastructureSystems.make_convex_approximation","text":"make_convex_approximation(\n    cost::InfrastructureSystems.CostCurve;\n    kwargs...\n) -> Union{Nothing, InfrastructureSystems.CostCurve}\n\n\nmake_convex_approximation(cost::CostCurve; kwargs...) -> Union{CostCurve, Nothing}\n\nTransform the underlying ValueCurve of a CostCurve into a convex approximation. Returns a new CostCurve with the convexified value curve, preserving power_units and vom_cost. Returns nothing if data quality validation fails.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.make_convex_approximation-Tuple{InfrastructureSystems.FuelCurve}","page":"API","title":"InfrastructureSystems.make_convex_approximation","text":"make_convex_approximation(\n    cost::InfrastructureSystems.FuelCurve;\n    kwargs...\n) -> Union{Nothing, InfrastructureSystems.FuelCurve}\n\n\nmake_convex_approximation(cost::FuelCurve; kwargs...) -> Union{FuelCurve, Nothing}\n\nTransform the underlying ValueCurve of a FuelCurve into a convex approximation. Returns a new FuelCurve with the convexified value curve, preserving all other fields. Returns nothing if data quality validation fails.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.make_convex_approximation-Tuple{PiecewiseAverageCurve}","page":"API","title":"InfrastructureSystems.make_convex_approximation","text":"make_convex_approximation(\n    curve::PiecewiseAverageCurve;\n    weights,\n    anchor,\n    merge_colinear,\n    generator_name\n) -> Union{Nothing, PiecewiseAverageCurve}\n\n\nmakeconvexapproximation(curve::AverageRateCurve{PiecewiseStepData}; kwargs...) -> Union{AverageRateCurve{PiecewiseStepData}, Nothing}\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.make_convex_approximation-Tuple{PiecewiseIncrementalCurve}","page":"API","title":"InfrastructureSystems.make_convex_approximation","text":"make_convex_approximation(\n    curve::PiecewiseIncrementalCurve;\n    weights,\n    anchor,\n    merge_colinear,\n    generator_name\n) -> Union{Nothing, PiecewiseIncrementalCurve}\n\n\nmake_convex_approximation(curve::IncrementalCurve{PiecewiseStepData}; kwargs...) -> Union{IncrementalCurve{PiecewiseStepData}, Nothing}\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.make_convex_approximation-Tuple{PiecewisePointCurve}","page":"API","title":"InfrastructureSystems.make_convex_approximation","text":"make_convex_approximation(\n    curve::PiecewisePointCurve;\n    weights,\n    anchor,\n    merge_colinear,\n    generator_name,\n    _skip_validation\n) -> Union{Nothing, PiecewisePointCurve}\n\n\nmakeconvexapproximation(curve::InputOutputCurve{PiecewiseLinearData}; kwargs...) -> Union{InputOutputCurve{PiecewiseLinearData}, Nothing}\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.make_selector","page":"API","title":"InfrastructureSystems.make_selector","text":"Factory function to create the appropriate subtype of ComponentSelector given the arguments. Users should call this rather than manually constructing ComponentSelectors.\n\nArguments\n\nSeveral methods of this function have a parameter groupby::Union{Symbol, Function}, which specifies how the selector is grouped for the purposes of get_groups. The groupby argument has the following semantics:\n\ngroupby = :each (default): each component that makes up the selector forms its own group. The number of groups from get_groups will be equal to the number of components from get_components.\ngroupby = :all: all components that make up the selector are put into the same group. get_groups will yield one group.\ngroupby = partition_function: if the argument is a user-supplied function, the function will be applied to each component; all components with the same result under the function will be grouped together, with the name of the group specified by the function's output.\n\nOther arguments are documented on a per-method basis.\n\nExamples\n\nSee the methods.\n\n\n\n\n\n","category":"function"},{"location":"InfrastructureSystems/#InfrastructureSystems.make_selector-Tuple{Function, Type{<:InfrastructureSystems.InfrastructureSystemsComponent}}","page":"API","title":"InfrastructureSystems.make_selector","text":"make_selector(\n    filter_func::Function,\n    component_type::Type{<:InfrastructureSystems.InfrastructureSystemsComponent};\n    name,\n    groupby\n) -> InfrastructureSystems.FilterComponentSelector\n\n\nMake a ComponentSelector from a filter function and a type of component. The filter function must accept instances of component_type as a sole argument and return a Bool. Optionally provide a grouping behavior and/or name for the selector. Selectors constructed this way point to all the components of the given type that satisfy the filter function, grouped by the groupby argument (see the base make_selector documentation).\n\nArguments\n\nfilter_func::Function: the filter function to apply to components\ncomponent_type::Type{<:InfrastructureSystemsComponent}: the type of component to select\ngroupby::Union{Symbol, Function} = :each: the grouping behavior (see the base make_selector documentation)\nname::Union{String, Nothing} = nothing: the name of the selector; if not provided, one will be constructed automatically\n\nExamples\n\nsel1 = make_selector(RenewableDispatch, x -> get_prime_mover_type(x) == PrimeMovers.PVe)\nsel2 = make_selector(RenewableDispatch, x -> get_prime_mover_type(x) == PrimeMovers.PVe; groupby = :all)\nsel3 = make_selector(RenewableDispatch, x -> get_prime_mover_type(x) == PrimeMovers.PVe; name = \"my_selector\")\n\nSee also: make_selector unified function documentation\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.make_selector-Tuple{InfrastructureSystems.InfrastructureSystemsComponent}","page":"API","title":"InfrastructureSystems.make_selector","text":"make_selector(\n    component::InfrastructureSystems.InfrastructureSystemsComponent;\n    name\n) -> InfrastructureSystems.NameComponentSelector\n\n\nMake a ComponentSelector from a component, pointing to a single component with the same type and name as the one given. Optionally provide a name for the selector. Selectors constructed this way contain exactly one group, which contains one component if the target component exists and zero if it doesn't.\n\nArguments\n\ncomponent::InfrastructureSystemsComponent: the component whose type and name specify the target of this selector\nname::Union{String, Nothing} = nothing: the name of the selector; if not provided, one will be constructed automatically\n\nExamples\n\nsel1 = make_selector(my_component)\nsel2 = make_selector(my_component; name = \"my_selector\")\n\nSee also: make_selector unified function documentation\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.make_selector-Tuple{Type{<:InfrastructureSystems.InfrastructureSystemsComponent}, AbstractString}","page":"API","title":"InfrastructureSystems.make_selector","text":"make_selector(\n    component_type::Type{<:InfrastructureSystems.InfrastructureSystemsComponent},\n    component_name::AbstractString;\n    name\n) -> InfrastructureSystems.NameComponentSelector\n\n\nMake a ComponentSelector pointing to a single component with the given type and name. Optionally provide a name for the selector. Selectors constructed this way contain exactly one group, which contains one component if the target component exists and zero if it doesn't.\n\nArguments\n\ncomponent_type::Type{<:InfrastructureSystemsComponent}: the type of the target component\ncomponent_name::AbstractString: the name of the target component\nname::Union{String, Nothing} = nothing: the name of the selector; if not provided, one will be constructed automatically\n\nExamples\n\nsel1 = make_selector(ThermalStandard, \"322_CT_6\")\nsel2 = make_selector(ThermalStandard, \"322_CT_6\"; name = \"my_selector\")\n\nSee also: make_selector unified function documentation\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.make_selector-Tuple{Type{<:InfrastructureSystems.InfrastructureSystemsComponent}}","page":"API","title":"InfrastructureSystems.make_selector","text":"make_selector(\n    component_type::Type{<:InfrastructureSystems.InfrastructureSystemsComponent};\n    groupby,\n    name\n) -> InfrastructureSystems.TypeComponentSelector\n\n\nMake a ComponentSelector from a type of component. Optionally provide a grouping behavior and/or name for the selector. Selectors constructed this way point to all the components of the given type, grouped by the groupby argument (see the base make_selector documentation).\n\nArguments\n\ncomponent_type::Type{<:InfrastructureSystemsComponent}: the type of component to select\ngroupby::Union{Symbol, Function} = :each: the grouping behavior (see the base make_selector documentation)\nname::Union{String, Nothing} = nothing: the name of the selector; if not provided, one will be constructed automatically\n\nExamples\n\nsel1 = make_selector(RenewableDispatch)\nsel2 = make_selector(RenewableDispatch; groupby = :all)\nsel3 = make_selector(RenewableDispatch; name = \"my_selector\")\n\nSee also: make_selector unified function documentation\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.make_selector-Tuple{Vararg{InfrastructureSystems.ComponentSelector}}","page":"API","title":"InfrastructureSystems.make_selector","text":"make_selector(\n    content::InfrastructureSystems.ComponentSelector...;\n    name\n) -> InfrastructureSystems.ListComponentSelector\n\n\nMake a ComponentSelector from several existing ComponentSelectors. Optionally provide a name for the selector. Selectors constructed this way contain one group for each of the selectors they were constructed with.\n\nArguments\n\ncontent::ComponentSelector...: the list of selectors that should form the groups\nname::Union{String, Nothing} = nothing: the name of the selector; if not provided, one will be constructed automatically\n\nExamples\n\nsel1 = make_selector(make_selector(ThermalStandard), make_selector(RenewableDispatch))\nsel2 = make_selector(make_selector(ThermalStandard), make_selector(RenewableDispatch); name = \"my_selector\")\n\nSee also: make_selector unified function documentation\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.make_time_array-Tuple{InfrastructureSystems.Forecast, Dates.DateTime}","page":"API","title":"InfrastructureSystems.make_time_array","text":"make_time_array(\n    forecast::InfrastructureSystems.Forecast,\n    start_time::Dates.DateTime;\n    len\n) -> Any\n\n\nReturn a TimeSeries.TimeArray for one forecast window.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.make_time_series!-Tuple{InfrastructureSystems.TimeSeriesParsingCache, InfrastructureSystems.TimeSeriesFileMetadata}","page":"API","title":"InfrastructureSystems.make_time_series!","text":"make_time_series!(\n    cache::InfrastructureSystems.TimeSeriesParsingCache,\n    ts_file_metadata::InfrastructureSystems.TimeSeriesFileMetadata\n) -> Any\n\n\nReturn a time series from TimeSeriesFileMetadata.\n\nArguments\n\ncache::TimeSeriesParsingCache: cached data\nts_file_metadata::TimeSeriesFileMetadata: metadata\nresolution::{Nothing, Dates.Period}: skip any time_series that don't match this resolution\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.mask_component!-Tuple{InfrastructureSystems.SystemData, InfrastructureSystems.InfrastructureSystemsComponent}","page":"API","title":"InfrastructureSystems.mask_component!","text":"mask_component!(\n    data::InfrastructureSystems.SystemData,\n    component::InfrastructureSystems.InfrastructureSystemsComponent;\n    remove_time_series,\n    remove_supplemental_attributes\n)\n\n\nRemoves the component from the main container and adds it to the masked container.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.merge_colinear_segments","page":"API","title":"InfrastructureSystems.merge_colinear_segments","text":"merge_colinear_segments(curve::ValueCurve; Îµ::Float64 = _COLINEARITY_TOLERANCE) -> ValueCurve\n\nMerge consecutive colinear segments in a piecewise curve.\n\nColinear segments are identified by grouping: starting from the first segment in a group, all subsequent segments whose slope differs from the group's first slope by less than Îµ are merged. This cleanup step removes artificial segmentation that can cause false non-convex detections, unnecessary curve complexity, and unstable numerical behavior.\n\nArguments\n\ncurve: A piecewise ValueCurve to clean up\nÎµ: Tolerance for comparing slopes (default: 1.0e-6)\n\nReturns\n\nA new curve with colinear segments merged. Endpoints are preserved exactly. Returns the original curve unchanged if no colinear segments are found.\n\nSupported curve types\n\nPiecewisePointCurve (InputOutputCurve{PiecewiseLinearData})\nPiecewiseIncrementalCurve (IncrementalCurve{PiecewiseStepData})\nPiecewiseAverageCurve (AverageRateCurve{PiecewiseStepData})\n\n\n\n\n\n","category":"function"},{"location":"InfrastructureSystems/#InfrastructureSystems.merge_colinear_segments-Tuple{PiecewiseAverageCurve}","page":"API","title":"InfrastructureSystems.merge_colinear_segments","text":"merge_colinear_segments(\n    curve::PiecewiseAverageCurve;\n    Îµ\n) -> PiecewiseAverageCurve\n\n\nmerge_colinear_segments(curve::PiecewiseAverageCurve; Îµ) -> PiecewiseAverageCurve\n\nMerge colinear segments in a PiecewiseAverageCurve (AverageRateCurve{PiecewiseStepData}).\n\nFor step data, average rates are directly stored as y-coordinates. Consecutive steps with y-values within tolerance Îµ are merged.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.merge_colinear_segments-Tuple{PiecewiseIncrementalCurve}","page":"API","title":"InfrastructureSystems.merge_colinear_segments","text":"merge_colinear_segments(\n    curve::PiecewiseIncrementalCurve;\n    Îµ\n) -> PiecewiseIncrementalCurve\n\n\nmerge_colinear_segments(curve::PiecewiseIncrementalCurve; Îµ) -> PiecewiseIncrementalCurve\n\nMerge colinear segments in a PiecewiseIncrementalCurve (IncrementalCurve{PiecewiseStepData}).\n\nFor step data, slopes are directly stored as y-coordinates. Consecutive steps with y-values within tolerance Îµ are merged.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.merge_colinear_segments-Tuple{PiecewisePointCurve}","page":"API","title":"InfrastructureSystems.merge_colinear_segments","text":"merge_colinear_segments(\n    curve::PiecewisePointCurve;\n    Îµ\n) -> PiecewisePointCurve\n\n\nmerge_colinear_segments(curve::PiecewisePointCurve; Îµ) -> PiecewisePointCurve\n\nMerge colinear segments in a PiecewisePointCurve (InputOutputCurve{PiecewiseLinearData}).\n\nAlgorithm:\n\nCompute slopes between consecutive points\nIdentify groups of consecutive segments with slopes within tolerance Îµ\nFor each colinear group, keep only the first and last points\nPreserve first and last endpoints exactly\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.open_file_logger","page":"API","title":"InfrastructureSystems.open_file_logger","text":"open_file_logger(func::Function, filename::String) -> Any\nopen_file_logger(\n    func::Function,\n    filename::String,\n    level\n) -> Any\nopen_file_logger(\n    func::Function,\n    filename::String,\n    level,\n    mode\n) -> Any\n\n\nOpens a file logger using Logging.SimpleLogger.\n\nArguments\n\nfunc::Function\nfilename::String: logger filename\nlevel=Logging.Info: optional, to change the minimum logging level\nmode = \"w+\": Optional, to designate write mode\n\nExample\n\nopen_file_logger(\"log.txt\", Logging.Info) do logger\n    global_logger(logger)\n    @info \"hello world\"\nend\n\n\n\n\n\n","category":"function"},{"location":"InfrastructureSystems/#InfrastructureSystems.optimize_database!-Tuple{InfrastructureSystems.SupplementalAttributeAssociations}","page":"API","title":"InfrastructureSystems.optimize_database!","text":"optimize_database!(\n    associations::InfrastructureSystems.SupplementalAttributeAssociations\n)\n\n\nUpdate database statistics for optimal query planning. Call this after bulk operations or significant data changes.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.optimize_database!-Tuple{InfrastructureSystems.TimeSeriesMetadataStore}","page":"API","title":"InfrastructureSystems.optimize_database!","text":"optimize_database!(\n    store::InfrastructureSystems.TimeSeriesMetadataStore\n)\n\n\nUpdate database statistics for optimal query planning. Call this after bulk operations or significant data changes.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.optional_and_fns-Tuple{Function, Function}","page":"API","title":"InfrastructureSystems.optional_and_fns","text":"optional_and_fns(\n    fn1::Function,\n    fn2::Function\n) -> InfrastructureSystems.var\"#optional_and_fns##0#optional_and_fns##1\"{<:Function, <:Function}\n\n\nReturn a function that computes the conjunction of the two functions with short-circuit evaluation, where if either of the functions is nothing it is as if its result is true.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.prepare_for_removal!-Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}}","page":"API","title":"InfrastructureSystems.prepare_for_removal!","text":"prepare_for_removal!(\n    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}\n)\n\n\nThis function must be called when a component or attribute is removed from a system.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.prepare_for_serialization_to_file!-Tuple{InfrastructureSystems.SystemData, AbstractString}","page":"API","title":"InfrastructureSystems.prepare_for_serialization_to_file!","text":"prepare_for_serialization_to_file!(\n    data::InfrastructureSystems.SystemData,\n    filename::AbstractString;\n    force\n)\n\n\nParent object should call this prior to serialization so that SystemData can store the appropriate path information for the time series data.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.read_time_series-Union{Tuple{T}, Tuple{Type{T}, AbstractString}, Tuple{Type{T}, AbstractString, Any}} where T<:InfrastructureSystems.TimeSeriesData","page":"API","title":"InfrastructureSystems.read_time_series","text":"read_time_series(\n    ::Type{T<:InfrastructureSystems.TimeSeriesData},\n    data_file::AbstractString;\n    ...\n) -> InfrastructureSystems.RawTimeSeries\nread_time_series(\n    ::Type{T<:InfrastructureSystems.TimeSeriesData},\n    data_file::AbstractString,\n    component_name;\n    kwargs...\n) -> Any\n\n\nReturn a TimeArray from a CSV file.\n\nPass component_name when the file does not have the component name in a column header.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.read_time_series-Union{Tuple{T}, Tuple{Type{T}, Type{<:InfrastructureSystems.StaticTimeSeries}, CSV.File, AbstractString}} where T<:InfrastructureSystems.TimeSeriesFormatPeriodAsHeader","page":"API","title":"InfrastructureSystems.read_time_series","text":"read_time_series(\n    ::Type{T<:InfrastructureSystems.TimeSeriesFormatPeriodAsHeader},\n    ::Type{<:InfrastructureSystems.StaticTimeSeries},\n    file::CSV.File,\n    component_name::AbstractString;\n    kwargs...\n) -> InfrastructureSystems.RawTimeSeries\n\n\nThis version of the function supports the format where there is no column header for a component, so the component_name must be passed in.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.read_time_series-Union{Tuple{T}, Tuple{Type{T}, Type{<:InfrastructureSystems.StaticTimeSeries}, CSV.File}, Tuple{Type{T}, Type{<:InfrastructureSystems.StaticTimeSeries}, CSV.File, Any}} where T<:InfrastructureSystems.TimeSeriesFormatComponentsAsColumnsNoTime","page":"API","title":"InfrastructureSystems.read_time_series","text":"read_time_series(\n    ::Type{T<:InfrastructureSystems.TimeSeriesFormatComponentsAsColumnsNoTime},\n    ::Type{<:InfrastructureSystems.StaticTimeSeries},\n    file::CSV.File;\n    ...\n) -> InfrastructureSystems.RawTimeSeries\nread_time_series(\n    ::Type{T<:InfrastructureSystems.TimeSeriesFormatComponentsAsColumnsNoTime},\n    ::Type{<:InfrastructureSystems.StaticTimeSeries},\n    file::CSV.File,\n    component_name;\n    kwargs...\n) -> InfrastructureSystems.RawTimeSeries\n\n\nThis version of the function only has component_name to match the interface. It is unused.\n\nSet start_datetime as a keyword argument for the starting timestamp, otherwise the current day is used.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.read_time_series-Union{Tuple{T}, Tuple{Type{T}, Type{<:InfrastructureSystems.StaticTimeSeries}, CSV.File}, Tuple{Type{T}, Type{<:InfrastructureSystems.StaticTimeSeries}, CSV.File, Any}} where T<:Union{InfrastructureSystems.TimeSeriesFormatDateTimeAsColumn, InfrastructureSystems.TimeSeriesFormatPeriodAsColumn}","page":"API","title":"InfrastructureSystems.read_time_series","text":"read_time_series(\n    ::Type{T<:Union{InfrastructureSystems.TimeSeriesFormatDateTimeAsColumn, InfrastructureSystems.TimeSeriesFormatPeriodAsColumn}},\n    ::Type{<:InfrastructureSystems.StaticTimeSeries},\n    file::CSV.File;\n    ...\n) -> InfrastructureSystems.RawTimeSeries\nread_time_series(\n    ::Type{T<:Union{InfrastructureSystems.TimeSeriesFormatDateTimeAsColumn, InfrastructureSystems.TimeSeriesFormatPeriodAsColumn}},\n    ::Type{<:InfrastructureSystems.StaticTimeSeries},\n    file::CSV.File,\n    component_name;\n    kwargs...\n) -> InfrastructureSystems.RawTimeSeries\n\n\nReturn a TimeSeries.TimeArray representing the CSV file.\n\nThis version of the function only has component_name to match the interface. It is unused.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.read_time_series-Union{Tuple{T}, Tuple{Type{T}, Type{InfrastructureSystems.Deterministic}, CSV.File}, Tuple{Type{T}, Type{InfrastructureSystems.Deterministic}, CSV.File, Any}} where T<:InfrastructureSystems.TimeSeriesFormatDateTimeAsColumn","page":"API","title":"InfrastructureSystems.read_time_series","text":"read_time_series(\n    ::Type{T<:InfrastructureSystems.TimeSeriesFormatDateTimeAsColumn},\n    ::Type{InfrastructureSystems.Deterministic},\n    file::CSV.File;\n    ...\n) -> InfrastructureSystems.RawTimeSeries\nread_time_series(\n    ::Type{T<:InfrastructureSystems.TimeSeriesFormatDateTimeAsColumn},\n    ::Type{InfrastructureSystems.Deterministic},\n    file::CSV.File,\n    component_name;\n    kwargs...\n) -> InfrastructureSystems.RawTimeSeries\n\n\nReturn a RawTimeSeries from a CSV file.\n\nPass component_name when the file does not have the component name in a column header.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.read_time_series_file_metadata-Tuple{AbstractString}","page":"API","title":"InfrastructureSystems.read_time_series_file_metadata","text":"read_time_series_file_metadata(\n    file_path::AbstractString\n) -> Any\n\n\nReads time_series metadata and fixes relative paths to the data files.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.rebuild_selector-Tuple{InfrastructureSystems.ListComponentSelector}","page":"API","title":"InfrastructureSystems.rebuild_selector","text":"rebuild_selector(\n    selector::InfrastructureSystems.ListComponentSelector;\n    name,\n    groupby\n) -> InfrastructureSystems.ListComponentSelector\n\n\nReturns a ComponentSelector functionally identical to the input selector except with the changes to its fields specified in the keyword arguments. It is not guaranteed that the result will have the same concrete type.\n\nExamples\n\nSuppose you have a selector with manual groups and you want to group by :each:\n\nsel = make_selector(make_selector(ThermalStandard), make_selector(RenewableDispatch))\nsel_each = rebuild_selector(sel; groupby = :each)  # will be a RegroupedComponentSelector\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.rebuild_selector-Tuple{T} where T<:InfrastructureSystems.ComponentSelector","page":"API","title":"InfrastructureSystems.rebuild_selector","text":"rebuild_selector(\n    selector::InfrastructureSystems.ComponentSelector;\n    name\n) -> InfrastructureSystems.ListComponentSelector\n\n\nReturns a ComponentSelector functionally identical to the input selector except with the changes to its fields specified in the keyword arguments.\n\nExamples\n\nSuppose you have a selector with name = \"my_name. If you instead wanted name = \"your_name:\n\nsel = make_selector(ThermalStandard, \"322_CT_6\"; name = \"my_name\")\nsel_yours = rebuild_selector(sel; name = \"your_name\")\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.rebuild_selector-Tuple{T} where T<:InfrastructureSystems.DynamicallyGroupedComponentSelector","page":"API","title":"InfrastructureSystems.rebuild_selector","text":"rebuild_selector(\n    selector::InfrastructureSystems.DynamicallyGroupedComponentSelector;\n    name,\n    groupby\n) -> Any\n\n\nReturns a ComponentSelector functionally identical to the input selector except with the changes to its fields specified in the keyword arguments.\n\nExamples\n\nSuppose you have a selector with groupby = :all. If you instead wanted groupby = :each:\n\nsel = make_selector(ThermalStandard; groupby = :all)\nsel_each = rebuild_selector(sel; groupby = :each)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.redirect_stdout_to_log-Tuple{Function}","page":"API","title":"InfrastructureSystems.redirect_stdout_to_log","text":"redirect_stdout_to_log(func::Function) -> Any\n\n\nRedirect all data written to stdout by a function to log events.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.register_recorder!-Tuple{Symbol}","page":"API","title":"InfrastructureSystems.register_recorder!","text":"register_recorder!(name::Symbol; io, mode, directory)\n\n\nRegister a recorder to log events. Afterwards, calls to @record name <event-type>() will record the event as JSON in <name>.log.\n\nCallers should guarantee that unregister_recorder! is called to close the file handle.\n\nArguments\n\nname::Symbol: name of recorder\nio::Union{Nothing, IO}:  If nothing, record events in a file using name.\nmode = \"w\":  Only used when io is nothing.\ndirectory = \".\":  Only used when io is nothing.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.remove_association!-Tuple{InfrastructureSystems.SupplementalAttributeAssociations, InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}","page":"API","title":"InfrastructureSystems.remove_association!","text":"remove_association!(\n    associations::InfrastructureSystems.SupplementalAttributeAssociations,\n    component::InfrastructureSystems.InfrastructureSystemsComponent,\n    attribute::InfrastructureSystems.SupplementalAttribute\n)\n\n\nRemove the association between the attribute and component.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.remove_associations!-Tuple{InfrastructureSystems.SupplementalAttributeAssociations, Type{<:InfrastructureSystems.SupplementalAttribute}}","page":"API","title":"InfrastructureSystems.remove_associations!","text":"remove_associations!(\n    associations::InfrastructureSystems.SupplementalAttributeAssociations,\n    type::Type{<:InfrastructureSystems.SupplementalAttribute}\n)\n\n\nRemove all associations of the given type.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.remove_component!-Union{Tuple{T}, Tuple{InfrastructureSystems.Components, T}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.remove_component!","text":"remove_component!(\n    components::InfrastructureSystems.Components,\n    component::InfrastructureSystems.InfrastructureSystemsComponent;\n    remove_time_series,\n    remove_supplemental_attributes\n) -> InfrastructureSystems.InfrastructureSystemsComponent\n\n\nRemove a component by its value.\n\nThrows ArgumentError if the component is not stored.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.remove_component!-Union{Tuple{T}, Tuple{Type{T}, InfrastructureSystems.Components, AbstractString}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.remove_component!","text":"remove_component!(\n    ::Type{T<:InfrastructureSystems.InfrastructureSystemsComponent},\n    components::InfrastructureSystems.Components,\n    name::AbstractString;\n    remove_time_series,\n    remove_supplemental_attributes\n) -> InfrastructureSystems.InfrastructureSystemsComponent\n\n\nRemove a component by its name.\n\nThrows ArgumentError if the component is not stored.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.remove_component_from_subsystem!-Tuple{InfrastructureSystems.SystemData, AbstractString, InfrastructureSystems.InfrastructureSystemsComponent}","page":"API","title":"InfrastructureSystems.remove_component_from_subsystem!","text":"remove_component_from_subsystem!(\n    data::InfrastructureSystems.SystemData,\n    subsystem_name::AbstractString,\n    component::InfrastructureSystems.InfrastructureSystemsComponent\n)\n\n\nRemove a component from a subsystem.\n\nThrows ArgumentError if the subsystem name or component is not stored.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.remove_components!-Union{Tuple{T}, Tuple{Type{T}, InfrastructureSystems.Components}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.remove_components!","text":"remove_components!(\n    _::Type{T<:InfrastructureSystems.InfrastructureSystemsComponent},\n    components::InfrastructureSystems.Components\n) -> Base.ValueIterator{T} where T<:(Dict{String, <:InfrastructureSystems.InfrastructureSystemsComponent})\n\n\nRemove all components of type T.\n\nThrows ArgumentError if the type is not stored.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.remove_metadata!-Tuple{InfrastructureSystems.TimeSeriesMetadataStore, Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}, InfrastructureSystems.TimeSeriesMetadata}","page":"API","title":"InfrastructureSystems.remove_metadata!","text":"remove_metadata!(\n    store::InfrastructureSystems.TimeSeriesMetadataStore,\n    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute},\n    metadata::InfrastructureSystems.TimeSeriesMetadata\n) -> Union{Nothing, InfrastructureSystems.TimeSeriesMetadata}\n\n\nRemove the matching metadata from the store.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.remove_subsystem!-Tuple{InfrastructureSystems.SystemData, AbstractString}","page":"API","title":"InfrastructureSystems.remove_subsystem!","text":"remove_subsystem!(\n    data::InfrastructureSystems.SystemData,\n    subsystem_name::AbstractString\n)\n\n\nRemove a subsystem from the system.\n\nThrows ArgumentError if the subsystem name is not stored.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.remove_supplemental_attributes!-Union{Tuple{T}, Tuple{InfrastructureSystems.SupplementalAttributeManager, Type{T}}} where T<:InfrastructureSystems.SupplementalAttribute","page":"API","title":"InfrastructureSystems.remove_supplemental_attributes!","text":"remove_supplemental_attributes!(\n    mgr::InfrastructureSystems.SupplementalAttributeManager,\n    _::Type{T<:InfrastructureSystems.SupplementalAttribute}\n) -> Base.ValueIterator{T} where T<:(Dict{Base.UUID, <:InfrastructureSystems.SupplementalAttribute})\n\n\nRemove all supplemental_attributes of type T.\n\nIgnores whether attributes are attached to components.\n\nThrows ArgumentError if the type is not stored.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.remove_time_series!-Tuple{InfrastructureSystems.TimeSeriesManager, Type{<:InfrastructureSystems.TimeSeriesData}, Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}, String}","page":"API","title":"InfrastructureSystems.remove_time_series!","text":"remove_time_series!(\n    mgr::InfrastructureSystems.TimeSeriesManager,\n    time_series_type::Type{<:InfrastructureSystems.TimeSeriesData},\n    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute},\n    name::String;\n    resolution,\n    features...\n)\n\n\nRemove the time series data for a component.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.remove_time_series!-Union{Tuple{T}, Tuple{InfrastructureSystems.SystemData, Type{T}, Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}, String}} where T<:InfrastructureSystems.TimeSeriesData","page":"API","title":"InfrastructureSystems.remove_time_series!","text":"remove_time_series!(\n    data::InfrastructureSystems.SystemData,\n    ::Type{T<:InfrastructureSystems.TimeSeriesData},\n    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute},\n    name::String;\n    resolution,\n    features...\n)\n\n\nRemove the time series data for a component.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.remove_time_series!-Union{Tuple{T}, Tuple{InfrastructureSystems.SystemData, Type{T}}} where T<:InfrastructureSystems.TimeSeriesData","page":"API","title":"InfrastructureSystems.remove_time_series!","text":"remove_time_series!(\n    data::InfrastructureSystems.SystemData,\n    ::Type{T<:InfrastructureSystems.TimeSeriesData};\n    resolution\n)\n\n\nRemoves all time series of a particular type from a System.\n\nArguments\n\ndata::SystemData: system\ntype::Type{<:TimeSeriesData}: Type of time series objects to remove.\nresolution::Union{Nothing, Dates.Period} = nothing: Only remove time series with this resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.replace_component_uuid!-Tuple{InfrastructureSystems.SupplementalAttributeAssociations, Base.UUID, Base.UUID}","page":"API","title":"InfrastructureSystems.replace_component_uuid!","text":"replace_component_uuid!(\n    associations::InfrastructureSystems.SupplementalAttributeAssociations,\n    old_uuid::Base.UUID,\n    new_uuid::Base.UUID\n)\n\n\nReplace the component UUID in the table.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.replace_iterator-Tuple{InfrastructureSystems.LazyDictFromIterator, Any}","page":"API","title":"InfrastructureSystems.replace_iterator","text":"replace_iterator(\n    container::InfrastructureSystems.LazyDictFromIterator,\n    iter\n)\n\n\nReplace the iterator, maintaining the cached dict.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.report_log_summary-Tuple{InfrastructureSystems.LogEventTracker}","page":"API","title":"InfrastructureSystems.report_log_summary","text":"report_log_summary(\n    tracker::InfrastructureSystems.LogEventTracker\n) -> String\n\n\nReturns a summary of log event counts by level.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.report_log_summary-Tuple{InfrastructureSystems.MultiLogger}","page":"API","title":"InfrastructureSystems.report_log_summary","text":"report_log_summary(\n    logger::InfrastructureSystems.MultiLogger\n) -> String\n\n\nReturns a summary of log event counts by level.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.reset!-Tuple{InfrastructureSystems.TimeSeriesCache}","page":"API","title":"InfrastructureSystems.reset!","text":"reset!(cache::InfrastructureSystems.TimeSeriesCache)\n\n\nReset parameters in order to start reading data from the beginning with get_next_time_series_array!\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.reset_iterator-Tuple{InfrastructureSystems.LazyDictFromIterator}","page":"API","title":"InfrastructureSystems.reset_iterator","text":"reset_iterator(\n    container::InfrastructureSystems.LazyDictFromIterator\n)\n\n\nReset the iterator for cases where underlying arrays have changed.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.serialize-Tuple{T} where T<:InfrastructureSystems.InfrastructureSystemsType","page":"API","title":"InfrastructureSystems.serialize","text":"serialize(\n    val::InfrastructureSystems.InfrastructureSystemsType\n) -> Vector{Dict{String, Any}}\n\n\nSerialize the Julia value into standard types that can be converted to non-Julia formats, such as JSON. In cases where val is an instance of a struct, return a Dict. In cases where val is a scalar value, return that value.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_available!-Tuple{InfrastructureSystems.InfrastructureSystemsComponent}","page":"API","title":"InfrastructureSystems.set_available!","text":"set_available!(\n    value::InfrastructureSystems.InfrastructureSystemsComponent\n) -> Bool\n\n\nSet the availability of the component.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_component!-Tuple{InfrastructureSystems.TimeSeriesFileMetadata, InfrastructureSystems.SystemData, Module}","page":"API","title":"InfrastructureSystems.set_component!","text":"set_component!(\n    metadata::InfrastructureSystems.TimeSeriesFileMetadata,\n    data::InfrastructureSystems.SystemData,\n    mod::Module\n) -> Union{Nothing, InfrastructureSystems.InfrastructureSystemsComponent}\n\n\nSet the component value in metadata by looking up the category in module. This requires that category be a string version of a component's abstract type. Modules can override for custom behavior.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_count!-Tuple{InfrastructureSystems.DeterministicMetadata, Any}","page":"API","title":"InfrastructureSystems.set_count!","text":"set_count!(\n    value::InfrastructureSystems.DeterministicMetadata,\n    val\n) -> Any\n\n\nSet DeterministicMetadata count.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_count!-Tuple{InfrastructureSystems.DeterministicSingleTimeSeries, Any}","page":"API","title":"InfrastructureSystems.set_count!","text":"set_count!(\n    value::InfrastructureSystems.DeterministicSingleTimeSeries,\n    val\n) -> Any\n\n\nSet DeterministicSingleTimeSeries count.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_count!-Tuple{InfrastructureSystems.ProbabilisticMetadata, Any}","page":"API","title":"InfrastructureSystems.set_count!","text":"set_count!(\n    value::InfrastructureSystems.ProbabilisticMetadata,\n    val\n) -> Any\n\n\nSet ProbabilisticMetadata count.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_count!-Tuple{InfrastructureSystems.ScenariosMetadata, Any}","page":"API","title":"InfrastructureSystems.set_count!","text":"set_count!(\n    value::InfrastructureSystems.ScenariosMetadata,\n    val\n) -> Any\n\n\nSet ScenariosMetadata count.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_data!-Tuple{InfrastructureSystems.Deterministic, Any}","page":"API","title":"InfrastructureSystems.set_data!","text":"set_data!(\n    value::InfrastructureSystems.Deterministic,\n    val\n) -> Any\n\n\nSet Deterministic data.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_data!-Tuple{InfrastructureSystems.Probabilistic, Any}","page":"API","title":"InfrastructureSystems.set_data!","text":"set_data!(\n    value::InfrastructureSystems.Probabilistic,\n    val\n) -> Any\n\n\nSet Probabilistic data.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_data!-Tuple{InfrastructureSystems.Scenarios, Any}","page":"API","title":"InfrastructureSystems.set_data!","text":"set_data!(\n    value::InfrastructureSystems.Scenarios,\n    val\n) -> Any\n\n\nSet Scenarios data.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_data!-Tuple{InfrastructureSystems.SingleTimeSeries, Any}","page":"API","title":"InfrastructureSystems.set_data!","text":"set_data!(\n    value::InfrastructureSystems.SingleTimeSeries,\n    val\n) -> Any\n\n\nSet SingleTimeSeries data.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_features!-Tuple{InfrastructureSystems.DeterministicMetadata, Any}","page":"API","title":"InfrastructureSystems.set_features!","text":"set_features!(\n    value::InfrastructureSystems.DeterministicMetadata,\n    val\n) -> Any\n\n\nSet DeterministicMetadata features.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_features!-Tuple{InfrastructureSystems.ProbabilisticMetadata, Any}","page":"API","title":"InfrastructureSystems.set_features!","text":"set_features!(\n    value::InfrastructureSystems.ProbabilisticMetadata,\n    val\n) -> Any\n\n\nSet ProbabilisticMetadata features.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_features!-Tuple{InfrastructureSystems.ScenariosMetadata, Any}","page":"API","title":"InfrastructureSystems.set_features!","text":"set_features!(\n    value::InfrastructureSystems.ScenariosMetadata,\n    val\n) -> Any\n\n\nSet ScenariosMetadata features.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_features!-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata, Any}","page":"API","title":"InfrastructureSystems.set_features!","text":"set_features!(\n    value::InfrastructureSystems.SingleTimeSeriesMetadata,\n    val\n) -> Any\n\n\nSet SingleTimeSeriesMetadata features.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_group_level!-Tuple{InfrastructureSystems.MultiLogger, Symbol, Base.CoreLogging.LogLevel}","page":"API","title":"InfrastructureSystems.set_group_level!","text":"set_group_level!(\n    logger::InfrastructureSystems.MultiLogger,\n    group::Symbol,\n    level::Base.CoreLogging.LogLevel\n)\n\n\nSet the minimum log level for a group.\n\nThe group field of a log message defaults to its file's base name (no extension) as a symbol. It can be customized by setting _group = :a_group_name.\n\nThe minimum log level stored for a console or file logger supercede this setting.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_group_levels!-Tuple{InfrastructureSystems.MultiLogger, Dict{Symbol, Base.CoreLogging.LogLevel}}","page":"API","title":"InfrastructureSystems.set_group_levels!","text":"set_group_levels!(\n    logger::InfrastructureSystems.MultiLogger,\n    group_levels::Dict{Symbol, Base.CoreLogging.LogLevel}\n)\n\n\nSet the minimum log levels for multiple groups. Refer to set_group_level! for more information.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_horizon!-Tuple{InfrastructureSystems.DeterministicMetadata, Any}","page":"API","title":"InfrastructureSystems.set_horizon!","text":"set_horizon!(\n    value::InfrastructureSystems.DeterministicMetadata,\n    val\n) -> Any\n\n\nSet DeterministicMetadata horizon.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_horizon!-Tuple{InfrastructureSystems.DeterministicSingleTimeSeries, Any}","page":"API","title":"InfrastructureSystems.set_horizon!","text":"set_horizon!(\n    value::InfrastructureSystems.DeterministicSingleTimeSeries,\n    val\n) -> Any\n\n\nSet DeterministicSingleTimeSeries horizon.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_horizon!-Tuple{InfrastructureSystems.ProbabilisticMetadata, Any}","page":"API","title":"InfrastructureSystems.set_horizon!","text":"set_horizon!(\n    value::InfrastructureSystems.ProbabilisticMetadata,\n    val\n) -> Any\n\n\nSet ProbabilisticMetadata horizon.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_horizon!-Tuple{InfrastructureSystems.ScenariosMetadata, Any}","page":"API","title":"InfrastructureSystems.set_horizon!","text":"set_horizon!(\n    value::InfrastructureSystems.ScenariosMetadata,\n    val\n) -> Any\n\n\nSet ScenariosMetadata horizon.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_initial_timestamp!-Tuple{InfrastructureSystems.DeterministicMetadata, Any}","page":"API","title":"InfrastructureSystems.set_initial_timestamp!","text":"set_initial_timestamp!(\n    value::InfrastructureSystems.DeterministicMetadata,\n    val\n) -> Any\n\n\nSet DeterministicMetadata initial_timestamp.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_initial_timestamp!-Tuple{InfrastructureSystems.DeterministicSingleTimeSeries, Any}","page":"API","title":"InfrastructureSystems.set_initial_timestamp!","text":"set_initial_timestamp!(\n    value::InfrastructureSystems.DeterministicSingleTimeSeries,\n    val\n) -> Any\n\n\nSet DeterministicSingleTimeSeries initial_timestamp.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_initial_timestamp!-Tuple{InfrastructureSystems.ProbabilisticMetadata, Any}","page":"API","title":"InfrastructureSystems.set_initial_timestamp!","text":"set_initial_timestamp!(\n    value::InfrastructureSystems.ProbabilisticMetadata,\n    val\n) -> Any\n\n\nSet ProbabilisticMetadata initial_timestamp.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_initial_timestamp!-Tuple{InfrastructureSystems.ScenariosMetadata, Any}","page":"API","title":"InfrastructureSystems.set_initial_timestamp!","text":"set_initial_timestamp!(\n    value::InfrastructureSystems.ScenariosMetadata,\n    val\n) -> Any\n\n\nSet ScenariosMetadata initial_timestamp.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_initial_timestamp!-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata, Any}","page":"API","title":"InfrastructureSystems.set_initial_timestamp!","text":"set_initial_timestamp!(\n    value::InfrastructureSystems.SingleTimeSeriesMetadata,\n    val\n) -> Any\n\n\nSet SingleTimeSeriesMetadata initial_timestamp.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_internal!-Tuple{InfrastructureSystems.Deterministic, Any}","page":"API","title":"InfrastructureSystems.set_internal!","text":"set_internal!(\n    value::InfrastructureSystems.Deterministic,\n    val\n) -> Any\n\n\nSet Deterministic internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_internal!-Tuple{InfrastructureSystems.DeterministicMetadata, Any}","page":"API","title":"InfrastructureSystems.set_internal!","text":"set_internal!(\n    value::InfrastructureSystems.DeterministicMetadata,\n    val\n) -> Any\n\n\nSet DeterministicMetadata internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_internal!-Tuple{InfrastructureSystems.Probabilistic, Any}","page":"API","title":"InfrastructureSystems.set_internal!","text":"set_internal!(\n    value::InfrastructureSystems.Probabilistic,\n    val\n) -> Any\n\n\nSet Probabilistic internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_internal!-Tuple{InfrastructureSystems.ProbabilisticMetadata, Any}","page":"API","title":"InfrastructureSystems.set_internal!","text":"set_internal!(\n    value::InfrastructureSystems.ProbabilisticMetadata,\n    val\n) -> Any\n\n\nSet ProbabilisticMetadata internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_internal!-Tuple{InfrastructureSystems.Scenarios, Any}","page":"API","title":"InfrastructureSystems.set_internal!","text":"set_internal!(\n    value::InfrastructureSystems.Scenarios,\n    val\n) -> Any\n\n\nSet Scenarios internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_internal!-Tuple{InfrastructureSystems.ScenariosMetadata, Any}","page":"API","title":"InfrastructureSystems.set_internal!","text":"set_internal!(\n    value::InfrastructureSystems.ScenariosMetadata,\n    val\n) -> Any\n\n\nSet ScenariosMetadata internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_internal!-Tuple{InfrastructureSystems.SingleTimeSeries, Any}","page":"API","title":"InfrastructureSystems.set_internal!","text":"set_internal!(\n    value::InfrastructureSystems.SingleTimeSeries,\n    val\n) -> Any\n\n\nSet SingleTimeSeries internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_internal!-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata, Any}","page":"API","title":"InfrastructureSystems.set_internal!","text":"set_internal!(\n    value::InfrastructureSystems.SingleTimeSeriesMetadata,\n    val\n) -> Any\n\n\nSet SingleTimeSeriesMetadata internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_interval!-Tuple{InfrastructureSystems.DeterministicMetadata, Any}","page":"API","title":"InfrastructureSystems.set_interval!","text":"set_interval!(\n    value::InfrastructureSystems.DeterministicMetadata,\n    val\n) -> Any\n\n\nSet DeterministicMetadata interval.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_interval!-Tuple{InfrastructureSystems.DeterministicSingleTimeSeries, Any}","page":"API","title":"InfrastructureSystems.set_interval!","text":"set_interval!(\n    value::InfrastructureSystems.DeterministicSingleTimeSeries,\n    val\n) -> Any\n\n\nSet DeterministicSingleTimeSeries interval.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_interval!-Tuple{InfrastructureSystems.ProbabilisticMetadata, Any}","page":"API","title":"InfrastructureSystems.set_interval!","text":"set_interval!(\n    value::InfrastructureSystems.ProbabilisticMetadata,\n    val\n) -> Any\n\n\nSet ProbabilisticMetadata interval.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_interval!-Tuple{InfrastructureSystems.ScenariosMetadata, Any}","page":"API","title":"InfrastructureSystems.set_interval!","text":"set_interval!(\n    value::InfrastructureSystems.ScenariosMetadata,\n    val\n) -> Any\n\n\nSet ScenariosMetadata interval.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_length!-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata, Any}","page":"API","title":"InfrastructureSystems.set_length!","text":"set_length!(\n    value::InfrastructureSystems.SingleTimeSeriesMetadata,\n    val\n) -> Any\n\n\nSet SingleTimeSeriesMetadata length.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_name!-Tuple{InfrastructureSystems.Deterministic, Any}","page":"API","title":"InfrastructureSystems.set_name!","text":"set_name!(\n    value::InfrastructureSystems.Deterministic,\n    val\n) -> Any\n\n\nSet Deterministic name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_name!-Tuple{InfrastructureSystems.DeterministicMetadata, Any}","page":"API","title":"InfrastructureSystems.set_name!","text":"set_name!(\n    value::InfrastructureSystems.DeterministicMetadata,\n    val\n) -> Any\n\n\nSet DeterministicMetadata name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_name!-Tuple{InfrastructureSystems.Probabilistic, Any}","page":"API","title":"InfrastructureSystems.set_name!","text":"set_name!(\n    value::InfrastructureSystems.Probabilistic,\n    val\n) -> Any\n\n\nSet Probabilistic name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_name!-Tuple{InfrastructureSystems.ProbabilisticMetadata, Any}","page":"API","title":"InfrastructureSystems.set_name!","text":"set_name!(\n    value::InfrastructureSystems.ProbabilisticMetadata,\n    val\n) -> Any\n\n\nSet ProbabilisticMetadata name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_name!-Tuple{InfrastructureSystems.Scenarios, Any}","page":"API","title":"InfrastructureSystems.set_name!","text":"set_name!(\n    value::InfrastructureSystems.Scenarios,\n    val\n) -> Any\n\n\nSet Scenarios name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_name!-Tuple{InfrastructureSystems.ScenariosMetadata, Any}","page":"API","title":"InfrastructureSystems.set_name!","text":"set_name!(\n    value::InfrastructureSystems.ScenariosMetadata,\n    val\n) -> Any\n\n\nSet ScenariosMetadata name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_name!-Tuple{InfrastructureSystems.SingleTimeSeries, Any}","page":"API","title":"InfrastructureSystems.set_name!","text":"set_name!(\n    value::InfrastructureSystems.SingleTimeSeries,\n    val\n) -> Any\n\n\nSet SingleTimeSeries name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_name!-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata, Any}","page":"API","title":"InfrastructureSystems.set_name!","text":"set_name!(\n    value::InfrastructureSystems.SingleTimeSeriesMetadata,\n    val\n) -> Any\n\n\nSet SingleTimeSeriesMetadata name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_name_internal!-Tuple{InfrastructureSystems.InfrastructureSystemsComponent, Any}","page":"API","title":"InfrastructureSystems.set_name_internal!","text":"set_name_internal!(\n    value::InfrastructureSystems.InfrastructureSystemsComponent,\n    name\n)\n\n\nSet the name of the component. Must only be called by InfrastructureSystems.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_percentiles!-Tuple{InfrastructureSystems.Probabilistic, Any}","page":"API","title":"InfrastructureSystems.set_percentiles!","text":"set_percentiles!(\n    value::InfrastructureSystems.Probabilistic,\n    val\n) -> Any\n\n\nSet Probabilistic percentiles.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_percentiles!-Tuple{InfrastructureSystems.ProbabilisticMetadata, Any}","page":"API","title":"InfrastructureSystems.set_percentiles!","text":"set_percentiles!(\n    value::InfrastructureSystems.ProbabilisticMetadata,\n    val\n) -> Any\n\n\nSet ProbabilisticMetadata percentiles.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_resolution!-Tuple{InfrastructureSystems.Deterministic, Any}","page":"API","title":"InfrastructureSystems.set_resolution!","text":"set_resolution!(\n    value::InfrastructureSystems.Deterministic,\n    val\n) -> Any\n\n\nSet Deterministic resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_resolution!-Tuple{InfrastructureSystems.DeterministicMetadata, Any}","page":"API","title":"InfrastructureSystems.set_resolution!","text":"set_resolution!(\n    value::InfrastructureSystems.DeterministicMetadata,\n    val\n) -> Any\n\n\nSet DeterministicMetadata resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_resolution!-Tuple{InfrastructureSystems.Probabilistic, Any}","page":"API","title":"InfrastructureSystems.set_resolution!","text":"set_resolution!(\n    value::InfrastructureSystems.Probabilistic,\n    val\n) -> Any\n\n\nSet Probabilistic resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_resolution!-Tuple{InfrastructureSystems.ProbabilisticMetadata, Any}","page":"API","title":"InfrastructureSystems.set_resolution!","text":"set_resolution!(\n    value::InfrastructureSystems.ProbabilisticMetadata,\n    val\n) -> Any\n\n\nSet ProbabilisticMetadata resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_resolution!-Tuple{InfrastructureSystems.Scenarios, Any}","page":"API","title":"InfrastructureSystems.set_resolution!","text":"set_resolution!(\n    value::InfrastructureSystems.Scenarios,\n    val\n) -> Any\n\n\nSet Scenarios resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_resolution!-Tuple{InfrastructureSystems.ScenariosMetadata, Any}","page":"API","title":"InfrastructureSystems.set_resolution!","text":"set_resolution!(\n    value::InfrastructureSystems.ScenariosMetadata,\n    val\n) -> Any\n\n\nSet ScenariosMetadata resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_resolution!-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata, Any}","page":"API","title":"InfrastructureSystems.set_resolution!","text":"set_resolution!(\n    value::InfrastructureSystems.SingleTimeSeriesMetadata,\n    val\n) -> Any\n\n\nSet SingleTimeSeriesMetadata resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{InfrastructureSystems.Deterministic, Any}","page":"API","title":"InfrastructureSystems.set_scaling_factor_multiplier!","text":"set_scaling_factor_multiplier!(\n    value::InfrastructureSystems.Deterministic,\n    val\n) -> Any\n\n\nSet Deterministic scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{InfrastructureSystems.DeterministicMetadata, Any}","page":"API","title":"InfrastructureSystems.set_scaling_factor_multiplier!","text":"set_scaling_factor_multiplier!(\n    value::InfrastructureSystems.DeterministicMetadata,\n    val\n) -> Any\n\n\nSet DeterministicMetadata scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{InfrastructureSystems.Probabilistic, Any}","page":"API","title":"InfrastructureSystems.set_scaling_factor_multiplier!","text":"set_scaling_factor_multiplier!(\n    value::InfrastructureSystems.Probabilistic,\n    val\n) -> Any\n\n\nSet Probabilistic scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{InfrastructureSystems.ProbabilisticMetadata, Any}","page":"API","title":"InfrastructureSystems.set_scaling_factor_multiplier!","text":"set_scaling_factor_multiplier!(\n    value::InfrastructureSystems.ProbabilisticMetadata,\n    val\n) -> Any\n\n\nSet ProbabilisticMetadata scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{InfrastructureSystems.Scenarios, Any}","page":"API","title":"InfrastructureSystems.set_scaling_factor_multiplier!","text":"set_scaling_factor_multiplier!(\n    value::InfrastructureSystems.Scenarios,\n    val\n) -> Any\n\n\nSet Scenarios scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{InfrastructureSystems.ScenariosMetadata, Any}","page":"API","title":"InfrastructureSystems.set_scaling_factor_multiplier!","text":"set_scaling_factor_multiplier!(\n    value::InfrastructureSystems.ScenariosMetadata,\n    val\n) -> Any\n\n\nSet ScenariosMetadata scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{InfrastructureSystems.SingleTimeSeries, Any}","page":"API","title":"InfrastructureSystems.set_scaling_factor_multiplier!","text":"set_scaling_factor_multiplier!(\n    value::InfrastructureSystems.SingleTimeSeries,\n    val\n) -> Any\n\n\nSet SingleTimeSeries scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata, Any}","page":"API","title":"InfrastructureSystems.set_scaling_factor_multiplier!","text":"set_scaling_factor_multiplier!(\n    value::InfrastructureSystems.SingleTimeSeriesMetadata,\n    val\n) -> Any\n\n\nSet SingleTimeSeriesMetadata scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_scenario_count!-Tuple{InfrastructureSystems.Scenarios, Any}","page":"API","title":"InfrastructureSystems.set_scenario_count!","text":"set_scenario_count!(\n    value::InfrastructureSystems.Scenarios,\n    val\n) -> Any\n\n\nSet Scenarios scenario_count.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_scenario_count!-Tuple{InfrastructureSystems.ScenariosMetadata, Any}","page":"API","title":"InfrastructureSystems.set_scenario_count!","text":"set_scenario_count!(\n    value::InfrastructureSystems.ScenariosMetadata,\n    val\n) -> Any\n\n\nSet ScenariosMetadata scenario_count.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_single_time_series!-Tuple{InfrastructureSystems.DeterministicSingleTimeSeries, Any}","page":"API","title":"InfrastructureSystems.set_single_time_series!","text":"set_single_time_series!(\n    value::InfrastructureSystems.DeterministicSingleTimeSeries,\n    val\n) -> Any\n\n\nSet DeterministicSingleTimeSeries single_time_series.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_time_series_type!-Tuple{InfrastructureSystems.DeterministicMetadata, Any}","page":"API","title":"InfrastructureSystems.set_time_series_type!","text":"set_time_series_type!(\n    value::InfrastructureSystems.DeterministicMetadata,\n    val\n) -> Any\n\n\nSet DeterministicMetadata time_series_type.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_time_series_uuid!-Tuple{InfrastructureSystems.DeterministicMetadata, Any}","page":"API","title":"InfrastructureSystems.set_time_series_uuid!","text":"set_time_series_uuid!(\n    value::InfrastructureSystems.DeterministicMetadata,\n    val\n) -> Any\n\n\nSet DeterministicMetadata time_series_uuid.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_time_series_uuid!-Tuple{InfrastructureSystems.ProbabilisticMetadata, Any}","page":"API","title":"InfrastructureSystems.set_time_series_uuid!","text":"set_time_series_uuid!(\n    value::InfrastructureSystems.ProbabilisticMetadata,\n    val\n) -> Any\n\n\nSet ProbabilisticMetadata time_series_uuid.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_time_series_uuid!-Tuple{InfrastructureSystems.ScenariosMetadata, Any}","page":"API","title":"InfrastructureSystems.set_time_series_uuid!","text":"set_time_series_uuid!(\n    value::InfrastructureSystems.ScenariosMetadata,\n    val\n) -> Any\n\n\nSet ScenariosMetadata time_series_uuid.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_time_series_uuid!-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata, Any}","page":"API","title":"InfrastructureSystems.set_time_series_uuid!","text":"set_time_series_uuid!(\n    value::InfrastructureSystems.SingleTimeSeriesMetadata,\n    val\n) -> Any\n\n\nSet SingleTimeSeriesMetadata time_series_uuid.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.show_recorder_events-Union{Tuple{T}, Tuple{Type{T}, AbstractString}, Tuple{Type{T}, AbstractString, Union{Nothing, Function}}} where T<:InfrastructureSystems.AbstractRecorderEvent","page":"API","title":"InfrastructureSystems.show_recorder_events","text":"show_recorder_events(\n    ::Type{T<:InfrastructureSystems.AbstractRecorderEvent},\n    filename::AbstractString;\n    ...\n)\nshow_recorder_events(\n    ::Type{T<:InfrastructureSystems.AbstractRecorderEvent},\n    filename::AbstractString,\n    filter_func::Union{Nothing, Function};\n    kwargs...\n)\n\n\nShow the events of type T in filename in a table. Refer to PrettyTables.jl documentation for accepted kwargs.\n\nArguments\n\nT: event type\nfilename::AbstractString: filename containing recorder events\nfilter_func::Union{Nothing, Function} = nothing: Optional function that accepts an event of type T and returns a Bool. Apply this function to each event and only return events where the result is true.\nexclude_columns = Set{String}(): Column names to exclude from the table\nkwargs: Passed to PrettyTables\n\nExamples\n\nshow_recorder_events(TestEvent, test_recorder.log)\nshow_recorder_events(TestEvent, test_recorder.log, x -> x.val2 > 2)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.show_supplemental_attributes-Tuple{InfrastructureSystems.InfrastructureSystemsComponent}","page":"API","title":"InfrastructureSystems.show_supplemental_attributes","text":"show_supplemental_attributes(\n    component::InfrastructureSystems.InfrastructureSystemsComponent\n)\n\n\nShow a table with supplemental attributes attached to the component.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.show_time_series-Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}}","page":"API","title":"InfrastructureSystems.show_time_series","text":"show_time_series(\n    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, InfrastructureSystems.SupplementalAttribute}\n)\n\n\nShow a table with time series data attached to the component.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.sql","page":"API","title":"InfrastructureSystems.sql","text":"sql(\n    store::InfrastructureSystems.TimeSeriesMetadataStore,\n    query::String\n) -> DataFrames.DataFrame\nsql(\n    store::InfrastructureSystems.TimeSeriesMetadataStore,\n    query::String,\n    params\n) -> DataFrames.DataFrame\n\n\nRun a query and return the results in a DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"InfrastructureSystems/#InfrastructureSystems.sql-2","page":"API","title":"InfrastructureSystems.sql","text":"sql(\n    associations::InfrastructureSystems.SupplementalAttributeAssociations,\n    query::String\n) -> DataFrames.DataFrame\nsql(\n    associations::InfrastructureSystems.SupplementalAttributeAssociations,\n    query::String,\n    params\n) -> DataFrames.DataFrame\n\n\nRun a query and return the results in a DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"InfrastructureSystems/#InfrastructureSystems.strip_module_name-Tuple{String}","page":"API","title":"InfrastructureSystems.strip_module_name","text":"strip_module_name(name::String) -> String\n\n\nStrips the module name off of a type string. This can be useful to print types as strings and receive consistent results regardless of whether the user used import or using to load a package.\n\nNote: This only strips the outermost module name. Module names inside parametric types (e.g., inside {...}) are preserved.\n\nExamples\n\njulia> strip_module_name(\"PowerSystems.HydroDispatch\")\n\"HydroDispatch\"\njulia> strip_module_name(\"SingleTimeSeries{PowerSystems.HydroDispatch}\")\n\"SingleTimeSeries{PowerSystems.HydroDispatch}\"\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.strip_module_name-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"API","title":"InfrastructureSystems.strip_module_name","text":"strip_module_name(_::Type{T}) -> Any\n\n\nStrips the module name off of a type. Unlike the String method, this also strips module names from type parameters.\n\nExamples\n\njulia> strip_module_name(PowerSystems.RegulationDevice{ThermalStandard})\n\"RegulationDevice{ThermalStandard}\"\njulia> strip_module_name(VariableReserve{PowerSystems.ReserveUp})\n\"VariableReserve{ReserveUp}\"\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.subtype_to_string-Tuple{Type{<:InfrastructureSystems.InfrastructureSystemsComponent}}","page":"API","title":"InfrastructureSystems.subtype_to_string","text":"subtype_to_string(\n    subtype::Type{<:InfrastructureSystems.InfrastructureSystemsComponent}\n) -> Any\n\n\nCanonical way to turn an InfrastructureSystemsComponent subtype into a unique string.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.supertypes-Union{Tuple{Type{T}}, Tuple{T}, Tuple{Type{T}, Any}} where T","page":"API","title":"InfrastructureSystems.supertypes","text":"supertypes(::Type{T}) -> Vector{Any}\nsupertypes(::Type{T}, types) -> Any\n\n\nReturns an array of all super types of T.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.supports_supplemental_attributes-Tuple{InfrastructureSystems.InfrastructureSystemsComponent}","page":"API","title":"InfrastructureSystems.supports_supplemental_attributes","text":"supports_supplemental_attributes(\n    _::InfrastructureSystems.InfrastructureSystemsComponent\n) -> Bool\n\n\nReturn true if the component supports supplemental attributes.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.supports_time_series-Tuple{InfrastructureSystems.InfrastructureSystemsComponent}","page":"API","title":"InfrastructureSystems.supports_time_series","text":"supports_time_series(\n    _::InfrastructureSystems.InfrastructureSystemsComponent\n) -> Bool\n\n\nReturn true if the component supports time series.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.supports_time_series-Tuple{InfrastructureSystems.SupplementalAttribute}","page":"API","title":"InfrastructureSystems.supports_time_series","text":"supports_time_series(\n    _::InfrastructureSystems.SupplementalAttribute\n) -> Bool\n\n\nReturn true if the supplemental attribute supports time series.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.tail-Tuple{InfrastructureSystems.SingleTimeSeries}","page":"API","title":"InfrastructureSystems.tail","text":"tail(\n    time_series::InfrastructureSystems.SingleTimeSeries\n) -> Any\n\n\nReturn a time_series with only the ending num values.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.test_generated_structs-Tuple{Any, Any}","page":"API","title":"InfrastructureSystems.test_generated_structs","text":"test_generated_structs(\n    descriptor_file,\n    existing_dir\n) -> Bool\n\n\nReturn true if the structs defined in existing_dir match structs freshly generated from descriptor_file.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.to-Tuple{InfrastructureSystems.SingleTimeSeries, Any}","page":"API","title":"InfrastructureSystems.to","text":"to(\n    time_series::InfrastructureSystems.SingleTimeSeries,\n    timestamp\n) -> InfrastructureSystems.SingleTimeSeries\n\n\nReturn a time_series truncated after timestamp.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.to_dataframe-Tuple{InfrastructureSystems.TimeSeriesMetadataStore}","page":"API","title":"InfrastructureSystems.to_dataframe","text":"to_dataframe(\n    store::InfrastructureSystems.TimeSeriesMetadataStore;\n    table\n) -> DataFrames.DataFrame\n\n\nReturn the table as a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.to_dict-Tuple{InfrastructureSystems.SystemData}","page":"API","title":"InfrastructureSystems.to_dict","text":"to_dict(\n    data::InfrastructureSystems.SystemData\n) -> Dict{String, Any}\n\n\nSerialize all system and component data to a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.to_json-Tuple{T} where T<:InfrastructureSystems.InfrastructureSystemsType","page":"API","title":"InfrastructureSystems.to_json","text":"to_json(\n    obj::InfrastructureSystems.InfrastructureSystemsType;\n    pretty,\n    indent\n) -> Any\n\n\nSerializes a InfrastructureSystemsType to a JSON string.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.to_json-Union{Tuple{T}, Tuple{T, AbstractString}} where T<:InfrastructureSystems.InfrastructureSystemsType","page":"API","title":"InfrastructureSystems.to_json","text":"to_json(\n    obj::InfrastructureSystems.InfrastructureSystemsType;\n    pretty,\n    indent\n) -> Any\n\n\nSerializes a InfrastructureSystemsType to a JSON file.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.to_records-Tuple{InfrastructureSystems.SupplementalAttributeAssociations}","page":"API","title":"InfrastructureSystems.to_records","text":"to_records(\n    associations::InfrastructureSystems.SupplementalAttributeAssociations\n) -> Vector\n\n\nReturn all rows in the table as dictionaries.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.transform_single_time_series!-Tuple{InfrastructureSystems.SystemData, Type{<:InfrastructureSystems.DeterministicSingleTimeSeries}, Dates.Period, Dates.Period}","page":"API","title":"InfrastructureSystems.transform_single_time_series!","text":"transform_single_time_series!(\n    data::InfrastructureSystems.SystemData,\n    ::Type{<:InfrastructureSystems.DeterministicSingleTimeSeries},\n    horizon::Dates.Period,\n    interval::Dates.Period;\n    resolution\n)\n\n\nTransform all instances of SingleTimeSeries to DeterministicSingleTimeSeries. If all SingleTimeSeries instances cannot be transformed then none will be.\n\nAny existing DeterministicSingleTimeSeries forecasts will be deleted even if the inputs are invalid.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.unregister_recorder!-Tuple{Symbol}","page":"API","title":"InfrastructureSystems.unregister_recorder!","text":"unregister_recorder!(name::Symbol; close_io) -> Any\n\n\nUnregister the recorder with this name and stop recording events.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.validate_exported_names-Tuple{Module}","page":"API","title":"InfrastructureSystems.validate_exported_names","text":"validate_exported_names(mod::Module) -> Bool\n\n\nReturn true if all publicly exported names in mod are defined.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.validate_groupby-Tuple{Symbol}","page":"API","title":"InfrastructureSystems.validate_groupby","text":"validate_groupby(groupby::Symbol) -> Symbol\n\n\nHelper function to check that the groupby argument is valid. Passes it through if so, errors if not.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.validate_struct-Tuple{InfrastructureSystems.InfrastructureSystemsType}","page":"API","title":"InfrastructureSystems.validate_struct","text":"validate_struct(\n    ist::InfrastructureSystems.InfrastructureSystemsType\n) -> Bool\n\n\nValidates a struct using only information within the struct.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.validate_time_series_data_for_hdf-Union{Tuple{DataStructures.SortedDict{Dates.DateTime, Vector{T}}}, Tuple{T}} where T","page":"API","title":"InfrastructureSystems.validate_time_series_data_for_hdf","text":"validate_time_series_data_for_hdf(\n    _::DataStructures.SortedDict{Dates.DateTime, Array{T, 1}}\n)\n\n\nValidate that data in a SortedDict has supported element types for transformarrayfor_hdf. Throws an ArgumentError if any vector has an unsupported element type.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.when-Tuple{InfrastructureSystems.SingleTimeSeries, Function, Integer}","page":"API","title":"InfrastructureSystems.when","text":"when(\n    time_series::InfrastructureSystems.SingleTimeSeries,\n    period::Function,\n    t::Integer\n) -> Any\n\n\nRefer to TimeSeries.when(). Underlying data is copied.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.@assert_op-Tuple{Any}","page":"API","title":"InfrastructureSystems.@assert_op","text":"Throw an AssertionError if conditions like op(exp1, exp2) are false, where op is a conditional infix operator.\n\nExamples\n\njulia> a = 3; b = 4;\njulia> @assert_op a == b\nERROR: AssertionError: 3 == 4\n\njulia> @assert_op a + 3 > b + 4\nERROR: AssertionError: 6 > 8\n\n\n\n\n\n","category":"macro"},{"location":"InfrastructureSystems/#InfrastructureSystems.@record-Tuple{Any, Any}","page":"API","title":"InfrastructureSystems.@record","text":"Record an event if the recorder with name is enabled.\n\nArguments\n\nname::Symbol: name of recorder\nevent::AbstractRecorderEvent: event to record\n\nExamples\n\n@record simulation TestEvent(\"start\", 1, 2.0)\n\n\n\n\n\n","category":"macro"},{"location":"InfrastructureSystems/#InfrastructureSystems.@scoped_enum-Tuple{Any, Vararg{Any}}","page":"API","title":"InfrastructureSystems.@scoped_enum","text":"Macro to wrap Enum in a module to keep the top level scope clean.\n\nExamples\n\njulia> @scoped_enum Fruit APPLE = 1 ORANGE = 2\n\njulia> value = Fruit.APPLE\nFruit.APPLE = 1\n\njulia> value = Fruit(1)\nFruit.APPLE = 1\n\njulia> @scoped_enum(Fruit,\n    APPLE = 1,  # comment\n    ORANGE = 2,  # comment\n)\n\n\n\n\n\n","category":"macro"},{"location":"InfrastructureSystems/#InfrastructureSystems.Simulation","page":"API","title":"InfrastructureSystems.Simulation","text":"Simulation\n\n\n\n\n\n","category":"module"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization","page":"API","title":"InfrastructureSystems.Optimization","text":"Optimization\n\n\n\n\n\n","category":"module"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization.ConstructStage","page":"API","title":"InfrastructureSystems.Optimization.ConstructStage","text":"Optimization Container construction stage\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization.ModelInternal","page":"API","title":"InfrastructureSystems.Optimization.ModelInternal","text":"Common structure to keep track of optimization models' internal information.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization.OptimizationProblemResults","page":"API","title":"InfrastructureSystems.Optimization.OptimizationProblemResults","text":"mutable struct OptimizationProblemResults <: Results\n\nContainer for the results of an optimization problem, including variable values, dual values, parameter values, expression values, and optimizer statistics.\n\nThis type stores all output data from solving an optimization problem and provides methods to read, export, and serialize the results. Instead of accessing the result dictionary  fields directly, use the read_foo functions.\n\nFields\n\nbase_power::Float64: Base power used for per-unit conversion\ntimestamps::Vector{Dates.DateTime}: Time stamps for each step in the results\nsource_data::Union{Nothing, InfrastructureSystemsType}: Reference to the source data (e.g., system)\nsource_data_uuid::Base.UUID: UUID of the source data for validation. Internal usage.\naux_variable_values::Dict{AuxVarKey, DataFrame}: Auxiliary variable results. See read_aux_variable and read_aux_variables\nvariable_values::Dict{VariableKey, DataFrame}: Decision variable results. See read_variable and read_variables\ndual_values::Dict{ConstraintKey, DataFrame}: Dual results. See read_dual and read_duals\nparameter_values::Dict{ParameterKey, DataFrame}: Parameter results. See read_parameter and read_parameters\nexpression_values::Dict{ExpressionKey, DataFrame}: Expression results. See read_expression and read_expressions\noptimizer_stats::DataFrame: Optimizer statistics for each solve\noptimization_container_metadata::OptimizationContainerMetadata: Metadata about the optimization container. Internal usage.\nmodel_type::String: Type of optimization model. Internal usage.\nresults_dir::String: Directory where results are stored\noutput_dir::String: Directory for exported output\n\nSee also: Results, OptimizerStats, OptimizationProblemResultsExport\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization.OptimizationProblemResults-Tuple{AbstractString}","page":"API","title":"InfrastructureSystems.Optimization.OptimizationProblemResults","text":"OptimizationProblemResults(directory::AbstractString) -> Any\n\n\nConstruct a OptimizationProblemResults instance from a serialized directory. It is up to the user or a higher-level package to set the source data using set_source_data!.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization.OptimizationProblemResultsExport","page":"API","title":"InfrastructureSystems.Optimization.OptimizationProblemResultsExport","text":"struct OptimizationProblemResultsExport\n\nConfiguration for exporting optimization problem results to files.\n\nSpecifies which variables, duals, parameters, expressions, and auxiliary variables should be exported when calling export_results on an OptimizationProblemResults instance.\n\nFields\n\nname::Symbol: Name identifier for this export configuration\nduals::Set{ConstraintKey}: Specific dual values to export\nexpressions::Set{ExpressionKey}: Specific expression values to export\nparameters::Set{ParameterKey}: Specific parameter values to export\nvariables::Set{VariableKey}: Specific variable values to export\naux_variables::Set{AuxVarKey}: Specific auxiliary variable values to export\noptimizer_stats::Bool: Whether to export optimizer statistics\nstore_all_flags::Dict{Symbol, Bool}: Flags indicating whether to export all values of each type (e.g., all variables, all duals). Set via constructor keyword arguments like store_all_variables = true. When a flag is true, all values of that type are exported regardless of what specific keys are passed in the corresponding set.\n\nExample\n\nexport_config = OptimizationProblemResultsExport(\n    \"MyExport\";\n    store_all_variables = true,\n    store_all_duals = false,\n    optimizer_stats = true,\n)\nexport_results(results, export_config)\n\nSee also: OptimizationProblemResults, export_results\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization.OptimizerStats","page":"API","title":"InfrastructureSystems.Optimization.OptimizerStats","text":"mutable struct OptimizerStats\n\nStatistics and performance metrics from an optimization solver run.\n\nCaptures solver-reported metrics (termination status, objective value, solve time) as well as timing information for auxiliary computations. Fields marked as Union{Missing, T} may not be available for all solvers.\n\nFields\n\ndetailed_stats::Bool: Whether detailed statistics are available\nobjective_value::Float64: Optimal objective function value\ntermination_status::Int: Solver termination status code\nprimal_status::Int: Status of the primal solution\ndual_status::Int: Status of the dual solution\nsolver_solve_time::Float64: Time reported by the solver for the solve\nresult_count::Int: Number of solutions found\nhas_values::Bool: Whether primal values are available\nhas_duals::Bool: Whether dual values are available\nobjective_bound::Union{Missing, Float64}: Bound on the objective (for MIP solvers)\nrelative_gap::Union{Missing, Float64}: Relative optimality gap (for MIP solvers)\ndual_objective_value::Union{Missing, Float64}: Dual objective value\nsolve_time::Float64: Total solve time\nbarrier_iterations::Union{Missing, Int}: Number of barrier iterations\nsimplex_iterations::Union{Missing, Int}: Number of simplex iterations\nnode_count::Union{Missing, Int}: Number of branch-and-bound nodes explored\ntimed_solve_time::Float64: Externally timed solve duration\ntimed_calculate_aux_variables::Float64: Time to calculate auxiliary variables\ntimed_calculate_dual_variables::Float64: Time to calculate dual variables\nsolve_bytes_alloc::Union{Missing, Float64}: Memory allocated during solve\nsec_in_gc::Union{Missing, Float64}: Time spent in garbage collection\n\nSee also: OptimizationProblemResults\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization.OptimizerStats-Tuple{Vector{Float64}}","page":"API","title":"InfrastructureSystems.Optimization.OptimizerStats","text":"OptimizerStats(data::Vector{Float64}) -> Any\n\n\nConstruct OptimizerStats from a vector that was serialized.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization._handle_natural_units-Tuple{DataFrames.DataFrame, Float64, InfrastructureSystems.Optimization.OptimizationContainerKey}","page":"API","title":"InfrastructureSystems.Optimization._handle_natural_units","text":"_handle_natural_units(\n    df::DataFrames.DataFrame,\n    base_power::Float64,\n    key::InfrastructureSystems.Optimization.OptimizationContainerKey\n) -> DataFrames.DataFrame\n\n\nConvert the value column to natural units, if required by the key. Does not mutate the input dataframe.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization.export_optimizer_stats-Tuple{InfrastructureSystems.Results, AbstractString}","page":"API","title":"InfrastructureSystems.Optimization.export_optimizer_stats","text":"export_optimizer_stats(\n    res::InfrastructureSystems.Results,\n    directory::AbstractString;\n    format\n) -> Union{String, Vector{String}}\n\n\nSave the optimizer statistics to CSV or JSON\n\nArguments\n\nres::Union{OptimizationProblemResults, SimulationProblmeResults: Results\ndirectory::AbstractString : target directory\nformat = \"CSV\" : can be \"csv\" or \"json\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization.export_realized_results-Tuple{InfrastructureSystems.Results}","page":"API","title":"InfrastructureSystems.Optimization.export_realized_results","text":"export_realized_results(\n    res::InfrastructureSystems.Results\n) -> String\n\n\nSave the realized results to CSV files for all variables, paramaters, duals, auxiliary variables, expressions, and optimizer statistics.\n\nArguments\n\nres::Results: Results\nsave_path::AbstractString : path to save results (defaults to simulation path)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization.export_results-Tuple{InfrastructureSystems.Optimization.OptimizationProblemResults}","page":"API","title":"InfrastructureSystems.Optimization.export_results","text":"export_results(\n    results::InfrastructureSystems.Optimization.OptimizationProblemResults;\n    kwargs...\n)\n\n\nExports all results from the operations problem.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization.read_aux_variable-Tuple{InfrastructureSystems.Optimization.OptimizationProblemResults, Vararg{Any}}","page":"API","title":"InfrastructureSystems.Optimization.read_aux_variable","text":"read_aux_variable(\n    res::InfrastructureSystems.Optimization.OptimizationProblemResults,\n    args...;\n    kwargs...\n) -> DataFrames.DataFrame\n\n\nReturn the values for the requested aux_variable key for a problem. Accepts a vector of keys for the return of the values.\n\nArguments\n\naux_variable::Tuple{Type{<:AuxVariableType}, Type{<:PSY.Component} : Tuple with aux_variable type and device type for the desired results\nstart_time::Dates.DateTime : initial time of the requested results\nlen::Int: length of results\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization.read_aux_variables-Tuple{InfrastructureSystems.Optimization.OptimizationProblemResults, Any}","page":"API","title":"InfrastructureSystems.Optimization.read_aux_variables","text":"read_aux_variables(\n    res::InfrastructureSystems.Optimization.OptimizationProblemResults,\n    aux_variables;\n    kwargs...\n) -> Union{Dict{Any, Any}, Dict{_A, DataFrames.DataFrame} where _A}\n\n\nReturn the values for the requested aux_variable keys for a problem. Accepts a vector of keys for the return of the values.\n\nArguments\n\naux_variables::Vector{Tuple{Type{<:AuxVariableType}, Type{<:PSY.Component}} : Tuple with aux_variable type and device type for the desired results\nstart_time::Dates.DateTime : initial time of the requested results\nlen::Int: length of results\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization.read_aux_variables-Tuple{InfrastructureSystems.Results}","page":"API","title":"InfrastructureSystems.Optimization.read_aux_variables","text":"read_aux_variables(\n    res::InfrastructureSystems.Results;\n    kwargs...\n) -> Dict\n\n\nReturn the values for all auxiliary variables.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization.read_dual-Tuple{InfrastructureSystems.Optimization.OptimizationProblemResults, Vararg{Any}}","page":"API","title":"InfrastructureSystems.Optimization.read_dual","text":"read_dual(\n    res::InfrastructureSystems.Optimization.OptimizationProblemResults,\n    args...;\n    kwargs...\n) -> DataFrames.DataFrame\n\n\nReturn the values for the requested dual key for a problem. Accepts a vector of keys for the return of the values.\n\nArguments\n\ndual::Tuple{Type{<:ConstraintType}, Type{<:PSY.Component} : Tuple with dual type and device type for the desired results\nstart_time::Dates.DateTime : initial time of the requested results\nlen::Int: length of results\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization.read_duals-Tuple{InfrastructureSystems.Optimization.OptimizationProblemResults, Any}","page":"API","title":"InfrastructureSystems.Optimization.read_duals","text":"read_duals(\n    res::InfrastructureSystems.Optimization.OptimizationProblemResults,\n    duals;\n    kwargs...\n) -> Union{Dict{Any, Any}, Dict{_A, DataFrames.DataFrame} where _A}\n\n\nReturn the values for the requested dual keys for a problem. Accepts a vector of keys for the return of the values.\n\nArguments\n\nduals::Vector{Tuple{Type{<:ConstraintType}, Type{<:PSY.Component}} : Tuple with dual type and device type for the desired results\nstart_time::Dates.DateTime : initial time of the requested results\nlen::Int: length of results\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization.read_duals-Tuple{InfrastructureSystems.Results}","page":"API","title":"InfrastructureSystems.Optimization.read_duals","text":"read_duals(\n    res::InfrastructureSystems.Results;\n    kwargs...\n) -> Dict\n\n\nReturn the values for all duals.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization.read_expression-Tuple{InfrastructureSystems.Optimization.OptimizationProblemResults, Vararg{Any}}","page":"API","title":"InfrastructureSystems.Optimization.read_expression","text":"read_expression(\n    res::InfrastructureSystems.Optimization.OptimizationProblemResults,\n    args...;\n    kwargs...\n) -> DataFrames.DataFrame\n\n\nReturn the values for the requested expression key for a problem. Accepts a vector of keys for the return of the values.\n\nArguments\n\nexpression::Tuple{Type{<:ExpressionType}, Type{<:PSY.Component} : Tuple with expression type and device type for the desired results\nstart_time::Dates.DateTime : initial time of the requested results\nlen::Int: length of results\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization.read_expressions-Tuple{InfrastructureSystems.Optimization.OptimizationProblemResults}","page":"API","title":"InfrastructureSystems.Optimization.read_expressions","text":"read_expressions(\n    res::InfrastructureSystems.Optimization.OptimizationProblemResults;\n    kwargs...\n) -> Union{Dict{Any, Any}, Dict{_A, DataFrames.DataFrame} where _A}\n\n\nReturn the values for the requested expression keys for a problem. Accepts a vector of keys for the return of the values.\n\nArguments\n\nexpressions::Vector{Tuple{Type{<:ExpressionType}, Type{<:PSY.Component}} : Tuple with expression type and device type for the desired results\nstart_time::Dates.DateTime : initial time of the requested results\nlen::Int: length of results\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization.read_expressions-Tuple{InfrastructureSystems.Results}","page":"API","title":"InfrastructureSystems.Optimization.read_expressions","text":"read_expressions(\n    res::InfrastructureSystems.Results;\n    kwargs...\n) -> Union{Dict{Any, Any}, Dict{_A, DataFrames.DataFrame} where _A}\n\n\nReturn the values for all expressions.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization.read_parameter-Tuple{InfrastructureSystems.Optimization.OptimizationProblemResults, Vararg{Any}}","page":"API","title":"InfrastructureSystems.Optimization.read_parameter","text":"read_parameter(\n    res::InfrastructureSystems.Optimization.OptimizationProblemResults,\n    args...;\n    kwargs...\n) -> DataFrames.DataFrame\n\n\nReturn the values for the requested parameter key for a problem. Accepts a vector of keys for the return of the values.\n\nArguments\n\nparameter::Tuple{Type{<:ParameterType}, Type{<:PSY.Component} : Tuple with parameter type and device type for the desired results\nstart_time::Dates.DateTime : initial time of the requested results\nlen::Int: length of results\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization.read_parameters-Tuple{InfrastructureSystems.Optimization.OptimizationProblemResults, Any}","page":"API","title":"InfrastructureSystems.Optimization.read_parameters","text":"read_parameters(\n    res::InfrastructureSystems.Optimization.OptimizationProblemResults,\n    parameters;\n    kwargs...\n) -> Union{Dict{Any, Any}, Dict{_A, DataFrames.DataFrame} where _A}\n\n\nReturn the values for the requested parameter keys for a problem. Accepts a vector of keys for the return of the values.\n\nArguments\n\nparameters::Vector{Tuple{Type{<:ParameterType}, Type{<:PSY.Component}} : Tuple with parameter type and device type for the desired results\nstart_time::Dates.DateTime : initial time of the requested results\nlen::Int: length of results\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization.read_parameters-Tuple{InfrastructureSystems.Results}","page":"API","title":"InfrastructureSystems.Optimization.read_parameters","text":"read_parameters(\n    res::InfrastructureSystems.Results;\n    kwargs...\n) -> Dict\n\n\nReturn the values for all parameters.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization.read_variable-Tuple{InfrastructureSystems.Optimization.OptimizationProblemResults, Vararg{Any}}","page":"API","title":"InfrastructureSystems.Optimization.read_variable","text":"read_variable(\n    res::InfrastructureSystems.Optimization.OptimizationProblemResults,\n    args...;\n    kwargs...\n) -> DataFrames.DataFrame\n\n\nReturn the values for the requested variable key for a problem. Accepts a vector of keys for the return of the values.\n\nArguments\n\nres::OptimizationProblemResults: Optimization problem results\nvariable::Tuple{Type{<:VariableType}, Type{<:PSY.Component}: Tuple with variable type and device type for the desired results\nstart_time::Dates.DateTime: Start time of the requested results\nlen::Int: length of results\ntable_format::TableFormat: Format of the table to be returned. Default is TableFormat.LONG where the columns are DateTime, name, and value when the data has two dimensions and DateTime, name, name2, and value when the data has three dimensions. Set to it TableFormat.WIDE to pivot the names as columns. Note: TableFormat.WIDE is not supported when the data has more than two dimensions.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization.read_variables-Tuple{InfrastructureSystems.Optimization.OptimizationProblemResults, Any}","page":"API","title":"InfrastructureSystems.Optimization.read_variables","text":"read_variables(\n    res::InfrastructureSystems.Optimization.OptimizationProblemResults,\n    variables;\n    kwargs...\n) -> Union{Dict{Any, Any}, Dict{_A, DataFrames.DataFrame} where _A}\n\n\nReturn the values for the requested variable keys for a problem. Accepts a vector of keys for the return of the values.\n\nArguments\n\nvariables::Vector{Tuple{Type{<:VariableType}, Type{<:PSY.Component}} : Tuple with variable type and device type for the desired results\nstart_time::Dates.DateTime : initial time of the requested results\nlen::Int: length of results\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization.read_variables-Tuple{InfrastructureSystems.Results}","page":"API","title":"InfrastructureSystems.Optimization.read_variables","text":"read_variables(\n    res::InfrastructureSystems.Results;\n    kwargs...\n) -> Dict\n\n\nReturn the values for all variables.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization.serialize_results-Tuple{InfrastructureSystems.Optimization.OptimizationProblemResults, AbstractString}","page":"API","title":"InfrastructureSystems.Optimization.serialize_results","text":"serialize_results(\n    res::InfrastructureSystems.Optimization.OptimizationProblemResults,\n    directory::AbstractString\n)\n\n\nSerialize the results to a binary file.\n\nIt is recommended that directory be the directory that contains a serialized OperationModel. That will allow automatic deserialization of the PowerSystems.System. The OptimizationProblemResults instance can be deserialized with OptimizationProblemResults(directory).\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization.set_source_data!-Tuple{InfrastructureSystems.Optimization.OptimizationProblemResults, InfrastructureSystems.InfrastructureSystemsType}","page":"API","title":"InfrastructureSystems.Optimization.set_source_data!","text":"set_source_data!(\n    res::InfrastructureSystems.Optimization.OptimizationProblemResults,\n    source::InfrastructureSystems.InfrastructureSystemsType\n)\n\n\nSet the system in the results instance.\n\nThrows InvalidValue if the source UUID is incorrect.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Optimization.to_matrix-Tuple{T} where T<:InfrastructureSystems.Optimization.OptimizerStats","page":"API","title":"InfrastructureSystems.Optimization.to_matrix","text":"to_matrix(\n    stats::InfrastructureSystems.Optimization.OptimizerStats\n) -> Matrix{Float64}\n\n\nConvert OptimizerStats to a matrix of floats that can be serialized.\n\n\n\n\n\n","category":"method"},{"location":"docs_best_practices/how-to/compile/#Compile-and-View-Documentation-Locally","page":"Compile and View Documentation Locally","title":"Compile and View Documentation Locally","text":"","category":"section"},{"location":"docs_best_practices/how-to/compile/#Pre-Step-a:-Update-Docs-Environment-(First-Time)","page":"Compile and View Documentation Locally","title":"Pre-Step a: Update Docs Environment (First Time)","text":"The first time you compile documentation for a package, make sure the docs/ environment (i.e., docs/Manifest.toml, not the main Manifest.toml in the root of the repository) is pointing to your local version of the package, so it compiles your local changes:\n\njulia --project=docs\nusing Pkg\nPkg.develop(path = \"..\")","category":"section"},{"location":"docs_best_practices/how-to/compile/#Pre-Step-b:-Auto-Generate-Structs-(If-Needed)","page":"Compile and View Documentation Locally","title":"Pre-Step b: Auto-Generate Structs (If Needed)","text":"Most documentation changes are made directly to markdown (.md) files, but if you changed one of Sienna's .json descriptor files, you must first follow the instructions here to auto-generate the structs from the .json to have your changes propagated into the markdown files used for documentation.\n\nExample: You updated PowerSystems.jl' power_system_structs.json file.\n\nFrom a terminal at the root of the repository (i.e., PowerSystems.jl), run:\n\njulia --project=.\nusing InfrastructureSystems\nInfrastructureSystems.generate_structs(\n    \"./src/descriptors/power_system_structs.json\",\n    \"./src/models/generated\",\n)","category":"section"},{"location":"docs_best_practices/how-to/compile/#Pre-Step-c:-Run-the-Formatter-(Before-Submitting-a-Pull-Request)","page":"Compile and View Documentation Locally","title":"Pre-Step c: Run the Formatter (Before Submitting a Pull Request)","text":"To automatically format the documentation to conform with the style guide, run in a terminal at the root of the repository:\n\njulia scripts/formatter/formatter_code.jl\n\nResolve any errors and re-run until error-free. See how to Troubleshoot Common Errors for help.\n\nThis is not a necessary step to compile, but needs to be done at least once to pass pull request checks.","category":"section"},{"location":"docs_best_practices/how-to/compile/#Step-1:-Compile","page":"Compile and View Documentation Locally","title":"Step 1: Compile","text":"To compile, run in a terminal at the root of the repository:\n\njulia --project=docs docs/make.jl \n\nResolve any errors and re-run until error-free. See how to Troubleshoot Common Errors for help.","category":"section"},{"location":"docs_best_practices/how-to/compile/#Step-2:-View","page":"Compile and View Documentation Locally","title":"Step 2: View","text":"Click on the newly-created index.html file (e.g., SomeSiennaPackage/docs/build/index.html) to view your locally compiled documentation in a browser.\n\nVisually verify formatting and that code blocks compile as expected.","category":"section"},{"location":"dev_guide/test_data_artifacts/#Using-Local-Test-Data-with-PowerSystemCaseBuilder","page":"Using Local Test Data with PowerSystemCaseBuilder","title":"Using Local Test Data with PowerSystemCaseBuilder","text":"By default, PowerSystemCaseBuilder fetches test data from Julia's official artifact system. When developing or modifying test data, you may need to use a local copy of the test data instead. This guide explains how to configure PowerSystemCaseBuilder to use local test data.","category":"section"},{"location":"dev_guide/test_data_artifacts/#Steps-to-Use-Local-Test-Data","page":"Using Local Test Data with PowerSystemCaseBuilder","title":"Steps to Use Local Test Data","text":"","category":"section"},{"location":"dev_guide/test_data_artifacts/#1.-Clone-the-Required-Repositories","page":"Using Local Test Data with PowerSystemCaseBuilder","title":"1. Clone the Required Repositories","text":"Clone both PowerSystemCaseBuilder.jl and PowerSystemsTestData:\n\ngit clone https://github.com/NREL-Sienna/PowerSystemCaseBuilder.jl.git\ngit clone https://github.com/NREL-Sienna/PowerSystemsTestData.git\n\nAlternatively, if you're working within a Julia environment, you can use dev to clone PowerSystemCaseBuilder.jl:\n\nusing Pkg\nPkg.develop(\"PowerSystemCaseBuilder\")\n\n(This won't work on PowerSystemsTestData, because it isn't a Julia package.)","category":"section"},{"location":"dev_guide/test_data_artifacts/#2.-Modify-the-Data-Directory-Path","page":"Using Local Test Data with PowerSystemCaseBuilder","title":"2. Modify the Data Directory Path","text":"Open PowerSystemCaseBuilder.jl/src/definitions.jl and locate the DATA_DIR constant:\n\nconst DATA_DIR = joinpath(LazyArtifacts.artifact\"CaseData\", \"PowerSystemsTestData-4.0.2\")\n\nChange it to point to your local PowerSystemsTestData directory:\n\nconst DATA_DIR = \"/path/to/your/PowerSystemsTestData\"","category":"section"},{"location":"dev_guide/test_data_artifacts/#3.-Clear-Cached-Systems-After-Modifying-Test-Data","page":"Using Local Test Data with PowerSystemCaseBuilder","title":"3. Clear Cached Systems After Modifying Test Data","text":"After making changes to PowerSystemsTestData, Julia may still use cached versions of the systems that don't reflect your modifications. You have two options to ensure your changes take effect:\n\nOption A: Clear all cached systems\n\nusing PowerSystemCaseBuilder\nPowerSystemCaseBuilder.clear_all_serialized_systems()\n\nOption B: Force rebuild on demand\n\nPass the force_build = true keyword argument when calling build_system:\n\nsys = build_system(SomeSystemCategory, \"system_name\"; force_build = true)\n\nThis approach is useful when you only want to rebuild specific systems rather than clearing the entire cache.","category":"section"},{"location":"dev_guide/logging/#log","page":"Logging","title":"Logging","text":"InfrastructureSystems.jl provides a MultiLogger object that allows customized logging to console and file. Refer to the logging documentation.\n\nIf you want to create a package-specific log file during a simulation, consider the workflow used by PowerSimulations.jl. It creates a custom logger in its build!(Simulation) function and then uses Julia's Logging.with_logger function to temporarily take over the global logger during build() and execute().\n\nThis document describes logging facilities available in the modules that use InfrastructureSystems.jl. The examples assume the following imports:\n\nimport Logging\nimport InfrastructureSystems:\n    configure_logging,\n    open_file_logger,\n    MultiLogger,\n    LogEventTracker,\n    make_logging_config_file,\n    report_log_summary\n\nNote: Packages that depend on InfrastructureSystems.jl already re-export configure_logging, open_file_logger, MultiLogger, LogEventTracker","category":"section"},{"location":"dev_guide/logging/#Use-Cases","page":"Logging","title":"Use Cases","text":"","category":"section"},{"location":"dev_guide/logging/#Enable-logging-in-REPL-or-Jupyter-Notebook","page":"Logging","title":"Enable logging in REPL or Jupyter Notebook","text":"Use InfrastructureSystems.configure_logging to create a logger with your preferences (console and/or file, levels, etc.).\n\nNote: log messages are not automatically flushed to files. Call flush(logger) to make this happen.\n\nExample: Global logger configuration\n\nlogger = configure_logging(; filename = \"log.txt\")\n@info \"hello world\"\nflush(logger)\n@error \"some error\"\nclose(logger)\n\nYou can also configure logging from a configuration file.\n\nmake_logging_config_file(\"logging_config.toml\")\n# Customize in an editor.\nlogger = configure_logging(\"logging_config.toml\")","category":"section"},{"location":"dev_guide/logging/#Enable-debug-logging-for-code-you-are-debugging-but-not-for-noisy-areas-you-don't-care-about.","page":"Logging","title":"Enable debug logging for code you are debugging but not for noisy areas you don't care about.","text":"InfrastructureSystems uses the _group field of a log event to perform additional filtering. All debug log messages that run frequently should have this field defined.\n\nNote that the default value of _group for a log event is its filename. Refer to the Julia docs for more information.\n\nRun this in the REPL to see commonly-used groups in InfrastructureSystems:\n\n@show InfrastructureSystems.LOG_GROUPS\n\nYou can tell InfrastructureSystems to filter out messages from a particular group in two ways:\n\nSpecify the group level in the logging_config.toml file mentioned above and configure logging with it.\nChange the logger dynamically from with Julia. Here is an example:\n\nlogger = configure_logging(; console_level = Logging.Debug)\nInfrastructureSystems.set_group_level!(\n    logger,\n    InfrastructureSystems.LOG_GROUP_TIME_SERIES,\n    Logging.Info,\n)\n\n# Or many at once.\nInfrastructureSystems.set_group_levels!(\n    logger,\n    Dict(\n        InfrastructureSystems.LOG_GROUP_SERIALIZATION => Logging.Info,\n        InfrastructureSystems.LOG_GROUP_TIME_SERIES => Logging.Info,\n    ),\n)\n\n# Get current settings\nInfrastructureSystems.get_group_levels(logger)\nInfrastructureSystems.get_group_level(logger, InfrastructureSystems.LOG_GROUP_TIME_SERIES)","category":"section"},{"location":"dev_guide/logging/#Log-to-console-and-file-in-an-application-or-unit-test-environment","page":"Logging","title":"Log to console and file in an application or unit test environment","text":"Create a MultiLogger from TerminalLoggers.TerminalLogger and Logging.SimpleLogger. Use open_file_logger to guarantee that all messages get flushed to the file.\n\nNote that you can use Logging.ConsoleLogger if you don't have TerminalLoggers installed.\n\nExample Multilogger configuration\n\nconsole_logger = TerminalLogger(stderr, Logging.Error)\n\nopen_file_logger(\"log.txt\", Logging.Info) do file_logger\n    multi_logger = MultiLogger([console_logger, file_logger])\n    global_logger(multi_logger)\n\n    do_stuff()\nend\n\nNote: If someone may execute the code in the REPL then wrap that code in a try/finally block and reset the global logger upon exit.\n\nfunction run_tests()\n    console_logger = TerminalLogger(stderr, Logging.Error)\n\n    open_file_logger(\"log.txt\", Logging.Info) do file_logger\n        multi_logger = MultiLogger([console_logger, file_logger])\n        global_logger(multi_logger)\n\n        do_stuff()\n    end\nend\n\nlogger = global_logger()\n\ntry\n    run_tests()\nfinally\n    # Guarantee that the global logger is reset.\n    global_logger(logger)\n    nothing\nend","category":"section"},{"location":"dev_guide/logging/#Suppress-frequent-messages","page":"Logging","title":"Suppress frequent messages","text":"The standard Logging module in Julia provides a method to suppress messages. Tag the log message with maxlog = X.\n\nfor i in range(1; length = 100)\n    @error \"something happened\" i maxlog = 2\nend\n\nOnly 2 messages will get logged.\n\nThe InfrastructureSystems logger provides a customization to make maxlog apply to a period of time instead of the duration of the Julia process.\n\nIn this example the suppression will timeout and two messages will get logged every five seconds. It will log how many log messages were suppressed on the first message that gets logged after a timeout.\n\nfor i in range(1; length = 100)\n    @error \"something happened\" i maxlog = 2 _suppression_period = 5\n    sleep(0.5)\nend","category":"section"},{"location":"dev_guide/logging/#Get-a-summary-of-log-messages","page":"Logging","title":"Get a summary of log messages","text":"By default a MultiLogger creates a LogEventTracker that keeps counts of all messages. Call report_log_summary after execution.\n\nlogger = configure_logging(; filename = \"log.txt\")\n@info \"hello world\"\n\n# Include a summary in the log file.\n@info report_log_summary(logger)\nclose(logger)\n\nThe output of the logger can be explored in the REPL:\n\nfor i in range(1; length = 100)\n    @info \"hello\" maxlog = 2\n    @warn \"beware\" maxlog = 2\nend\n@info report_log_summary(logger)","category":"section"},{"location":"docs_best_practices/how-to/view_github/#View-Draft-Documentation-on-Github","page":"View Draft Documentation on Github","title":"View Draft Documentation on Github","text":"Create a pull request on Github.\nVerify the Documentation/build check was successful (takes a few minutes).\nPreview it in a browser following this url format:\nhttps://nrel-sienna.github.io/<PACKAGE_NAME>.jl/previews/PR<PULL_REQUEST_NUMBER>/\n\nThis only works if the PR is on the root repository, not a fork. Otherwise, work with a maintainer to move your PR to the root repository.","category":"section"},{"location":"docs_best_practices/how-to/write_a_how-to/#Write-a-How-to-Guide","page":"Write a How-To Guide","title":"Write a How-to Guide","text":"A How-To guides a user trying to accomplish a certain task in their work, or address a problem or series of linked problems.","category":"section"},{"location":"docs_best_practices/how-to/write_a_how-to/#Prepare","page":"Write a How-To Guide","title":"Prepare","text":"If you have not read Diataxis, first read it in its entirety.\nIf you have read it, skim the pages on How-to guides and the difference between a tutorial and how-to guide to refresh your memory and refer back throughout the process.\nLook at an example: this page, how to Compile and View Documentation Locally, and how to Troubleshoot Common Errors are all examples.","category":"section"},{"location":"docs_best_practices/how-to/write_a_how-to/#Follow-the-Do's-and-Don't's","page":"Write a How-To Guide","title":"Follow the Do's and Don't's","text":"The Diataxis How-to's page should be your main reference as you write, but in addition, use these guidelines to ensure we follow Diataxis and avoid common pitfalls from previous versions of Sienna documentation:\n\nPages = [\"write_a_how-to.md\"]\nDepth = 3:3","category":"section"},{"location":"docs_best_practices/how-to/write_a_how-to/#Omit-the-Unnecessary","page":"Write a How-To Guide","title":"Omit the Unnecessary","text":"tip: Do\nJump the user right to a logical starting point in the code using #hide or @setup blocks.\n\ntip: Do\nConfigure the logger or load/build a System that returns very few log statements. Use semi-colons at line ends to hide return statements if need be.","category":"section"},{"location":"docs_best_practices/how-to/write_a_how-to/#Make-it-effortless-to-read","page":"Write a How-To Guide","title":"Make it effortless to read","text":"tip: Do\nSplit code examples into ideally 1 (to 3) lines ONLY, with a short preface to explain what each line is doing, even if it's obvious to you.","category":"section"},{"location":"docs_best_practices/how-to/write_a_how-to/#Move-Docstring-Material-to-the-APIs","page":"Write a How-To Guide","title":"Move Docstring Material to the APIs","text":"An issue with earlier versions of Sienna documentation was basic reference information located in pages other than the APIs. See how-to Organize APIs and Write Docstrings if needed to make that information easier to find.\n\ntip: Do\nPreface each call to a new function with a hyperlink to that function's docstring so the user can find more detail\n\nwarning: Don't\nInclude digressive details about different keyword arguments or versions of a function.","category":"section"},{"location":"docs_best_practices/how-to/write_a_how-to/#Minimize-or-Eliminate-How-To-Guides-with-a-Single-Step","page":"Write a How-To Guide","title":"Minimize or Eliminate How-To Guides with a Single Step","text":"A how-to guide has a sequence of steps â€“ if your guide only has a single step, ask yourself if you are compensating for a lack of information in the API's.\n\ntip: Do\nMove how-to guides with a single function to being Examples in that function's docstring. See Writing Documentation.","category":"section"},{"location":"docs_best_practices/how-to/write_a_how-to/#Remove-Other-Reference-Material","page":"Write a How-To Guide","title":"Remove Other Reference Material","text":"Particularly when editing existing pages, watch out for other Reference material.\n\ntip: Do\nMove tables and lists of information into Reference pages and link to them instead","category":"section"},{"location":"docs_best_practices/how-to/write_a_how-to/#Follow-the-Guidelines-on-Cleaning-Up-General-Formatting","page":"Write a How-To Guide","title":"Follow the Guidelines on Cleaning Up General Formatting","text":"tip: Do\nFollow How-to Clean Up General Formatting.","category":"section"},{"location":"docs_best_practices/how-to/write_a_how-to/#Look-at-the-compiled-.html!","page":"Write a How-To Guide","title":"Look at the compiled .html!","text":"tip: Do\nCompile the how-to guide regularly and look at it\nCheck all code examples gave the expected results without erroring\nCheck for length of the code examples and iteratively adjust to make it easy to read","category":"section"},{"location":"docs_best_practices/reference/useful_links/#Useful-Links","page":"Useful Links","title":"Useful Links","text":"Diataxis: Reference for the new documentation framework Sienna is striving to follow (not specific to Julia)\nJulia's guidance on Writing Documentation\nDocumenter.jl: Julia's documentation package, the Syntax and Showcase pages are especially useful\nDocumenterInterLinks.jl: A helper package for making hyperlinks between packages using Documenter.jl's @extref link syntax, without hardcoded urls that can get out of date\nDocStringExtensions.jl: Another helper package to automate docstrings formatting, including signatures and arguments lists\nSiennaTemplate.jl Git repository: A template for new Sienna packages that includes the required documentation framework.","category":"section"},{"location":"dev_guide/associations_database/#Associations-Database-Schema","page":"Associations Database Schema","title":"Associations Database Schema","text":"note: For Maintainers and Contributors\nThis page documents the internal database schemas used by InfrastructureSystems.jl to manage associations between components and their time series data and supplemental attributes. This information is intended for maintainers and contributors working on the codebase. End users should not need to interact with these databases directly.","category":"section"},{"location":"dev_guide/associations_database/#Overview","page":"Associations Database Schema","title":"Overview","text":"InfrastructureSystems.jl uses SQLite databases to efficiently track associations between:\n\nComponents and Time Series data\nComponents and Supplemental Attributes\n\nThese associations are managed under the hood to enable:\n\nFast lookups of time series and attributes attached to components\nEfficient querying and filtering\nProper lifecycle management (adding, removing, updating references)\nSerialization and deserialization support\n\nThe package maintains two separate databases:\n\nTime Series Metadata Store - tracks time series associations\nSupplemental Attribute Associations - tracks supplemental attribute associations","category":"section"},{"location":"dev_guide/associations_database/#Design-Rationale","page":"Associations Database Schema","title":"Design Rationale","text":"","category":"section"},{"location":"dev_guide/associations_database/#Why-Separate-Databases?","page":"Associations Database Schema","title":"Why Separate Databases?","text":"Time series metadata and supplemental attribute associations are stored in independent SQLite databases rather than different tables in the same database. This design decision is driven by serialization requirements:\n\nBackground:\n\nTime series metadata is always persisted as a SQLite file during serialization\nThe SQLite file is written as an HDF5 dataset in the time series data file\nSerialization produces: system.json, system_metadata.json, and system_time_series.h5\nIf there is no time series in the system, only system.json and system_metadata.json are produced\n\nThe Problem: If supplemental attribute associations were in the same database as time series metadata, and the system had supplemental attributes but no time series, serialization would produce an extra file. The team required that supplemental attribute associations be written to the system JSON file when there is no time series data.\n\nThe Solution: Keeping them as separate databases simplifies the code by avoiding the complexity of temporarily sharing a database across serialization and deepcopy operations. The supplemental attribute database is always ephemeral (in-memory only), while the time series metadata can be persisted.","category":"section"},{"location":"dev_guide/associations_database/#Time-Series-Metadata-Store","page":"Associations Database Schema","title":"Time Series Metadata Store","text":"The TimeSeriesMetadataStore manages associations between time series data and components/supplemental attributes. It uses an in-memory SQLite database for fast access.","category":"section"},{"location":"dev_guide/associations_database/#Database-Tables","page":"Associations Database Schema","title":"Database Tables","text":"","category":"section"},{"location":"dev_guide/associations_database/#1.-time_series_associations-Table","page":"Associations Database Schema","title":"1. time_series_associations Table","text":"This is the primary table that stores the associations between time series data and owners (components or supplemental attributes).\n\nSchema:\n\nColumn Name Type Description\nid INTEGER Primary key, auto-incremented\ntime_series_uuid TEXT UUID of the time series data array\ntime_series_type TEXT Type name of the time series (e.g., \"SingleTimeSeries\", \"Deterministic\")\ninitial_timestamp TEXT ISO 8601 formatted initial timestamp\nresolution TEXT Resolution encoded as ISO 8601 duration\nhorizon TEXT ISO 8601 formatted forecast horizon (NULL for static time series)\ninterval TEXT ISO 8601 formatted forecast interval (NULL for static time series)\nwindow_count INTEGER Number of forecast windows (NULL for static time series)\nlength INTEGER Length of static time series (NULL for forecasts)\nname TEXT User-defined name for the time series\nowner_uuid TEXT UUID of the component or supplemental attribute that owns this\nowner_type TEXT Type name of the owner\nowner_category TEXT Either \"Component\" or \"SupplementalAttribute\"\nfeatures TEXT JSON string of feature key-value pairs for filtering\nscaling_factor_multiplier JSON Optional function for scaling (NULL if not used)\nmetadata_uuid TEXT UUID of the metadata object\nunits TEXT Optional units specification (NULL if not used)\n\nIndexes:\n\nby_c_n_tst_features: Composite index on (owner_uuid, time_series_type, name, resolution, features) - optimized for lookups by component with specific time series parameters\nby_ts_uuid: Index on (time_series_uuid) - optimized for finding all owners of a specific time series\n\nDesign Notes:\n\nThe table supports both static time series and forecasts. Forecast-specific columns (horizon, interval, window_count) are NULL for static time series.\nThe features column stores a JSON string of key-value pairs that can be used for flexible filtering and querying.\nAll Dates.Period values are stored as ISO 8601 strings for portability.\nThe metadata_uuid allows multiple associations to reference the same metadata object (stored in memory).","category":"section"},{"location":"dev_guide/associations_database/#2.-key_value_store-Table","page":"Associations Database Schema","title":"2. key_value_store Table","text":"Stores metadata about the database itself.\n\nSchema:\n\nColumn Name Type Description\nkey TEXT Primary key\nvalue JSON JSON value\n\nCurrent Keys:\n\nversion: Stores the time series metadata format version (currently \"1.0.0\")","category":"section"},{"location":"dev_guide/associations_database/#Common-Queries","page":"Associations Database Schema","title":"Common Queries","text":"The following types of queries are optimized by the indexes:\n\nFind all time series for a component:\nSELECT * FROM time_series_associations WHERE owner_uuid = ?\nFind specific time series by name and type:\nSELECT * FROM time_series_associations \nWHERE owner_uuid = ? AND name = ? AND time_series_type = ?\nFind time series with specific features:\nSELECT * FROM time_series_associations \nWHERE owner_uuid = ? AND features LIKE ?\nFind all owners of a time series:\nSELECT DISTINCT owner_uuid FROM time_series_associations \nWHERE time_series_uuid = ?","category":"section"},{"location":"dev_guide/associations_database/#Migrations","page":"Associations Database Schema","title":"Migrations","text":"The database schema has evolved over time. Migration code handles upgrading from older formats:\n\nv2.3 Migration: Converted from a single metadata table with JSON columns to the current two-table structure\nv2.4 Migration: Converted period storage from integer milliseconds to ISO 8601 strings\n\nMigration functions (_migrate_from_v2_3, _migrate_from_v2_4) are maintained in time_series_metadata_store.jl for backward compatibility.","category":"section"},{"location":"dev_guide/associations_database/#Supplemental-Attribute-Associations","page":"Associations Database Schema","title":"Supplemental Attribute Associations","text":"The SupplementalAttributeAssociations manages associations between supplemental attributes and components. It uses an in-memory SQLite database that is always ephemeral.","category":"section"},{"location":"dev_guide/associations_database/#Database-Table","page":"Associations Database Schema","title":"Database Table","text":"","category":"section"},{"location":"dev_guide/associations_database/#supplemental_attributes-Table","page":"Associations Database Schema","title":"supplemental_attributes Table","text":"Schema:\n\nColumn Name Type Description\nattribute_uuid TEXT UUID of the supplemental attribute\nattribute_type TEXT Type name of the supplemental attribute\ncomponent_uuid TEXT UUID of the component\ncomponent_type TEXT Type name of the component\n\nIndexes:\n\nby_attribute: Composite index on (attribute_uuid, component_uuid, component_type) - optimized for finding components associated with an attribute\nby_component: Composite index on (component_uuid, attribute_uuid, attribute_type) - optimized for finding attributes associated with a component\n\nDesign Notes:\n\nThe schema is simpler than the time series associations because supplemental attributes have less metadata\nBoth attribute and component information is stored to enable bidirectional lookups\nThe indexes support fast queries in both directions (attribute â†’ components and component â†’ attributes)","category":"section"},{"location":"dev_guide/associations_database/#Common-Queries-2","page":"Associations Database Schema","title":"Common Queries","text":"Find all attributes for a component:\nSELECT DISTINCT attribute_uuid FROM supplemental_attributes \nWHERE component_uuid = ?\nFind attributes of a specific type for a component:\nSELECT DISTINCT attribute_uuid FROM supplemental_attributes \nWHERE component_uuid = ? AND attribute_type = ?\nFind all components with an attribute:\nSELECT DISTINCT component_uuid FROM supplemental_attributes \nWHERE attribute_uuid = ?\nCheck if an association exists:\nSELECT attribute_uuid FROM supplemental_attributes \nWHERE attribute_uuid = ? AND component_uuid = ? \nLIMIT 1","category":"section"},{"location":"dev_guide/associations_database/#Performance-Considerations","page":"Associations Database Schema","title":"Performance Considerations","text":"","category":"section"},{"location":"dev_guide/associations_database/#Statement-Caching","page":"Associations Database Schema","title":"Statement Caching","text":"Both database implementations cache compiled SQL statements to avoid the overhead of re-parsing queries. This saves approximately 3-4 microseconds per query.\n\nTimeSeriesMetadataStore maintains a cached_statements dictionary\nSupplementalAttributeAssociations maintains a cached_statements dictionary\nFrequently-used queries benefit most from caching","category":"section"},{"location":"dev_guide/associations_database/#Index-Strategy","page":"Associations Database Schema","title":"Index Strategy","text":"Time Series Metadata:\n\nOptimize for user queries by component/attribute UUID with name, type, and resolution\nOptimize for deduplication checks during add_time_series!\nOptimize for metadata retrieval by time series UUID\n\nSupplemental Attributes:\n\nOptimize for bidirectional lookups (attribute â†” component)\nSupport filtering by type in both directions","category":"section"},{"location":"dev_guide/associations_database/#Database-Location","page":"Associations Database Schema","title":"Database Location","text":"Both databases are in-memory (SQLite.DB()) for performance\nThe time series metadata database can be backed up to disk for serialization\nThe supplemental attribute database is never persisted (associations are stored in JSON during serialization)","category":"section"},{"location":"dev_guide/associations_database/#Serialization-Behavior","page":"Associations Database Schema","title":"Serialization Behavior","text":"","category":"section"},{"location":"dev_guide/associations_database/#Time-Series-Metadata","page":"Associations Database Schema","title":"Time Series Metadata","text":"During serialization:\n\nThe in-memory database is backed up to a temporary file\nIndexes are dropped from the backup (to reduce file size)\nThe database file is written as an HDF5 dataset in system_time_series.h5\n\nDuring deserialization:\n\nThe SQLite database is extracted from the HDF5 file\nIt's loaded into an in-memory database\nIndexes are recreated for performance\nMetadata objects are reconstructed and cached in memory","category":"section"},{"location":"dev_guide/associations_database/#Supplemental-Attribute-Associations-2","page":"Associations Database Schema","title":"Supplemental Attribute Associations","text":"During serialization:\n\nAll associations are extracted as records (tuples of UUIDs and types)\nRecords are written to the JSON file\n\nDuring deserialization:\n\nRecords are read from the JSON file\nA new in-memory database is created\nRecords are bulk-inserted using executemany for efficiency\nIndexes are created","category":"section"},{"location":"dev_guide/associations_database/#Implementation-Files","page":"Associations Database Schema","title":"Implementation Files","text":"Time Series Metadata Store: src/time_series_metadata_store.jl\nSupplemental Attribute Associations: src/supplemental_attribute_associations.jl\nSQLite Utilities: src/utils/sqlite.jl","category":"section"},{"location":"dev_guide/associations_database/#Debugging-and-Inspection","page":"Associations Database Schema","title":"Debugging and Inspection","text":"","category":"section"},{"location":"dev_guide/associations_database/#Querying-the-Databases","page":"Associations Database Schema","title":"Querying the Databases","text":"Both stores provide a sql() function for running custom queries:\n\n# Query time series associations\ndf = InfrastructureSystems.sql(\n    store,\n    \"SELECT * FROM time_series_associations WHERE owner_type = 'Generator'\",\n)\n\n# Query supplemental attribute associations  \ndf = InfrastructureSystems.sql(\n    associations,\n    \"SELECT * FROM supplemental_attributes WHERE component_type = 'Bus'\",\n)","category":"section"},{"location":"dev_guide/associations_database/#Viewing-as-DataFrames","page":"Associations Database Schema","title":"Viewing as DataFrames","text":"# Time series associations as DataFrame\ndf = InfrastructureSystems.to_dataframe(store)\n\n# Supplemental attributes as records\nrecords = InfrastructureSystems.to_records(associations)","category":"section"},{"location":"dev_guide/associations_database/#Summary-Functions","page":"Associations Database Schema","title":"Summary Functions","text":"Both stores provide summary functions:\n\n# Time series summaries\ncounts = InfrastructureSystems.get_time_series_counts(store)\nsummary_table = InfrastructureSystems.get_forecast_summary_table(store)\n\n# Supplemental attribute summaries\nsummary_table = InfrastructureSystems.get_attribute_summary_table(associations)\nnum_attrs = InfrastructureSystems.get_num_attributes(associations)","category":"section"},{"location":"dev_guide/associations_database/#Best-Practices-for-Developers","page":"Associations Database Schema","title":"Best Practices for Developers","text":"Use Transactions: When making multiple related changes, wrap them in a SQLite transaction for atomicity and performance\nLeverage Indexes: Design queries to take advantage of the existing indexes. Check query plans if performance is a concern.\nCache Statements: For frequently-executed queries, use the cached statement methods (_execute_cached) rather than creating new statements each time\nValidate Migrations: When modifying the schema, ensure migration code is added and tested with data from older versions\nTest with Large Datasets: Performance characteristics can change significantly with large numbers of associations. Test with realistic data sizes.\nHandle Edge Cases: Consider abstract types, subtypes, and empty result sets in query logic\nMaintain Consistency: When adding/removing associations, ensure both the database and any in-memory caches (like metadata_uuids in TimeSeriesMetadataStore) are updated together","category":"section"},{"location":"dev_guide/associations_database/#Future-Considerations","page":"Associations Database Schema","title":"Future Considerations","text":"Potential areas for enhancement:\n\nQuery Optimization: Profile and optimize hot paths, especially for large systems\nSchema Versioning: Maintain a clear versioning strategy as the schema evolves\nPartial Indexes: Consider partial indexes for common filtered queries\nBulk Operations: Optimize bulk insert/delete operations for large datasets\nForeign Keys: Currently not used; could add foreign key constraints for data integrity if needed\nFull-Text Search: For advanced filtering on text fields like name or features","category":"section"},{"location":"dev_guide/time_series/#Time-Series-Data","page":"Time Series Data","title":"Time Series Data","text":"InfrastructureSystems.jl implements containers and routines to efficiently manage time series data. This document contains content for developers of new time series data. For the usage please refer to the documentation in PowerSystems.jl.\n\nInfrastructureSystems.jl provides a mechanism to store time series data for components. Here are reasons to consider using it:\n\nTime series data, by default, is stored independently of components in HDF5 files. Components store references to that data.\nSystem memory is not depleted by loading all time series data at once. Only data that you need is loaded.\nMultiple components can share the same time series data by sharing references instead of making expensive copies.\nSupports serialization and deserialization.\nSupports parsing raw data files of several formats as well as data stored in TimeSeries.TimeArray and DataFrames.DataFrame objects.\n\nYour package must reimplement a deepcopy method if you use HDF5 storage for TimeSeriesData.\n\nIf you store an instance of InfrastructureSystems.SystemData within your system and then a user calls deepcopy on a system, the .h5 file will not be copied. The new and old instances will have references to the same file. You will need to reimplement deepcopy to handle this. One solution is to serialize and then deserialize the system.\n\nNotes:\n\nTime series data can optionally be stored fully in memory. Refer to the InfrastructureSystems.SystemData documentation.\nInfrastructureSystems.jl creates HDF5 files on the tmp filesystem by default, using the location obtained from tempdir(). This can be changed if the time series data is larger than the amount of tmp space available. Refer to the InfrastructureSystems.SystemData link above.\nBy default, the call to add_time_series! will open the .h5 file, write the data to the file, and close the file. Opening and closing the file has overhead. If you will add thousands of time series arrays, consider using open_time_series_store! to add all the arrays with one file handle.","category":"section"},{"location":"dev_guide/time_series/#Instructions","page":"Time Series Data","title":"Instructions","text":"Ensure that supports_time_series(::MyComponent) returns true for the struct. It may be implemented on a supertype of the struct.","category":"section"},{"location":"dev_guide/time_series/#Data-Format","page":"Time Series Data","title":"Data Format","text":"Time series arrays are stored in an HDF5 file according the format described here.\n\nThe root path /time_series defines these HDF5 attributes to control deserialization:\n\ndata_format_version: Designates the InfrastructureSystems format for the file.\ncompression_enabled: Specifies whether compression is enabled and will be used for new time series.\ncompression_type: Specifies the type of compression being used.\ncompression_level: Specifies the level of compression being used.\ncompression_shuffle: Specifies whether the shuffle filter is being used.\n\nEach time series array is stored in an HDF5 group named with the array's UUID. Each group contains a dataset called data which contains the actual data. Each group also contains a group called component_references which contains an HDF5 attribute for each component reference. The component reference uses the format <component_uuid>__<time_series_name>.\n\nEach time series group defines attributes that control how the data will be deserialized into a TimeSeriesData instance.\n\ninitial_timestamp: Defines the first timestamp of the array. (All times are not stored.)\nresolution: Resolution of the time series in milliseconds.\ntype: Type of the time series. Subtype of TimeSeriesData.\nmodule: Module that defines the type of the time series.\ndata_type: Describes the type of the array stored.\n\nExample:\n\n/time_series\n    data_format_version = \"1.0.1\"\n    compression_enabled = 1\n    /9f02f706-3394-4af3-8084-8903d302cbba\n        /component_references\n            0b6ecb61-8e8d-4563-b795-f001246c3ea5__max_active_power\n            613ddbc2-b666-4c9d-adb5-fa69e7f40a95__max_active_power\n        /data","category":"section"},{"location":"dev_guide/time_series/#Debugging","page":"Time Series Data","title":"Debugging","text":"The HDF Group provides tools to inspect and manipulate files. Refer to their website.\n\nHDFView is especially useful for viewing data. Note that using h5ls and h5dump in a terminal combined with UNIX tools like grep can sometimes be faster.","category":"section"},{"location":"dev_guide/time_series/#Maintenance","page":"Time Series Data","title":"Maintenance","text":"If you delete time series arrays in your system you may notice that the actual size of the HDF5 does not decrease. The only way to recover this space is to build a new file with only the active objects. The HDF5 tools package provides the tool h5repack for this purpose.\n\n$ h5repack time_series.h5 new.h5\n$ mv new.h5 time_series.h5","category":"section"},{"location":"#InfrastructureSystems.jl","page":"Welcome Page","title":"InfrastructureSystems.jl","text":"","category":"section"},{"location":"#Overview","page":"Welcome Page","title":"Overview","text":"InfrastructureSystems.jl is a Julia package that provides data management services and common utility software for the packages in NLR's Sienna Initiative. This package is meant for module development. It is used primarily by PowerSystems.jl and PowerSimulations.jl but is written to be extensible for other kinds of infrastructure models.\n\nThis document describes how to integrate it with other packages.","category":"section"},{"location":"#Installation","page":"Welcome Page","title":"Installation","text":"The latest stable release of InfrastructureSystems.jl can be installed using the Julia package manager with\n\n] add InfrastructureSystems\n\nFor the current development version, \"checkout\" this package with\n\n] add InfrastructureSystems#main","category":"section"},{"location":"#Usage","page":"Welcome Page","title":"Usage","text":"InfrastructureSystems.jl does not export any method or struct by design. For detailed use of InfrastructureSystems.jl visit the API section of the documentation.\n\nInfrastructureSystems.jl provides several utilities for the development of packages, the documentation includes several guides for developers\n\nPages = [\n        \"dev_guide/components_and_container.md\",\n        \"dev_guide/auto_generation.md\",\n        \"dev_guide/time_series.md\",\n        \"dev_guide/recorder.md\",\n        \"dev_guide/tests.md\",\n        \"dev_guide/logging.md\"\n]\nDepth = 1\n\n\n\nInfrastructureSystems has been developed as part of the Scalable Integrated Infrastructure Planning (SIIP) initiative at the U.S. Department of Energy's National Laboratory of the Rockies (NLR, formerly NREL)","category":"section"},{"location":"docs_best_practices/how-to/general_formatting/#Clean-Up-General-Formatting","page":"Clean Up General Formatting","title":"Clean Up General Formatting","text":"These recommendations are to make navigating our documentation effortless for users, while addressing common markdown formatting issues in the existing Sienna documentation:","category":"section"},{"location":"docs_best_practices/how-to/general_formatting/#Format-in-back-ticks","page":"Clean Up General Formatting","title":"Format in back-ticks","text":"All package names, types, functions, methods, and parameters, etc. should formatted in back-ticks:\n\ntip: Do\n`max_active_power`compiles as max_active_power\n\nwarning: Don't\nmax_active_powercompiles as maxactivepower","category":"section"},{"location":"docs_best_practices/how-to/general_formatting/#hyperlinks","page":"Clean Up General Formatting","title":"Put hyperlinks everywhere","text":"All types, function, and methods should have hyperlinks to the correct docstring, accounting for multiple methods of the same name due to Julia's multiple dispatch. Documenter.jl will link to the first occurrance in documentation. If that's not the one you're referring to, copy the entire signature with types into the hyperlink reference.\n\ntip: Do\n[`get_time_series_values`](@ref)Or[`get_time_series_values` from a `ForecastCache`](@ref get_time_series_values(\nowner::TimeSeriesOwners,\nforecast::Forecast,\nstart_time::Dates.DateTime;\nlen::Union{Nothing, Int} = nothing,\nignore_scaling_factors = false,\n))\n\nwarning: Don't\n`get_time_series_values`Orget_time_series_values\n\ntip: Do\nDefine hyperlinks to other packages with an @extref reference, rather than hard-coded references which might change, using DocumenterInterLinks.jl:[`PowerSystems.System`](@extref)compiles as PowerSystems.System. See Declaring External Projects for help setting up a connection to a new package for the first time.","category":"section"},{"location":"docs_best_practices/how-to/general_formatting/#Add-links-to-other-Sienna-packages","page":"Clean Up General Formatting","title":"Add links to other Sienna packages","text":"All other Sienna package names should have documentation (not Git repo) hyperlinks:\n\ntip: Do\n[`PowerSystems.jl`](https://nrel-sienna.github.io/PowerSystems.jl/stable/)\n\nwarning: Don't\n`PowerSystems.jl`OrPSYOr[`PowerSystems.jl`](https://github.com/NREL-Sienna/PowerSystems.jl)","category":"section"}]
}
