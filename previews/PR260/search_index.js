var documenterSearchIndex = {"docs":
[{"location":"style/#style_guide","page":"Style Guide","title":"Julia Coding Style Guide for SIIP","text":"","category":"section"},{"location":"style/#Goals","page":"Style Guide","title":"Goals","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Define a straightforward set of rules that lead to consistent, readable code.\nDevelopers focus on producing high quality code, not how to format it.","category":"page"},{"location":"style/#Base","page":"Style Guide","title":"Base","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Follow the official","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Julia style guide except for deviations noted here.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Follow Julia contribution guidelines,","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"notably its line length limit.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Follow Julia guidelines for docstrings.\nFollow JuMP coding standards,","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"including its deviations from the Julia style guide.  In particular, note its policies on","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"whitespace\nreturn statements\nvariable names.\nRead The Zen of Python.\nConsider using a plugin that configures your text editor to use EditorConfig settings.","category":"page"},{"location":"style/#Code-Organization","page":"Style Guide","title":"Code Organization","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Import standard modules, then 3rd-party modules, then yours. Include a blank line between","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"each group.","category":"page"},{"location":"style/#Module","page":"Style Guide","title":"Module","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"When writing a module locate all the exports in the main module file.\nPlease include a copy of this .gitignore file","category":"page"},{"location":"style/#Comments","page":"Style Guide","title":"Comments","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Use comments to describe non-obvious or non-trivial aspects of code.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Describe why something was done but not how.  The \"how\" should be apparent from the code itself.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Use complete sentences and proper grammar.\nInclude a space in between the \"#\" and the first word of the comment.\nUse these tags in comments to describe known work:\nTODO:  tasks that need to be done\nFIXME:  code that needs refactoring\nBUG:  known bug that exists. Should include a bug ID and tracking system.\nPERF:  known performance limitation that needs improvement","category":"page"},{"location":"style/#Constructors","page":"Style Guide","title":"Constructors","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Per guidance from Julia documentation, use inner constructors to enforce","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"restrictions on parameters or to allow construction of self-referential objects. Use outer constructors to provide default values or to perform customization.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Document the reason why the outer constructor is different.\nNote that the compiler will provide a default constructor with all struct","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"members if no inner constructor is defined.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"When creating a constructor use function Foo() instead of Foo() = ...","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"One exception is the case where one file has all single-line functions.","category":"page"},{"location":"style/#Exceptions","page":"Style Guide","title":"Exceptions","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Use exceptions for unexpected errors and not for normal error handling.\nDetection of an unsupported data format from a user should likely throw","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"an exception and terminate the application.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Do not use try/catch to handle retrieving a potentially-missing key from a","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"dictionary.","category":"page"},{"location":"style/#Asserts","page":"Style Guide","title":"Asserts","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Use @assert statements to guard against programming errors. Do not use them","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"after detecting bad user input. An assert tripping should indicate that there is a bug in the code. Note that they may be compiled out in optimized builds in the future.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Consider using InfrastructureSystems.@assert_op instead of the standard","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"@assert because it will automatically print the value of the expression. Unlike the standard @assert the Julia compiler will never exclude @assert_op in optimized builds.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"julia> a = 3; b = 4;\njulia> @assert_op a == b\nERROR: AssertionError: 3 == 4","category":"page"},{"location":"style/#Globals","page":"Style Guide","title":"Globals","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Global constants should use UPPER_CASE and be declared const.\nIf global variables are needed, prefix them with g_.\nDon't use magic numbers. Instead, define const globals or Enums (Julia @enum).","category":"page"},{"location":"style/#One-line-Conditionals","page":"Style Guide","title":"One-line Conditionals","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Julia code base uses this idiom frequently:  <cond> && <statement> Example:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"    function fact(n::Int)\n       n >= 0 || error(\"n must be non-negative\")\n       n == 0 && return 1\n       n * fact(n-1)\n    end","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"This is acceptable for simple code as in this example. However, in general, prefer to write out an entire if statement.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Ternary operators provide a way to write clean, concise code.  Use good judgement.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"    y = x > 0 ? x : -x","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"There are many examples in our codebase that use the form <cond> ? <statement> : <statement>. These can be expressed much more clearly in an if/else statement.","category":"page"},{"location":"style/#Logging","page":"Style Guide","title":"Logging","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"When adding a debug log statement consider whether it is appropriate to append _group = <some-name>. The packages use this Julia feature to suppress debug logging of entire groups at once.  InfrastructureSystems defines LOG_GROUPS with commonly-used group names.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"If you are developing a feature with functionality in a single file then you can let Julia use the default name (the base name of the file). However, if the feature spans files then you should use an existing group or add a new one. Group names should be of type Symbol and follow the PascalCase naming convention.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Common group names should be defined in InfrastructureSystems but packages can add their own as needed.","category":"page"},{"location":"style/#Unit-Tests","page":"Style Guide","title":"Unit Tests","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"All code should be tested. The packages in SIIP have a minimum of 70% coverage to be merged into master. This functionality is provided using Codecov","category":"page"},{"location":"style/#Whitespace","page":"Style Guide","title":"Whitespace","text":"","category":"section"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"If many function arguments cause the line length to be exceeded, put one","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"argument per line. In some cases it may make sense to pair some variables on the same line.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"    function foo(\n                 var1::String,\n                 var2::String,\n                 var3::String,\n                 var4::String,\n                 var5::String,\n                 var6::String,\n                 )","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Do not surround equal signs with spaces when passing keyword args to a","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"function or defining default values in function declarations.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Do not right-align equal signs when assigning groups of variables. It causes","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"unnecessary changes whenever someone adds a new variable with a longer name.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"    x   = 1\n    foo = 2","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"    x = 1\n    foo = 2","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Define abstract types on one line. Given the lack of IDE support for Julia,","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"this makes it easier to find type definitions.","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"    abstract type\n        Foo\n    end","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"    abstract type Foo end","category":"page"},{"location":"style/","page":"Style Guide","title":"Style Guide","text":"All SIIP packages perform tests using JuliaFormatter if you are unsure of your format, you can run julia  -e 'using JuliaFormatter; include(\".github/workflows/formatter_code.jl\")' at the root of the package. Make sure to have the latest version of JuliaFormatter in your main environment","category":"page"},{"location":"InfrastructureSystems/#API_ref","page":"API","title":"InfrastructureSystems API Reference","text":"","category":"section"},{"location":"InfrastructureSystems/","page":"API","title":"API","text":"Modules = [InfrastructureSystems]","category":"page"},{"location":"InfrastructureSystems/#InfrastructureSystems.CompressionSettings","page":"API","title":"InfrastructureSystems.CompressionSettings","text":"Provides customization of HDF5 compression settings. Refer to the HDF5.jl and HDF5 documention for more information.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.DataFormatError","page":"API","title":"InfrastructureSystems.DataFormatError","text":"Thrown upon detection of user data that is not supported.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.Deterministic","page":"API","title":"InfrastructureSystems.Deterministic","text":"mutable struct Deterministic <: AbstractDeterministic\n    name::String\n    data::Union{\n        SortedDict{Dates.DateTime, Vector{CONSTANT}},\n        SortedDict{Dates.DateTime, Vector{POLYNOMIAL}},\n        SortedDict{Dates.DateTime, Vector{PWL}},\n    }\n    resolution::Dates.Period\n    scaling_factor_multiplier::Union{Nothing, Function}\n    internal::InfrastructureSystemsInternal\nend\n\nA deterministic forecast for a particular data field in a Component.\n\nArguments\n\nname::String: user-defined name\ndata::Union{SortedDict{Dates.DateTime, Vector{CONSTANT}}, SortedDict{Dates.DateTime, Vector{POLYNOMIAL}}, SortedDict{Dates.DateTime, Vector{PWL}}}: timestamp - scalingfactor\nresolution::Dates.Period: forecast resolution\nscaling_factor_multiplier::Union{Nothing, Function}: Applicable when the time series data are scaling factors. Called on the associated component to convert the values.\ninternal::InfrastructureSystemsInternal\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.Deterministic-Tuple{AbstractString,AbstractDict{Dates.DateTime,#s63} where #s63<:TimeSeries.TimeArray}","page":"API","title":"InfrastructureSystems.Deterministic","text":"Deterministic(name::AbstractString, input_data::AbstractDict{Dates.DateTime,#s63} where #s63<:TimeSeries.TimeArray; normalization_factor, scaling_factor_multiplier) -> InfrastructureSystems.Deterministic\n\n\nConstruct Deterministic from a Dict of TimeArrays.\n\nArguments\n\nname::AbstractString: user-defined name\ninput_data::AbstractDict{Dates.DateTime, TimeSeries.TimeArray}: time series data.\nnormalization_factor::NormalizationFactor = 1.0: optional normalization factor to apply to each data entry\nscaling_factor_multiplier::Union{Nothing, Function} = nothing: If the data are scaling factors then this function will be called on the component and applied to the data when get_time_series_array is called.\ntimestamp = :timestamp: If the values are DataFrames is passed then this must be the column name that contains timestamps.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Deterministic-Tuple{AbstractString,AbstractString,InfrastructureSystems.InfrastructureSystemsComponent,Dates.Period}","page":"API","title":"InfrastructureSystems.Deterministic","text":"Deterministic(name::AbstractString, filename::AbstractString, component::InfrastructureSystems.InfrastructureSystemsComponent, resolution::Dates.Period; normalization_factor, scaling_factor_multiplier) -> InfrastructureSystems.Deterministic\n\n\nConstruct Deterministic from a CSV file. The first column must be a timestamp in DateTime format and the columns the values in the forecast window.\n\nArguments\n\nname::AbstractString: user-defined name\nfilename::AbstractString: name of CSV file containing data\ncomponent::InfrastructureSystemsComponent: component associated with the data\nnormalization_factor::NormalizationFactor = 1.0: optional normalization factor to apply to each data entry\nscaling_factor_multiplier::Union{Nothing, Function} = nothing: If the data are scaling factors then this function will be called on the component and applied to the data when get_time_series_array is called.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Deterministic-Tuple{AbstractString,InfrastructureSystems.RawTimeSeries,Dates.Period}","page":"API","title":"InfrastructureSystems.Deterministic","text":"Deterministic(name::AbstractString, series_data::InfrastructureSystems.RawTimeSeries, resolution::Dates.Period; normalization_factor, scaling_factor_multiplier) -> InfrastructureSystems.Deterministic\n\n\nConstruct Deterministic from RawTimeSeries.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Deterministic-Tuple{InfrastructureSystems.Deterministic,Any}","page":"API","title":"InfrastructureSystems.Deterministic","text":"Deterministic(forecast::InfrastructureSystems.Deterministic, data) -> InfrastructureSystems.Deterministic\n\n\nConstruct a new Deterministic from an existing instance and a subset of data.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.DeterministicMetadata","page":"API","title":"InfrastructureSystems.DeterministicMetadata","text":"mutable struct DeterministicMetadata <: ForecastMetadata\n    name::String\n    resolution::Dates.Period\n    initial_timestamp::Dates.DateTime\n    interval::Dates.Period\n    count::Int\n    time_series_uuid::UUIDs.UUID\n    horizon::Int\n    time_series_type::Type{<:AbstractDeterministic}\n    scaling_factor_multiplier::Union{Nothing, Function}\n    internal::InfrastructureSystemsInternal\nend\n\nA deterministic forecast for a particular data field in a Component.\n\nArguments\n\nname::String: user-defined name\nresolution::Dates.Period\ninitial_timestamp::Dates.DateTime: time series availability time\ninterval::Dates.Period: time step between forecast windows\ncount::Int: number of forecast windows\ntime_series_uuid::UUIDs.UUID: reference to time series data\nhorizon::Int: length of this time series\ntime_series_type::Type{<:AbstractDeterministic}: Type of the time series data associated with this metadata.\nscaling_factor_multiplier::Union{Nothing, Function}: Applicable when the time series data are scaling factors. Called on the associated component to convert the values.\ninternal::InfrastructureSystemsInternal\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.DeterministicSingleTimeSeries","page":"API","title":"InfrastructureSystems.DeterministicSingleTimeSeries","text":"mutable struct DeterministicSingleTimeSeries <: AbstractDeterministic\n    single_time_series::SingleTimeSeries\n    initial_timestamp::Dates.DateTime\n    interval::Dates.Period\n    count::Int\n    horizon::Int\nend\n\nA deterministic forecast for a particular data field in a Component that wraps a SingleTimeSeries.\n\nArguments\n\nsingle_time_series::SingleTimeSeries: wrapped SingleTimeSeries object\ninitial_timestamp::Dates.DateTime: time series availability time\ninterval::Dates.Period: time step between forecast windows\ncount::Int: number of forecast windows\nhorizon::Int: length of this time series\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.DeviceParameter","page":"API","title":"InfrastructureSystems.DeviceParameter","text":"Base type for auxillary structs. These should not be stored in a system.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.FileLogger","page":"API","title":"InfrastructureSystems.FileLogger","text":"Specializes the behavior of SimpleLogger by adding timestamps and process and thread IDs.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.FlattenIteratorWrapper","page":"API","title":"InfrastructureSystems.FlattenIteratorWrapper","text":"Wrapper around Iterators.Flatten to provide total length.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.ForecastCache-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.InfrastructureSystemsComponent,AbstractString}} where T<:InfrastructureSystems.Forecast","page":"API","title":"InfrastructureSystems.ForecastCache","text":"Construct ForecastCache to automatically control caching of forecast data. Maintains some count of forecast windows in memory based on cache_size_bytes.\n\nCall Base.iterate or get_next_time_series_array! to retrieve data.\n\nArguments\n\n::Type{T}: subtype of Forecast\ncomponent::InfrastructureSystemsComponent: component\nname::AbstractString: forecast name\nstart_time::Union{Nothing, Dates.DateTime} = nothing: forecast start time\nhorizon::Union{Nothing, Int} = nothing: forecast horizon\ncache_size_bytes = TIME_SERIES_CACHE_SIZE_BYTES: maximum size of data to keep in memory\nignore_scaling_factors = false: controls whether to ignore scaling_factor_multiplier in the time series instance\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Hdf5TimeSeriesStorage","page":"API","title":"InfrastructureSystems.Hdf5TimeSeriesStorage","text":"Stores all time series data in an HDF5 file.\n\nThe file used is assumed to be temporary and will be automatically deleted when there are no more references to the storage object.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.Hdf5TimeSeriesStorage-Tuple{Bool}","page":"API","title":"InfrastructureSystems.Hdf5TimeSeriesStorage","text":"Hdf5TimeSeriesStorage(create_file::Bool; filename, directory, read_only, compression) -> InfrastructureSystems.Hdf5TimeSeriesStorage\n\n\nConstructs Hdf5TimeSeriesStorage.\n\nArguments\n\ncreate_file::Bool: create new file\nfilename=nothing: if nothing, create a temp file, else use this name.\ndirectory=nothing: if set and filename is nothing, create a temp file in this  directory. Use tempdir() if not set. This should be set if the time series data is larger  than the tmp filesystem can hold.\nread_only = false: If true, don't allow changes to the file. Allows simultaneous read  access.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Hdf5TimeSeriesStorage-Tuple{}","page":"API","title":"InfrastructureSystems.Hdf5TimeSeriesStorage","text":"Hdf5TimeSeriesStorage() -> InfrastructureSystems.Hdf5TimeSeriesStorage\n\n\nConstructs Hdf5TimeSeriesStorage by creating a temp file.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.InMemoryTimeSeriesStorage","page":"API","title":"InfrastructureSystems.InMemoryTimeSeriesStorage","text":"Stores all time series data in memory.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.InMemoryTimeSeriesStorage-Tuple{InfrastructureSystems.Hdf5TimeSeriesStorage}","page":"API","title":"InfrastructureSystems.InMemoryTimeSeriesStorage","text":"InMemoryTimeSeriesStorage(hdf5_storage::InfrastructureSystems.Hdf5TimeSeriesStorage) -> InfrastructureSystems.InMemoryTimeSeriesStorage\n\n\nConstructs InMemoryTimeSeriesStorage from an instance of Hdf5TimeSeriesStorage.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.InfrastructureSystemsComponent","text":"Base type for structs that are stored in a system.\n\nRequired interface functions for subtypes:\n\nget_name()\nget_internal()\n\nOptional interface functions:\n\ngettimeseries_container()\n\nSubtypes may contain time series.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.InfrastructureSystemsInternal","page":"API","title":"InfrastructureSystems.InfrastructureSystemsInternal","text":"Internal storage common to InfrastructureSystems types.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.InfrastructureSystemsInternal-Tuple{Base.UUID}","page":"API","title":"InfrastructureSystems.InfrastructureSystemsInternal","text":"InfrastructureSystemsInternal(u::Base.UUID) -> InfrastructureSystems.InfrastructureSystemsInternal\n\n\nCreates InfrastructureSystemsInternal with an existing UUID.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.InfrastructureSystemsInternal-Tuple{}","page":"API","title":"InfrastructureSystems.InfrastructureSystemsInternal","text":"InfrastructureSystemsInternal(; uuid, units_info, ext) -> InfrastructureSystems.InfrastructureSystemsInternal\n\n\nCreates InfrastructureSystemsInternal with a new UUID.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.InfrastructureSystemsType","page":"API","title":"InfrastructureSystems.InfrastructureSystemsType","text":"Base type for any struct in the SIIP packages. All structs must implement a kwarg-only constructor to allow deserializing from a Dict.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.LazyDictFromIterator-Union{Tuple{V}, Tuple{K}, Tuple{Type{K},Type{V},Any,Function}} where V where K","page":"API","title":"InfrastructureSystems.LazyDictFromIterator","text":"LazyDictFromIterator creates a dictionary from an iterator, but only increments the iterator and adds items to the dictionary as it needs them. In the worst case it is identical to creating a dictionary by iterating over the entire list. Each V should have a K member.\n\nArguments\n\nK: type of the dictionary keys\nV: type of the dictionary values\niter: any object implementing the Iterator interface\ngetter::Function: method to call on V to get its K\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.LogEvent","page":"API","title":"InfrastructureSystems.LogEvent","text":"Contains information describing a log event.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.LogEventTracker","page":"API","title":"InfrastructureSystems.LogEventTracker","text":"LogEventTracker() -> InfrastructureSystems.LogEventTracker\nLogEventTracker(levels) -> InfrastructureSystems.LogEventTracker\n\n\nTracks counts of all log events by level.\n\nExamples\n\nLogEventTracker()\nLogEventTracker((Logging.Info, Logging.Warn, Logging.Error))\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.MultiLogger","page":"API","title":"InfrastructureSystems.MultiLogger","text":"Redirects log events to multiple loggers. The primary use case is to allow logging to both a file and the console. Secondarily, it can track the counts of all log messages.\n\nExample\n\nMultiLogger([ConsoleLogger(stderr), SimpleLogger(stream)], LogEventTracker())\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.MultiLogger-Union{Tuple{Array{T,N} where N}, Tuple{T}} where T<:Base.CoreLogging.AbstractLogger","page":"API","title":"InfrastructureSystems.MultiLogger","text":"MultiLogger(loggers::Array{T<:Base.CoreLogging.AbstractLogger,N} where N) -> InfrastructureSystems.MultiLogger\n\n\nCreates a MultiLogger with no event tracking.\n\nExample\n\nMultiLogger([ConsoleLogger(stderr), SimpleLogger(stream)])\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Probabilistic","page":"API","title":"InfrastructureSystems.Probabilistic","text":"mutable struct Probabilistic <: Forecast\n    name::String\n    resolution::Dates.Period\n    percentiles::Vector{Float64}\n    data::Union{\n        SortedDict{Dates.DateTime, Matrix{CONSTANT}},\n        SortedDict{Dates.DateTime, Matrix{POLYNOMIAL}},\n        SortedDict{Dates.DateTime, Matrix{PWL}},\n    }\n    scaling_factor_multiplier::Union{Nothing, Function}\n    internal::InfrastructureSystemsInternal\nend\n\nA Probabilistic forecast for a particular data field in a Component.\n\nArguments\n\nname::String: user-defined name\nresolution::Dates.Period: forecast resolution\npercentiles::Vector{Float64}: Percentiles for the probabilistic forecast\ndata::Union{SortedDict{Dates.DateTime, Matrix{CONSTANT}}, SortedDict{Dates.DateTime, Matrix{POLYNOMIAL}}, SortedDict{Dates.DateTime, Matrix{PWL}}}: timestamp - scalingfactor\nscaling_factor_multiplier::Union{Nothing, Function}: Applicable when the time series data are scaling factors. Called on the associated component to convert the values.\ninternal::InfrastructureSystemsInternal\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.Probabilistic-Tuple{AbstractString,AbstractDict,Array{T,1} where T,Dates.Period}","page":"API","title":"InfrastructureSystems.Probabilistic","text":"Probabilistic(name::AbstractString, input_data::AbstractDict, percentiles::Array{T,1} where T, resolution::Dates.Period; normalization_factor, scaling_factor_multiplier) -> InfrastructureSystems.Probabilistic\n\n\nConstruct Probabilistic from a SortedDict of Arrays.\n\nArguments\n\nname::AbstractString: user-defined name\ninput_data::AbstractDict{Dates.DateTime, Matrix{Float64}}: time series data.\npercentiles: Percentiles represented in the probabilistic forecast\nresolution::Dates.Period: The resolution of the forecast in Dates.Period`\nnormalization_factor::NormalizationFactor = 1.0: optional normalization factor to apply to each data entry\nscaling_factor_multiplier::Union{Nothing, Function} = nothing: If the data are scaling factors then this function will be called on the component and applied to the data when get_time_series_array is called.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Probabilistic-Tuple{AbstractString,AbstractDict{Dates.DateTime,#s63} where #s63<:TimeSeries.TimeArray,Array{Float64,1}}","page":"API","title":"InfrastructureSystems.Probabilistic","text":"Probabilistic(name::AbstractString, input_data::AbstractDict{Dates.DateTime,#s63} where #s63<:TimeSeries.TimeArray, percentiles::Array{Float64,1}; normalization_factor, scaling_factor_multiplier) -> InfrastructureSystems.Probabilistic\n\n\nConstruct Probabilistic from a Dict of TimeArrays.\n\nArguments\n\nname::AbstractString: user-defined name\ninput_data::AbstractDict{Dates.DateTime, TimeSeries.TimeArray}: time series data.\npercentiles: Percentiles represented in the probabilistic forecast\nnormalization_factor::NormalizationFactor = 1.0: optional normalization factor to apply to each data entry\nscaling_factor_multiplier::Union{Nothing, Function} = nothing: If the data are scaling factors then this function will be called on the component and applied to the data when get_time_series_array is called.\ntimestamp = :timestamp: If the values are DataFrames is passed then this must be the column name that contains timestamps.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Probabilistic-Tuple{AbstractString,InfrastructureSystems.RawTimeSeries,Array{T,1} where T,Dates.Period}","page":"API","title":"InfrastructureSystems.Probabilistic","text":"Probabilistic(name::AbstractString, series_data::InfrastructureSystems.RawTimeSeries, percentiles::Array{T,1} where T, resolution::Dates.Period; normalization_factor, scaling_factor_multiplier) -> InfrastructureSystems.Probabilistic\n\n\nConstruct Deterministic from RawTimeSeries.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.ProbabilisticMetadata","page":"API","title":"InfrastructureSystems.ProbabilisticMetadata","text":"mutable struct ProbabilisticMetadata <: ForecastMetadata\n    name::String\n    initial_timestamp::Dates.DateTime\n    resolution::Dates.Period\n    interval::Dates.Period\n    count::Int\n    percentiles::Vector{Float64}\n    time_series_uuid::UUIDs.UUID\n    horizon::Int\n    scaling_factor_multiplier::Union{Nothing, Function}\n    internal::InfrastructureSystemsInternal\nend\n\nA Probabilistic forecast for a particular data field in a Component.\n\nArguments\n\nname::String: user-defined name\ninitial_timestamp::Dates.DateTime: time series availability time\nresolution::Dates.Period\ninterval::Dates.Period: time step between forecast windows\ncount::Int: number of forecast windows\npercentiles::Vector{Float64}: Percentiles for the probabilistic forecast\ntime_series_uuid::UUIDs.UUID: reference to time series data\nhorizon::Int: length of this time series\nscaling_factor_multiplier::Union{Nothing, Function}: Applicable when the time series data are scaling factors. Called on the associated component to convert the values.\ninternal::InfrastructureSystemsInternal\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.RawTimeSeries","page":"API","title":"InfrastructureSystems.RawTimeSeries","text":"Wraps the data read from the text files with time series\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.Recorder","page":"API","title":"InfrastructureSystems.Recorder","text":"Records user-defined events in JSON format.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.Recorder-Tuple{Symbol}","page":"API","title":"InfrastructureSystems.Recorder","text":"Recorder(name::Symbol; io, mode, directory) -> InfrastructureSystems.Recorder\n\n\nConstruct a Recorder.\n\nArguments\n\nname::Symbol: name of recorder\nio::Union{Nothing, IO}:  If nothing, record events in a file using name.\nmode = \"w\":  Only used when io is nothing.\ndirectory = \".\":  Only used when io is nothing.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Results","page":"API","title":"InfrastructureSystems.Results","text":"To implement a sub-type of this you need to implement the methods below.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.Scenarios","page":"API","title":"InfrastructureSystems.Scenarios","text":"mutable struct Scenarios <: Forecast\n    name::String\n    resolution::Dates.Period\n    scenario_count::Int64\n    data::Union{\n        SortedDict{Dates.DateTime, Matrix{CONSTANT}},\n        SortedDict{Dates.DateTime, Matrix{POLYNOMIAL}},\n        SortedDict{Dates.DateTime, Matrix{PWL}},\n    }\n    scaling_factor_multiplier::Union{Nothing, Function}\n    internal::InfrastructureSystemsInternal\nend\n\nA Discrete Scenario Based time series for a particular data field in a Component.\n\nArguments\n\nname::String: user-defined name\nresolution::Dates.Period: forecast resolution\nscenario_count::Int64: Number of scenarios\ndata::Union{SortedDict{Dates.DateTime, Matrix{CONSTANT}}, SortedDict{Dates.DateTime, Matrix{POLYNOMIAL}}, SortedDict{Dates.DateTime, Matrix{PWL}}}: timestamp - scalingfactor\nscaling_factor_multiplier::Union{Nothing, Function}: Applicable when the time series data are scaling factors. Called on the associated component to convert the values.\ninternal::InfrastructureSystemsInternal\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.Scenarios-Tuple{AbstractString,AbstractDict,Dates.Period}","page":"API","title":"InfrastructureSystems.Scenarios","text":"Scenarios(name::AbstractString, input_data::AbstractDict, resolution::Dates.Period; normalization_factor, scaling_factor_multiplier) -> InfrastructureSystems.Scenarios\n\n\nConstruct Scenarios from a SortedDict of Arrays.\n\nArguments\n\nname::AbstractString: user-defined name\ninput_data::AbstractDict{Dates.DateTime, Matrix{Float64}}: time series data.\nresolution::Dates.Period: The resolution of the forecast in Dates.Period`\nnormalization_factor::NormalizationFactor = 1.0: optional normalization factor to apply to each data entry\nscaling_factor_multiplier::Union{Nothing, Function} = nothing: If the data are scaling factors then this function will be called on the component and applied to the data when get_time_series_array is called.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.Scenarios-Tuple{AbstractString,AbstractDict{Dates.DateTime,#s63} where #s63<:TimeSeries.TimeArray}","page":"API","title":"InfrastructureSystems.Scenarios","text":"Scenarios(name::AbstractString, input_data::AbstractDict{Dates.DateTime,#s63} where #s63<:TimeSeries.TimeArray; normalization_factor, scaling_factor_multiplier) -> InfrastructureSystems.Scenarios\n\n\nConstruct Scenarios from a Dict of TimeArrays.\n\nArguments\n\nname::AbstractString: user-defined name\ninput_data::AbstractDict{Dates.DateTime, TimeSeries.TimeArray}: time series data.\nnormalization_factor::NormalizationFactor = 1.0: optional normalization factor to apply to each data entry\nscaling_factor_multiplier::Union{Nothing, Function} = nothing: If the data are scaling factors then this function will be called on the component and applied to the data when get_time_series_array is called.\ntimestamp = :timestamp: If the values are DataFrames is passed then this must be the column name that contains timestamps.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.ScenariosMetadata","page":"API","title":"InfrastructureSystems.ScenariosMetadata","text":"mutable struct ScenariosMetadata <: ForecastMetadata\n    name::String\n    resolution::Dates.Period\n    initial_timestamp::Dates.DateTime\n    interval::Dates.Period\n    scenario_count::Int64\n    count::Int\n    time_series_uuid::UUIDs.UUID\n    horizon::Int\n    scaling_factor_multiplier::Union{Nothing, Function}\n    internal::InfrastructureSystemsInternal\nend\n\nA Discrete Scenario Based time series for a particular data field in a Component.\n\nArguments\n\nname::String: user-defined name\nresolution::Dates.Period\ninitial_timestamp::Dates.DateTime: time series availability time\ninterval::Dates.Period: time step between forecast windows\nscenario_count::Int64: Number of scenarios\ncount::Int: number of forecast windows\ntime_series_uuid::UUIDs.UUID: reference to time series data\nhorizon::Int: length of this time series\nscaling_factor_multiplier::Union{Nothing, Function}: Applicable when the time series data are scaling factors. Called on the associated component to convert the values.\ninternal::InfrastructureSystemsInternal\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.SingleTimeSeries","page":"API","title":"InfrastructureSystems.SingleTimeSeries","text":"mutable struct SingleTimeSeries <: StaticTimeSeries\n    name::String\n    data::TimeSeries.TimeArray\n    scaling_factor_multiplier::Union{Nothing, Function}\n    internal::InfrastructureSystemsInternal\nend\n\nA deterministic forecast for a particular data field in a Component.\n\nArguments\n\nname::String: user-defined name\ndata::TimeSeries.TimeArray: timestamp - scalingfactor\nscaling_factor_multiplier::Union{Nothing, Function}: Applicable when the time series data are scaling factors. Called on the associated component to convert the values.\ninternal::InfrastructureSystemsInternal\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.SingleTimeSeries-Tuple{AbstractString,AbstractString,InfrastructureSystems.InfrastructureSystemsComponent,Dates.Period}","page":"API","title":"InfrastructureSystems.SingleTimeSeries","text":"SingleTimeSeries(name::AbstractString, filename::AbstractString, component::InfrastructureSystems.InfrastructureSystemsComponent, resolution::Dates.Period; normalization_factor, scaling_factor_multiplier) -> InfrastructureSystems.SingleTimeSeries\n\n\nConstruct SingleTimeSeries from a CSV file. The file must have a column that is the name of the component.\n\nArguments\n\nname::AbstractString: user-defined name\nfilename::AbstractString: name of CSV file containing data\ncomponent::InfrastructureSystemsComponent: component associated with the data\nresolution::Dates.Period: resolution of the time series\nnormalization_factor::NormalizationFactor = 1.0: optional normalization factor to apply to each data entry\nscaling_factor_multiplier::Union{Nothing, Function} = nothing: If the data are scaling factors then this function will be called on the component and applied to the data when get_time_series_array is called.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.SingleTimeSeries-Tuple{AbstractString,Union{DataFrames.DataFrame, TimeSeries.TimeArray}}","page":"API","title":"InfrastructureSystems.SingleTimeSeries","text":"SingleTimeSeries(name::AbstractString, data::Union{DataFrames.DataFrame, TimeSeries.TimeArray}; normalization_factor, scaling_factor_multiplier, timestamp) -> InfrastructureSystems.SingleTimeSeries\n\n\nConstruct SingleTimeSeries from a TimeArray or DataFrame.\n\nArguments\n\nname::AbstractString: user-defined name\ndata::Union{TimeSeries.TimeArray, DataFrames.DataFrame}: time series data\nnormalization_factor::NormalizationFactor = 1.0: optional normalization factor to apply to each data entry\nscaling_factor_multiplier::Union{Nothing, Function} = nothing: If the data are scaling factors then this function will be called on the component and applied to the data when get_time_series_array is called.\ntimestamp = :timestamp: If a DataFrame is passed then this must be the column name that contains timestamps.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.SingleTimeSeries-Tuple{InfrastructureSystems.SingleTimeSeries,TimeSeries.TimeArray}","page":"API","title":"InfrastructureSystems.SingleTimeSeries","text":"SingleTimeSeries(time_series::InfrastructureSystems.SingleTimeSeries, data::TimeSeries.TimeArray) -> Any\n\n\nCreates a new SingleTimeSeries from an existing instance and a subset of data.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.SingleTimeSeries-Tuple{String,Dates.Period,Dates.DateTime,Int64}","page":"API","title":"InfrastructureSystems.SingleTimeSeries","text":"SingleTimeSeries(name::String, resolution::Dates.Period, initial_time::Dates.DateTime, time_steps::Int64) -> InfrastructureSystems.SingleTimeSeries\n\n\nConstruct SingleTimeSeries after constructing a TimeArray from initial_time and time_steps.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.SingleTimeSeriesMetadata","page":"API","title":"InfrastructureSystems.SingleTimeSeriesMetadata","text":"mutable struct SingleTimeSeriesMetadata <: StaticTimeSeriesMetadata\n    name::String\n    resolution::Dates.Period\n    initial_timestamp::Dates.DateTime\n    time_series_uuid::UUIDs.UUID\n    length::Int\n    scaling_factor_multiplier::Union{Nothing, Function}\n    internal::InfrastructureSystemsInternal\nend\n\nA TimeSeries Data object in contigous form.\n\nArguments\n\nname::String: user-defined name\nresolution::Dates.Period\ninitial_timestamp::Dates.DateTime: time series availability time\ntime_series_uuid::UUIDs.UUID: reference to time series data\nlength::Int: length of this time series\nscaling_factor_multiplier::Union{Nothing, Function}: Applicable when the time series data are scaling factors. Called on the associated component to convert the values.\ninternal::InfrastructureSystemsInternal\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.StaticTimeSeriesCache-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.InfrastructureSystemsComponent,AbstractString}} where T<:InfrastructureSystems.StaticTimeSeries","page":"API","title":"InfrastructureSystems.StaticTimeSeriesCache","text":"Construct StaticTimeSeriesCache to automatically control caching of time series data. Maintains rows of data in memory based on cache_size_bytes.\n\nCall Base.iterate or get_time_series_array to retrieve data.\n\nArguments\n\n::Type{T}: subtype of StaticTimeSeries\ncomponent::InfrastructureSystemsComponent: component\nname::AbstractString: time series name\ncache_size_bytes = TIME_SERIES_CACHE_SIZE_BYTES: maximum size of data to keep in memory\nignore_scaling_factors = false: controls whether to ignore scalingfactormultiplier in the time series instance\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.SystemData","page":"API","title":"InfrastructureSystems.SystemData","text":"mutable struct SystemData <: InfrastructureSystemsType\n    components::Components\n    \"Masked components are attached to the system for overall management purposes but\n    are not exposed in the standard library calls like [`get_components`](@ref).\n    Examples are components in a subsystem.\"\n    masked_components::Components\n    time_series_params::TimeSeriesParameters\n    validation_descriptors::Vector\n    time_series_storage::TimeSeriesStorage\n    time_series_storage_file::Union{Nothing, String}\n    internal::InfrastructureSystemsInternal\nend\n\nContainer for system components and time series data\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.SystemData-Tuple{}","page":"API","title":"InfrastructureSystems.SystemData","text":"SystemData(; validation_descriptor_file, time_series_in_memory, time_series_directory, compression) -> InfrastructureSystems.SystemData\n\n\nConstruct SystemData to store components and time series data.\n\nArguments\n\nvalidation_descriptor_file = nothing: Optionally, a file defining component validation descriptors.\ntime_series_in_memory = false: Controls whether time series data is stored in memory or in a file.\ntime_series_directory = nothing: Controls what directory time series data is stored in. Default is tempdir().\ncompression = CompressionSettings(): Controls compression of time series data.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.TimeSeriesContainer","page":"API","title":"InfrastructureSystems.TimeSeriesContainer","text":"Time series container for a component.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.TimeSeriesData","page":"API","title":"InfrastructureSystems.TimeSeriesData","text":"Abstract type for time series stored in the system. Components store references to these through TimeSeriesMetadata values so that data can reside on storage media instead of memory.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.TimeSeriesFileMetadata","page":"API","title":"InfrastructureSystems.TimeSeriesFileMetadata","text":"Describes how to construct time_series from raw time series data files.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.TimeSeriesMetadata","page":"API","title":"InfrastructureSystems.TimeSeriesMetadata","text":"Abstract type for time_series that are stored in a system. Users never create them or get access to them. Stores references to TimeSeriesData.\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#InfrastructureSystems.TimeSeriesStorage","page":"API","title":"InfrastructureSystems.TimeSeriesStorage","text":"Abstract type for time series storage implementations.\n\nAll subtypes must implement:\n\naddtimeseries_reference!\ncheckreadonly\ncleartimeseries!\ndeserializetimeseries\ngetcompressionsettings\ngetnumtime_series\nisreadonly\nremovetimeseries!\nserializetimeseries!\nreplacecomponentuuid!\nBase.isempty\n\n\n\n\n\n","category":"type"},{"location":"InfrastructureSystems/#Base.close-Tuple{InfrastructureSystems.MultiLogger}","page":"API","title":"Base.close","text":"close(logger::InfrastructureSystems.MultiLogger)\n\n\nEnsures that any file streams are flushed and closed.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.flush-Tuple{InfrastructureSystems.MultiLogger}","page":"API","title":"Base.flush","text":"flush(logger::InfrastructureSystems.MultiLogger)\n\n\nFlush any file streams.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#Base.get-Union{Tuple{K}, Tuple{InfrastructureSystems.LazyDictFromIterator,K}} where K","page":"API","title":"Base.get","text":"get(container::InfrastructureSystems.LazyDictFromIterator, key::K) -> Any\n\n\nReturns the item mapped to key. If the key is already stored then it will be returned with a dictionary lookup. If it has not been stored then iterate over the list until it is found.\n\nReturns nothing if key is not found.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems._get_all_concrete_subtypes-Union{Tuple{T}, Tuple{Type{T},Array{DataType,1}}} where T","page":"API","title":"InfrastructureSystems._get_all_concrete_subtypes","text":"_get_all_concrete_subtypes(_::Type{T}, sub_types::Array{DataType,1})\n\n\nRecursively builds a vector of subtypes.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems._validate_component-Union{Tuple{T}, Tuple{InfrastructureSystems.SystemData,T}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems._validate_component","text":"_validate_component(data::InfrastructureSystems.SystemData, component::T<:InfrastructureSystems.InfrastructureSystemsComponent)\n\n\nChecks that the component exists in data and the UUID's match.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.add_component!-Union{Tuple{T}, Tuple{InfrastructureSystems.Components,T}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.add_component!","text":"add_component!(components::InfrastructureSystems.Components, component::T<:InfrastructureSystems.InfrastructureSystemsComponent; kwargs...)\n\n\nAdd a component.\n\nThrows ArgumentError if the component's name is already stored for its concrete type.\n\nThrows InvalidRange if any of the component's field values are outside of defined valid range.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.add_serialization_metadata!-Union{Tuple{T}, Tuple{Dict,Type{T}}} where T","page":"API","title":"InfrastructureSystems.add_serialization_metadata!","text":"add_serialization_metadata!(data::Dict, _::Type{T})\n\n\nAdd type information to the dictionary that can be used to deserialize the value.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.add_time_series!-Tuple{InfrastructureSystems.SystemData,Any,InfrastructureSystems.TimeSeriesData}","page":"API","title":"InfrastructureSystems.add_time_series!","text":"add_time_series!(data::InfrastructureSystems.SystemData, components, time_series::InfrastructureSystems.TimeSeriesData)\n\n\nAdd the same time series data to multiple components.\n\nArguments\n\ndata::SystemData: SystemData\ncomponents: iterable of components that will store the same time series reference\ntime_series::TimeSeriesData: Any object of subtype TimeSeriesData\n\nThis is significantly more efficent than calling add_time_series! for each component individually with the same data because in this case, only one time series array is stored.\n\nThrows ArgumentError if a component is not stored in the system.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.add_time_series!-Tuple{InfrastructureSystems.SystemData,InfrastructureSystems.InfrastructureSystemsComponent,InfrastructureSystems.TimeSeriesData}","page":"API","title":"InfrastructureSystems.add_time_series!","text":"add_time_series!(data::InfrastructureSystems.SystemData, component::InfrastructureSystems.InfrastructureSystemsComponent, time_series::InfrastructureSystems.TimeSeriesData; skip_if_present)\n\n\nAdd time series data to a component.\n\nArguments\n\ndata::SystemData: SystemData\ncomponent::InfrastructureSystemsComponent: will store the time series reference\ntime_series::TimeSeriesData: Any object of subtype TimeSeriesData\n\nThrows ArgumentError if the component is not stored in the system.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.add_time_series_from_file_metadata!-Union{Tuple{T}, Tuple{InfrastructureSystems.SystemData,Type{T},AbstractString}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.add_time_series_from_file_metadata!","text":"add_time_series_from_file_metadata!(data::InfrastructureSystems.SystemData, ::Type{T<:InfrastructureSystems.InfrastructureSystemsComponent}, metadata_file::AbstractString; resolution)\n\n\nAdds time_series from a metadata file or metadata descriptors.\n\nArguments\n\ndata::SystemData: system\n::Type{T}: type of the component associated with time series data; may be abstract\nmetadata_file::AbstractString: metadata file for time series that includes an array of TimeSeriesFileMetadata instances or a vector.\nresolution::DateTime.Period=nothing: skip time_series that don't match this resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.add_time_series_from_file_metadata!-Union{Tuple{T}, Tuple{InfrastructureSystems.SystemData,Type{T},Array{InfrastructureSystems.TimeSeriesFileMetadata,1}}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.add_time_series_from_file_metadata!","text":"add_time_series_from_file_metadata!(data::InfrastructureSystems.SystemData, ::Type{T<:InfrastructureSystems.InfrastructureSystemsComponent}, file_metadata::Array{InfrastructureSystems.TimeSeriesFileMetadata,1}; resolution)\n\n\nAdds time series data from a metadata file or metadata descriptors.\n\nArguments\n\ndata::SystemData: system\nfile_metadata::Vector{TimeSeriesFileMetadata}: metadata for time series\nresolution::DateTime.Period=nothing: skip time_series that don't match this resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.assign_new_uuid!-Tuple{InfrastructureSystems.InfrastructureSystemsType}","page":"API","title":"InfrastructureSystems.assign_new_uuid!","text":"assign_new_uuid!(obj::InfrastructureSystems.InfrastructureSystemsType)\n\n\nAssign a new UUID.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.check_params_compatibility-Tuple{InfrastructureSystems.TimeSeriesParameters,InfrastructureSystems.TimeSeriesParameters}","page":"API","title":"InfrastructureSystems.check_params_compatibility","text":"check_params_compatibility(params::InfrastructureSystems.TimeSeriesParameters, other::InfrastructureSystems.TimeSeriesParameters) -> Union{Nothing, Bool}\n\n\nReturn true if params match other or if one of them is uninitialized.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.clear_components!-Tuple{InfrastructureSystems.Components}","page":"API","title":"InfrastructureSystems.clear_components!","text":"clear_components!(components::InfrastructureSystems.Components)\n\n\nRemoves all components from the system.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.clear_ext!-Tuple{InfrastructureSystems.InfrastructureSystemsInternal}","page":"API","title":"InfrastructureSystems.clear_ext!","text":"clear_ext!(obj::InfrastructureSystems.InfrastructureSystemsInternal)\n\n\nClear any value stored in ext.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.compare_values-Union{Tuple{T}, Tuple{T,T}} where T","page":"API","title":"InfrastructureSystems.compare_values","text":"compare_values(x::T, y::T; compare_uuids) -> Bool\n\n\nRecursively compares struct values. Prints all mismatched values to stdout.\n\nArguments\n\nx::T: First value\ny::T: Second value\ncompare_uuids::Bool = false: Compare any UUID in the object or composed objects.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.configure_logging-Tuple{}","page":"API","title":"InfrastructureSystems.configure_logging","text":"configure_logging(; console, console_stream, console_level, file, filename, file_level, file_mode, tracker, set_global) -> InfrastructureSystems.MultiLogger\n\n\nCreates console and file loggers per caller specification and returns a MultiLogger.\n\nSuppress noisy events by specifying per-event values of maxlog = X and  _suppression_period = Y where X is the max number of events that can occur in Y seconds. After the period ends, messages will no longer be suppressed. Note that if you don't specify _suppression_period then maxlog applies for the for the duration of your process (standard Julia logging behavior).\n\nNote: Use of log message suppression and the LogEventTracker are not thread-safe. Please contact the package developers if you need this functionality.\n\nNote: If logging to a file users must call Base.close() on the returned MultiLogger to ensure that all events get flushed.\n\nArguments\n\nconsole::Bool=true: create console logger\nconsole_stream::IOStream=stderr: stream for console logger\nconsole_level::Logging.LogLevel=Logging.Error: level for console messages\nfile::Bool=true: create file logger\nfilename::Union{Nothing, String}=log.txt: log file\nfile_level::Logging.LogLevel=Logging.Info: level for file messages\nfile_mode::String=w+: mode used when opening log file\ntracker::Union{LogEventTracker, Nothing}=LogEventTracker(): optionally track log events\nset_global::Bool=true: set the created logger as the global logger\n\nExample\n\nlogger = configure_logging(filename=\"mylog.txt\")\n@info \"hello world\"\n@info \"hello world\" maxlog = 5 _suppression_period = 10\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.copy_time_series!-Tuple{InfrastructureSystems.InfrastructureSystemsComponent,InfrastructureSystems.InfrastructureSystemsComponent}","page":"API","title":"InfrastructureSystems.copy_time_series!","text":"copy_time_series!(dst::InfrastructureSystems.InfrastructureSystemsComponent, src::InfrastructureSystems.InfrastructureSystemsComponent; name_mapping, scaling_factor_multiplier_mapping)\n\n\nEfficiently add all time_series in one component to another by copying the underlying references.\n\nArguments\n\ndst::InfrastructureSystemsComponent: Destination component\nsrc::InfrastructureSystemsComponent: Source component\nname_mapping::Dict = nothing: Optionally map src names to different dst names. If provided and src has a timeseries with a name not present in namemapping, that timeseries will not copied. If namemapping is nothing then all time_series will be copied with src's names.\nscaling_factor_multiplier_mapping::Dict = nothing: Optionally map src multipliers to different dst multipliers.  If provided and src has a timeseries with a multiplier not present in scalingfactormultipliermapping, that timeseries will not copied. If scalingfactormultipliermapping is nothing then all time_series will be copied with src's multipliers.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.copy_to_new_file!","page":"API","title":"InfrastructureSystems.copy_to_new_file!","text":"copy_to_new_file!(storage::InfrastructureSystems.Hdf5TimeSeriesStorage)\ncopy_to_new_file!(storage::InfrastructureSystems.Hdf5TimeSeriesStorage, directory)\n\n\nCopy the time series data to a new file. This should get called when the system is undergoing a deepcopy.\n\nArguments\n\nstorage::Hdf5TimeSeriesStorage: storage instance\ndirectory::String: If nothing, use tempdir\n\n\n\n\n\n","category":"function"},{"location":"InfrastructureSystems/#InfrastructureSystems.deserialize-Union{Tuple{T}, Tuple{Type{T},Dict}} where T<:InfrastructureSystems.InfrastructureSystemsType","page":"API","title":"InfrastructureSystems.deserialize","text":"deserialize(_::Type{T<:InfrastructureSystems.InfrastructureSystemsType}, data::Dict) -> InfrastructureSystems.SystemData\n\n\nDeserialize an object from standard types stored in non-Julia formats, such as JSON, into Julia types.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.empty_group_levels!-Tuple{InfrastructureSystems.MultiLogger}","page":"API","title":"InfrastructureSystems.empty_group_levels!","text":"empty_group_levels!(logger::InfrastructureSystems.MultiLogger)\n\n\nEmpty the minimum log levels stored for each group.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.from-Tuple{InfrastructureSystems.SingleTimeSeries,Any}","page":"API","title":"InfrastructureSystems.from","text":"from(time_series::InfrastructureSystems.SingleTimeSeries, timestamp) -> InfrastructureSystems.SingleTimeSeries\n\n\nReturn a time_series truncated starting with timestamp.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.from_file-Tuple{Type{InfrastructureSystems.Hdf5TimeSeriesStorage},AbstractString}","page":"API","title":"InfrastructureSystems.from_file","text":"from_file(::Type{InfrastructureSystems.Hdf5TimeSeriesStorage}, filename::AbstractString; read_only, directory) -> InfrastructureSystems.Hdf5TimeSeriesStorage\n\n\nConstructs Hdf5TimeSeriesStorage from an existing file.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.from_json-Union{Tuple{T}, Tuple{Type{T},String}} where T<:InfrastructureSystems.InfrastructureSystemsType","page":"API","title":"InfrastructureSystems.from_json","text":"from_json(_::Type{T<:InfrastructureSystems.InfrastructureSystemsType}, filename::String) -> Any\n\n\nDeserializes a InfrastructureSystemsType from a JSON filename.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.from_json-Union{Tuple{T}, Tuple{Union{IO, String},Type{T}}} where T<:InfrastructureSystems.InfrastructureSystemsType","page":"API","title":"InfrastructureSystems.from_json","text":"from_json(io::Union{IO, String}, _::Type{T<:InfrastructureSystems.InfrastructureSystemsType}) -> InfrastructureSystems.TestComponent\n\n\nDeserializes a InfrastructureSystemsType from String or IO.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_abstract_subtypes-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"API","title":"InfrastructureSystems.get_abstract_subtypes","text":"Returns an array of abstract types that are direct subtypes of T.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_all_concrete_subtypes-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"API","title":"InfrastructureSystems.get_all_concrete_subtypes","text":"Returns an array of all concrete subtypes of T. Note that this does not find parameterized types.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_component-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.Components,AbstractString}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.get_component","text":"Get the component of type T with name. Returns nothing if no component matches. If T is an abstract type then the names of components across all subtypes of T must be unique.\n\nSee get_components_by_name for abstract types with non-unique names across subtypes.\n\nThrows ArgumentError if T is not a concrete type and there is more than one component with     requested name\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_components-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.Components}, Tuple{Type{T},InfrastructureSystems.Components,Union{Nothing, Function}}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.get_components","text":"get_components(::Type{T<:InfrastructureSystems.InfrastructureSystemsComponent}, components::InfrastructureSystems.Components) -> InfrastructureSystems.FlattenIteratorWrapper{_A} where _A\nget_components(::Type{T<:InfrastructureSystems.InfrastructureSystemsComponent}, components::InfrastructureSystems.Components, filter_func::Union{Nothing, Function}) -> InfrastructureSystems.FlattenIteratorWrapper{_A} where _A\n\n\nReturns an iterator of components. T can be concrete or abstract. Call collect on the result if an array is desired.\n\nArguments\n\nT: component type\ncomponents::Components: Components of the sytem\nfilter_func::Union{Nothing, Function} = nothing: Optional function that accepts a component  of type T and returns a Bool. Apply this function to each component and only return components  where the result is true.\n\nSee also: iterate_components\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_components_by_name-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.Components,AbstractString}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.get_components_by_name","text":"Get the components of abstract type T with name. Note that InfrastructureSystems enforces unique names on each concrete type but not across concrete types.\n\nSee get_component if the concrete type is known.\n\nThrows ArgumentError if T is not an abstract type.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_concrete_subtypes-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"API","title":"InfrastructureSystems.get_concrete_subtypes","text":"get_concrete_subtypes(_::Type{T}) -> Array{_A,1} where _A\n\n\nReturns an array of concrete types that are direct subtypes of T.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_count-Tuple{InfrastructureSystems.DeterministicMetadata}","page":"API","title":"InfrastructureSystems.get_count","text":"get_count(value::InfrastructureSystems.DeterministicMetadata) -> Int64\n\n\nGet DeterministicMetadata count.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_count-Tuple{InfrastructureSystems.DeterministicSingleTimeSeries}","page":"API","title":"InfrastructureSystems.get_count","text":"get_count(value::InfrastructureSystems.DeterministicSingleTimeSeries) -> Int64\n\n\nGet DeterministicSingleTimeSeries count.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_count-Tuple{InfrastructureSystems.ProbabilisticMetadata}","page":"API","title":"InfrastructureSystems.get_count","text":"get_count(value::InfrastructureSystems.ProbabilisticMetadata) -> Int64\n\n\nGet ProbabilisticMetadata count.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_count-Tuple{InfrastructureSystems.ScenariosMetadata}","page":"API","title":"InfrastructureSystems.get_count","text":"get_count(value::InfrastructureSystems.ScenariosMetadata) -> Int64\n\n\nGet ScenariosMetadata count.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_data-Tuple{InfrastructureSystems.Deterministic}","page":"API","title":"InfrastructureSystems.get_data","text":"get_data(value::InfrastructureSystems.Deterministic) -> Union{DataStructures.SortedDict{Dates.DateTime,Array{Array{Tuple{Float64,Float64},1},1},Ord} where Ord<:Base.Order.Ordering, DataStructures.SortedDict{Dates.DateTime,Array{Float64,1},Ord} where Ord<:Base.Order.Ordering, DataStructures.SortedDict{Dates.DateTime,Array{Tuple{Float64,Float64},1},Ord} where Ord<:Base.Order.Ordering}\n\n\nGet Deterministic data.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_data-Tuple{InfrastructureSystems.Probabilistic}","page":"API","title":"InfrastructureSystems.get_data","text":"get_data(value::InfrastructureSystems.Probabilistic) -> Union{DataStructures.SortedDict{Dates.DateTime,Array{Array{Tuple{Float64,Float64},1},2},Ord} where Ord<:Base.Order.Ordering, DataStructures.SortedDict{Dates.DateTime,Array{Float64,2},Ord} where Ord<:Base.Order.Ordering, DataStructures.SortedDict{Dates.DateTime,Array{Tuple{Float64,Float64},2},Ord} where Ord<:Base.Order.Ordering}\n\n\nGet Probabilistic data.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_data-Tuple{InfrastructureSystems.Scenarios}","page":"API","title":"InfrastructureSystems.get_data","text":"get_data(value::InfrastructureSystems.Scenarios) -> Union{DataStructures.SortedDict{Dates.DateTime,Array{Array{Tuple{Float64,Float64},1},2},Ord} where Ord<:Base.Order.Ordering, DataStructures.SortedDict{Dates.DateTime,Array{Float64,2},Ord} where Ord<:Base.Order.Ordering, DataStructures.SortedDict{Dates.DateTime,Array{Tuple{Float64,Float64},2},Ord} where Ord<:Base.Order.Ordering}\n\n\nGet Scenarios data.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_data-Tuple{InfrastructureSystems.SingleTimeSeries}","page":"API","title":"InfrastructureSystems.get_data","text":"get_data(value::InfrastructureSystems.SingleTimeSeries) -> TimeSeries.TimeArray\n\n\nGet SingleTimeSeries data.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_data_type-Tuple{InfrastructureSystems.TimeSeriesData}","page":"API","title":"InfrastructureSystems.get_data_type","text":"get_data_type(ts::InfrastructureSystems.TimeSeriesData) -> String\n\n\nReturn a String for the data type of the forecast data, this implementation avoids the use of eval on arbitrary code stored in HDF dataset.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_ext-Tuple{InfrastructureSystems.InfrastructureSystemsInternal}","page":"API","title":"InfrastructureSystems.get_ext","text":"get_ext(obj::InfrastructureSystems.InfrastructureSystemsInternal) -> Union{Nothing, Dict{String,Any}}\n\n\nReturn a user-modifiable dictionary to store extra information.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_group_level-Tuple{InfrastructureSystems.MultiLogger,Symbol}","page":"API","title":"InfrastructureSystems.get_group_level","text":"get_group_level(logger::InfrastructureSystems.MultiLogger, group::Symbol) -> Union{Nothing, Base.CoreLogging.LogLevel}\n\n\nReturn the minimum logging level for a group or nothing if group is not stored.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_group_levels-Tuple{InfrastructureSystems.MultiLogger}","page":"API","title":"InfrastructureSystems.get_group_levels","text":"get_group_levels(logger::InfrastructureSystems.MultiLogger) -> Dict{Symbol,Base.CoreLogging.LogLevel}\n\n\nReturn the minimum logging levels for groups that have been stored.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_horizon-Tuple{InfrastructureSystems.DeterministicMetadata}","page":"API","title":"InfrastructureSystems.get_horizon","text":"get_horizon(value::InfrastructureSystems.DeterministicMetadata) -> Int64\n\n\nGet DeterministicMetadata horizon.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_horizon-Tuple{InfrastructureSystems.DeterministicSingleTimeSeries}","page":"API","title":"InfrastructureSystems.get_horizon","text":"get_horizon(value::InfrastructureSystems.DeterministicSingleTimeSeries) -> Int64\n\n\nGet DeterministicSingleTimeSeries horizon.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_horizon-Tuple{InfrastructureSystems.ProbabilisticMetadata}","page":"API","title":"InfrastructureSystems.get_horizon","text":"get_horizon(value::InfrastructureSystems.ProbabilisticMetadata) -> Int64\n\n\nGet ProbabilisticMetadata horizon.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_horizon-Tuple{InfrastructureSystems.ScenariosMetadata}","page":"API","title":"InfrastructureSystems.get_horizon","text":"get_horizon(value::InfrastructureSystems.ScenariosMetadata) -> Int64\n\n\nGet ScenariosMetadata horizon.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_initial_times-Tuple{InfrastructureSystems.Forecast}","page":"API","title":"InfrastructureSystems.get_initial_times","text":"get_initial_times(f::InfrastructureSystems.Forecast) -> DataStructures.SDMKeyIteration\n\n\nReturn the initial times in the forecast.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_initial_timestamp-Tuple{InfrastructureSystems.DeterministicMetadata}","page":"API","title":"InfrastructureSystems.get_initial_timestamp","text":"get_initial_timestamp(value::InfrastructureSystems.DeterministicMetadata) -> Dates.DateTime\n\n\nGet DeterministicMetadata initial_timestamp.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_initial_timestamp-Tuple{InfrastructureSystems.DeterministicSingleTimeSeries}","page":"API","title":"InfrastructureSystems.get_initial_timestamp","text":"get_initial_timestamp(value::InfrastructureSystems.DeterministicSingleTimeSeries) -> Dates.DateTime\n\n\nGet DeterministicSingleTimeSeries initial_timestamp.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_initial_timestamp-Tuple{InfrastructureSystems.ProbabilisticMetadata}","page":"API","title":"InfrastructureSystems.get_initial_timestamp","text":"get_initial_timestamp(value::InfrastructureSystems.ProbabilisticMetadata) -> Dates.DateTime\n\n\nGet ProbabilisticMetadata initial_timestamp.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_initial_timestamp-Tuple{InfrastructureSystems.ScenariosMetadata}","page":"API","title":"InfrastructureSystems.get_initial_timestamp","text":"get_initial_timestamp(value::InfrastructureSystems.ScenariosMetadata) -> Dates.DateTime\n\n\nGet ScenariosMetadata initial_timestamp.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_initial_timestamp-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata}","page":"API","title":"InfrastructureSystems.get_initial_timestamp","text":"get_initial_timestamp(value::InfrastructureSystems.SingleTimeSeriesMetadata) -> Dates.DateTime\n\n\nGet SingleTimeSeriesMetadata initial_timestamp.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_internal-Tuple{InfrastructureSystems.DeterministicMetadata}","page":"API","title":"InfrastructureSystems.get_internal","text":"get_internal(value::InfrastructureSystems.DeterministicMetadata) -> InfrastructureSystems.InfrastructureSystemsInternal\n\n\nGet DeterministicMetadata internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_internal-Tuple{InfrastructureSystems.Deterministic}","page":"API","title":"InfrastructureSystems.get_internal","text":"get_internal(value::InfrastructureSystems.Deterministic) -> InfrastructureSystems.InfrastructureSystemsInternal\n\n\nGet Deterministic internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_internal-Tuple{InfrastructureSystems.ProbabilisticMetadata}","page":"API","title":"InfrastructureSystems.get_internal","text":"get_internal(value::InfrastructureSystems.ProbabilisticMetadata) -> InfrastructureSystems.InfrastructureSystemsInternal\n\n\nGet ProbabilisticMetadata internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_internal-Tuple{InfrastructureSystems.Probabilistic}","page":"API","title":"InfrastructureSystems.get_internal","text":"get_internal(value::InfrastructureSystems.Probabilistic) -> InfrastructureSystems.InfrastructureSystemsInternal\n\n\nGet Probabilistic internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_internal-Tuple{InfrastructureSystems.ScenariosMetadata}","page":"API","title":"InfrastructureSystems.get_internal","text":"get_internal(value::InfrastructureSystems.ScenariosMetadata) -> InfrastructureSystems.InfrastructureSystemsInternal\n\n\nGet ScenariosMetadata internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_internal-Tuple{InfrastructureSystems.Scenarios}","page":"API","title":"InfrastructureSystems.get_internal","text":"get_internal(value::InfrastructureSystems.Scenarios) -> InfrastructureSystems.InfrastructureSystemsInternal\n\n\nGet Scenarios internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_internal-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata}","page":"API","title":"InfrastructureSystems.get_internal","text":"get_internal(value::InfrastructureSystems.SingleTimeSeriesMetadata) -> InfrastructureSystems.InfrastructureSystemsInternal\n\n\nGet SingleTimeSeriesMetadata internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_internal-Tuple{InfrastructureSystems.SingleTimeSeries}","page":"API","title":"InfrastructureSystems.get_internal","text":"get_internal(value::InfrastructureSystems.SingleTimeSeries) -> InfrastructureSystems.InfrastructureSystemsInternal\n\n\nGet SingleTimeSeries internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_interval-Tuple{InfrastructureSystems.DeterministicMetadata}","page":"API","title":"InfrastructureSystems.get_interval","text":"get_interval(value::InfrastructureSystems.DeterministicMetadata) -> Dates.Period\n\n\nGet DeterministicMetadata interval.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_interval-Tuple{InfrastructureSystems.DeterministicSingleTimeSeries}","page":"API","title":"InfrastructureSystems.get_interval","text":"get_interval(value::InfrastructureSystems.DeterministicSingleTimeSeries) -> Dates.Period\n\n\nGet DeterministicSingleTimeSeries interval.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_interval-Tuple{InfrastructureSystems.ProbabilisticMetadata}","page":"API","title":"InfrastructureSystems.get_interval","text":"get_interval(value::InfrastructureSystems.ProbabilisticMetadata) -> Dates.Period\n\n\nGet ProbabilisticMetadata interval.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_interval-Tuple{InfrastructureSystems.ScenariosMetadata}","page":"API","title":"InfrastructureSystems.get_interval","text":"get_interval(value::InfrastructureSystems.ScenariosMetadata) -> Dates.Period\n\n\nGet ScenariosMetadata interval.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_length-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata}","page":"API","title":"InfrastructureSystems.get_length","text":"get_length(value::InfrastructureSystems.SingleTimeSeriesMetadata) -> Int64\n\n\nGet SingleTimeSeriesMetadata length.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_log_events-Tuple{InfrastructureSystems.LogEventTracker,Base.CoreLogging.LogLevel}","page":"API","title":"InfrastructureSystems.get_log_events","text":"get_log_events(tracker::InfrastructureSystems.LogEventTracker, level::Base.CoreLogging.LogLevel) -> Union{Base.ValueIterator{Dict{Symbol,InfrastructureSystems.LogEvent}}, Array{Any,1}}\n\n\nReturns an iterable of log events for a level.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_name-Tuple{InfrastructureSystems.DeterministicMetadata}","page":"API","title":"InfrastructureSystems.get_name","text":"get_name(value::InfrastructureSystems.DeterministicMetadata) -> String\n\n\nGet DeterministicMetadata name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_name-Tuple{InfrastructureSystems.Deterministic}","page":"API","title":"InfrastructureSystems.get_name","text":"get_name(value::InfrastructureSystems.Deterministic) -> String\n\n\nGet Deterministic name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_name-Tuple{InfrastructureSystems.ProbabilisticMetadata}","page":"API","title":"InfrastructureSystems.get_name","text":"get_name(value::InfrastructureSystems.ProbabilisticMetadata) -> String\n\n\nGet ProbabilisticMetadata name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_name-Tuple{InfrastructureSystems.Probabilistic}","page":"API","title":"InfrastructureSystems.get_name","text":"get_name(value::InfrastructureSystems.Probabilistic) -> String\n\n\nGet Probabilistic name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_name-Tuple{InfrastructureSystems.ScenariosMetadata}","page":"API","title":"InfrastructureSystems.get_name","text":"get_name(value::InfrastructureSystems.ScenariosMetadata) -> String\n\n\nGet ScenariosMetadata name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_name-Tuple{InfrastructureSystems.Scenarios}","page":"API","title":"InfrastructureSystems.get_name","text":"get_name(value::InfrastructureSystems.Scenarios) -> String\n\n\nGet Scenarios name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_name-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata}","page":"API","title":"InfrastructureSystems.get_name","text":"get_name(value::InfrastructureSystems.SingleTimeSeriesMetadata) -> String\n\n\nGet SingleTimeSeriesMetadata name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_name-Tuple{InfrastructureSystems.SingleTimeSeries}","page":"API","title":"InfrastructureSystems.get_name","text":"get_name(value::InfrastructureSystems.SingleTimeSeries) -> String\n\n\nGet SingleTimeSeries name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_next_time-Tuple{InfrastructureSystems.TimeSeriesCache}","page":"API","title":"InfrastructureSystems.get_next_time","text":"get_next_time(cache::InfrastructureSystems.TimeSeriesCache) -> Any\n\n\nReturn the timestamp for the next read with get_next_time_series_array!.\n\nReturn nothing if all data has been read.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_next_time_series_array!-Tuple{InfrastructureSystems.TimeSeriesCache}","page":"API","title":"InfrastructureSystems.get_next_time_series_array!","text":"get_next_time_series_array!(cache::InfrastructureSystems.TimeSeriesCache) -> Any\n\n\nReturn the next TimeSeries.TimeArray.\n\nReturns nothing when all data has been read. Call reset! to restart. Call get_next_time to check the start time.\n\nReads from storage if the data is not already in cache.\n\nArguments\n\ncache::StaticTimeSeriesCache: cached instance\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_num_steps-Union{Tuple{T}, Tuple{Type{T},CSV.File,AbstractArray}} where T<:InfrastructureSystems.TimeSeriesFileFormat","page":"API","title":"InfrastructureSystems.get_num_steps","text":"get_num_steps(_::Type{T<:InfrastructureSystems.TimeSeriesFileFormat}, file::CSV.File, period::AbstractArray) -> Any\n\n\nReturn the number of steps specified by the period in the file.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_num_steps-Union{Tuple{T}, Tuple{Type{T},CSV.File,AbstractArray}} where T<:InfrastructureSystems.TimeSeriesFormatPeriodAsHeader","page":"API","title":"InfrastructureSystems.get_num_steps","text":"get_num_steps(_::Type{T<:InfrastructureSystems.TimeSeriesFormatPeriodAsHeader}, file::CSV.File, period::AbstractArray) -> Any\n\n\nReturn the number of steps specified by the period in the file.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_num_steps-Union{Tuple{T}, Tuple{Type{T},CSV.File,AbstractArray}} where T<:Union{InfrastructureSystems.TimeSeriesFormatDateTimeAsColumn, InfrastructureSystems.TimeSeriesFormatPeriodAsColumn}","page":"API","title":"InfrastructureSystems.get_num_steps","text":"get_num_steps(_::Type{T<:Union{InfrastructureSystems.TimeSeriesFormatDateTimeAsColumn, InfrastructureSystems.TimeSeriesFormatPeriodAsColumn}}, file::CSV.File, period::AbstractArray) -> Any\n\n\nReturn the number of steps specified by the period in the file.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_percentiles-Tuple{InfrastructureSystems.ProbabilisticMetadata}","page":"API","title":"InfrastructureSystems.get_percentiles","text":"get_percentiles(value::InfrastructureSystems.ProbabilisticMetadata) -> Array{Float64,1}\n\n\nGet ProbabilisticMetadata percentiles.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_percentiles-Tuple{InfrastructureSystems.Probabilistic}","page":"API","title":"InfrastructureSystems.get_percentiles","text":"get_percentiles(value::InfrastructureSystems.Probabilistic) -> Array{Float64,1}\n\n\nGet Probabilistic percentiles.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_period_columns-Tuple{Type{InfrastructureSystems.TimeSeriesFormatPeriodAsColumn},CSV.File}","page":"API","title":"InfrastructureSystems.get_period_columns","text":"get_period_columns(_::Type{InfrastructureSystems.TimeSeriesFormatPeriodAsColumn}, file::CSV.File) -> Array{Symbol,1}\n\n\nReturn the column names that specify the Period.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_resolution-Tuple{InfrastructureSystems.DeterministicMetadata}","page":"API","title":"InfrastructureSystems.get_resolution","text":"get_resolution(value::InfrastructureSystems.DeterministicMetadata) -> Dates.Period\n\n\nGet DeterministicMetadata resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_resolution-Tuple{InfrastructureSystems.Deterministic}","page":"API","title":"InfrastructureSystems.get_resolution","text":"get_resolution(value::InfrastructureSystems.Deterministic) -> Dates.Period\n\n\nGet Deterministic resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_resolution-Tuple{InfrastructureSystems.ProbabilisticMetadata}","page":"API","title":"InfrastructureSystems.get_resolution","text":"get_resolution(value::InfrastructureSystems.ProbabilisticMetadata) -> Dates.Period\n\n\nGet ProbabilisticMetadata resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_resolution-Tuple{InfrastructureSystems.Probabilistic}","page":"API","title":"InfrastructureSystems.get_resolution","text":"get_resolution(value::InfrastructureSystems.Probabilistic) -> Dates.Period\n\n\nGet Probabilistic resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_resolution-Tuple{InfrastructureSystems.ScenariosMetadata}","page":"API","title":"InfrastructureSystems.get_resolution","text":"get_resolution(value::InfrastructureSystems.ScenariosMetadata) -> Dates.Period\n\n\nGet ScenariosMetadata resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_resolution-Tuple{InfrastructureSystems.Scenarios}","page":"API","title":"InfrastructureSystems.get_resolution","text":"get_resolution(value::InfrastructureSystems.Scenarios) -> Dates.Period\n\n\nGet Scenarios resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_resolution-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata}","page":"API","title":"InfrastructureSystems.get_resolution","text":"get_resolution(value::InfrastructureSystems.SingleTimeSeriesMetadata) -> Dates.Period\n\n\nGet SingleTimeSeriesMetadata resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_resolution-Tuple{InfrastructureSystems.SingleTimeSeries}","page":"API","title":"InfrastructureSystems.get_resolution","text":"get_resolution(value::InfrastructureSystems.SingleTimeSeries) -> Dates.Period\n\n\nGet SingleTimeSeries resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_resolution-Tuple{TimeSeries.TimeArray}","page":"API","title":"InfrastructureSystems.get_resolution","text":"get_resolution(ts::TimeSeries.TimeArray) -> Any\n\n\nReturn the resolution from a TimeArray.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_scaling_factor_multiplier-Tuple{InfrastructureSystems.DeterministicMetadata}","page":"API","title":"InfrastructureSystems.get_scaling_factor_multiplier","text":"get_scaling_factor_multiplier(value::InfrastructureSystems.DeterministicMetadata) -> Union{Nothing, Function}\n\n\nGet DeterministicMetadata scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_scaling_factor_multiplier-Tuple{InfrastructureSystems.Deterministic}","page":"API","title":"InfrastructureSystems.get_scaling_factor_multiplier","text":"get_scaling_factor_multiplier(value::InfrastructureSystems.Deterministic) -> Union{Nothing, Function}\n\n\nGet Deterministic scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_scaling_factor_multiplier-Tuple{InfrastructureSystems.ProbabilisticMetadata}","page":"API","title":"InfrastructureSystems.get_scaling_factor_multiplier","text":"get_scaling_factor_multiplier(value::InfrastructureSystems.ProbabilisticMetadata) -> Union{Nothing, Function}\n\n\nGet ProbabilisticMetadata scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_scaling_factor_multiplier-Tuple{InfrastructureSystems.Probabilistic}","page":"API","title":"InfrastructureSystems.get_scaling_factor_multiplier","text":"get_scaling_factor_multiplier(value::InfrastructureSystems.Probabilistic) -> Union{Nothing, Function}\n\n\nGet Probabilistic scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_scaling_factor_multiplier-Tuple{InfrastructureSystems.ScenariosMetadata}","page":"API","title":"InfrastructureSystems.get_scaling_factor_multiplier","text":"get_scaling_factor_multiplier(value::InfrastructureSystems.ScenariosMetadata) -> Union{Nothing, Function}\n\n\nGet ScenariosMetadata scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_scaling_factor_multiplier-Tuple{InfrastructureSystems.Scenarios}","page":"API","title":"InfrastructureSystems.get_scaling_factor_multiplier","text":"get_scaling_factor_multiplier(value::InfrastructureSystems.Scenarios) -> Union{Nothing, Function}\n\n\nGet Scenarios scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_scaling_factor_multiplier-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata}","page":"API","title":"InfrastructureSystems.get_scaling_factor_multiplier","text":"get_scaling_factor_multiplier(value::InfrastructureSystems.SingleTimeSeriesMetadata) -> Union{Nothing, Function}\n\n\nGet SingleTimeSeriesMetadata scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_scaling_factor_multiplier-Tuple{InfrastructureSystems.SingleTimeSeries}","page":"API","title":"InfrastructureSystems.get_scaling_factor_multiplier","text":"get_scaling_factor_multiplier(value::InfrastructureSystems.SingleTimeSeries) -> Union{Nothing, Function}\n\n\nGet SingleTimeSeries scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_scenario_count-Tuple{InfrastructureSystems.ScenariosMetadata}","page":"API","title":"InfrastructureSystems.get_scenario_count","text":"get_scenario_count(value::InfrastructureSystems.ScenariosMetadata) -> Int64\n\n\nGet ScenariosMetadata scenario_count.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_scenario_count-Tuple{InfrastructureSystems.Scenarios}","page":"API","title":"InfrastructureSystems.get_scenario_count","text":"get_scenario_count(value::InfrastructureSystems.Scenarios) -> Int64\n\n\nGet Scenarios scenario_count.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_serialization_metadata-Tuple{Dict}","page":"API","title":"InfrastructureSystems.get_serialization_metadata","text":"get_serialization_metadata(data::Dict) -> Any\n\n\nReturn the type information for the serialized struct.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_single_time_series-Tuple{InfrastructureSystems.DeterministicSingleTimeSeries}","page":"API","title":"InfrastructureSystems.get_single_time_series","text":"get_single_time_series(value::InfrastructureSystems.DeterministicSingleTimeSeries) -> InfrastructureSystems.SingleTimeSeries\n\n\nGet DeterministicSingleTimeSeries single_time_series.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.InfrastructureSystemsComponent,AbstractString}} where T<:InfrastructureSystems.TimeSeriesData","page":"API","title":"InfrastructureSystems.get_time_series","text":"Return a time series corresponding to the given parameters.\n\nArguments\n\n::Type{T}: Concrete subtype of TimeSeriesData to return\ncomponent::InfrastructureSystemsComponent: Component containing the time series\nname::AbstractString: name of time series\nstart_time::Union{Nothing, Dates.DateTime} = nothing: If nothing, use the initial_timestamp of the time series. If T is a subtype of Forecast then start_time must be the first timstamp of a window.\nlen::Union{Nothing, Int} = nothing: Length in the time dimension. If nothing, use the entire length.\ncount::Union{Nothing, Int} = nothing: Only applicable to subtypes of Forecast. Number of forecast windows starting at start_time to return. Defaults to all available.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_array","page":"API","title":"InfrastructureSystems.get_time_series_array","text":"get_time_series_array(component::InfrastructureSystems.InfrastructureSystemsComponent, time_series::InfrastructureSystems.StaticTimeSeries) -> Any\nget_time_series_array(component::InfrastructureSystems.InfrastructureSystemsComponent, time_series::InfrastructureSystems.StaticTimeSeries, start_time::Union{Nothing, Dates.DateTime}; len, ignore_scaling_factors) -> Any\n\n\nReturn a TimeSeries.TimeArray from a cached StaticTimeSeries instance.\n\nIf the data are scaling factors then the stored scalingfactormultiplier will be called on the component and applied to the data unless ignorescalingfactors is true.\n\nSee also StaticTimeSeriesCache.\n\n\n\n\n\n","category":"function"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_array!-Tuple{InfrastructureSystems.TimeSeriesCache,Dates.DateTime}","page":"API","title":"InfrastructureSystems.get_time_series_array!","text":"get_time_series_array!(cache::InfrastructureSystems.TimeSeriesCache, timestamp::Dates.DateTime) -> Any\n\n\nReturn the TimeSeries.TimeArray starting at timestamp. Reads from storage if the data is not already in cache.\n\nTimestamps must be read sequentially. Random access may be added in the future.\n\nArguments\n\ncache::StaticTimeSeriesCache: cached instance\ntimestamp::Dates.DateTime: starting timestamp for the time series array\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_array-Tuple{InfrastructureSystems.InfrastructureSystemsComponent,InfrastructureSystems.Forecast,Dates.DateTime}","page":"API","title":"InfrastructureSystems.get_time_series_array","text":"get_time_series_array(component::InfrastructureSystems.InfrastructureSystemsComponent, forecast::InfrastructureSystems.Forecast, start_time::Dates.DateTime; len, ignore_scaling_factors) -> Any\n\n\nReturn a TimeSeries.TimeArray for one forecast window from a cached Forecast instance.\n\nIf the data are scaling factors then the stored scalingfactormultiplier will be called on the component and applied to the data unless ignorescalingfactors is true.\n\nSee also ForecastCache.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_array-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.InfrastructureSystemsComponent,AbstractString}} where T<:InfrastructureSystems.TimeSeriesData","page":"API","title":"InfrastructureSystems.get_time_series_array","text":"get_time_series_array(::Type{T<:InfrastructureSystems.TimeSeriesData}, component::InfrastructureSystems.InfrastructureSystemsComponent, name::AbstractString; start_time, len, ignore_scaling_factors) -> Any\n\n\nReturn a TimeSeries.TimeArray from storage for the given time series parameters.\n\nIf the data are scaling factors then the stored scalingfactormultiplier will be called on the component and applied to the data unless ignorescalingfactors is true.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_container-Tuple{InfrastructureSystems.InfrastructureSystemsComponent}","page":"API","title":"InfrastructureSystems.get_time_series_container","text":"get_time_series_container(value::InfrastructureSystems.InfrastructureSystemsComponent) -> InfrastructureSystems.TimeSeriesContainer\n\n\nReturn the internal time_series storage container or nothing, if the type doesn't store time series.\n\nSubtypes need to implement this method if they store time series.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_counts-Tuple{InfrastructureSystems.SystemData}","page":"API","title":"InfrastructureSystems.get_time_series_counts","text":"get_time_series_counts(data::InfrastructureSystems.SystemData) -> Tuple{Int64,Any,Any}\n\n\nReturn a tuple of counts of components with time series and total time series and forecasts.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_format-Tuple{CSV.File}","page":"API","title":"InfrastructureSystems.get_time_series_format","text":"get_time_series_format(file::CSV.File) -> Type\n\n\nReturn the time series format used in the CSV file.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_multiple","page":"API","title":"InfrastructureSystems.get_time_series_multiple","text":"get_time_series_multiple(data::InfrastructureSystems.SystemData) -> Channel{Any}\nget_time_series_multiple(data::InfrastructureSystems.SystemData, filter_func; type, name) -> Channel{Any}\n\n\nReturns an iterator of TimeSeriesData instances attached to the system.\n\nNote that passing a filter function can be much slower than the other filtering parameters because it reads time series data from media.\n\nCall collect on the result to get an array.\n\nArguments\n\ndata::SystemData: system\nfilter_func = nothing: Only return time_series for which this returns true.\ntype = nothing: Only return time_series with this type.\nname = nothing: Only return time_series matching this value.\n\n\n\n\n\n","category":"function"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_multiple-2","page":"API","title":"InfrastructureSystems.get_time_series_multiple","text":"get_time_series_multiple(component::InfrastructureSystems.InfrastructureSystemsComponent) -> Channel{Any}\nget_time_series_multiple(component::InfrastructureSystems.InfrastructureSystemsComponent, filter_func; type, start_time, name) -> Channel{Any}\n\n\nReturns an iterator of TimeSeriesData instances attached to the component.\n\nNote that passing a filter function can be much slower than the other filtering parameters because it reads time series data from media.\n\nCall collect on the result to get an array.\n\nArguments\n\ncomponent::InfrastructureSystemsComponent: component from which to get time_series\nfilter_func = nothing: Only return time_series for which this returns true.\ntype = nothing: Only return time_series with this type.\nname = nothing: Only return time_series matching this value.\n\n\n\n\n\n","category":"function"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_multiple-Tuple{Type{InfrastructureSystems.TimeSeriesMetadata},InfrastructureSystems.InfrastructureSystemsComponent}","page":"API","title":"InfrastructureSystems.get_time_series_multiple","text":"get_time_series_multiple(_::Type{InfrastructureSystems.TimeSeriesMetadata}, component::InfrastructureSystems.InfrastructureSystemsComponent) -> Channel{Any}\n\n\nReturns an iterator of TimeSeriesMetadata instances attached to the component.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_timestamps","page":"API","title":"InfrastructureSystems.get_time_series_timestamps","text":"get_time_series_timestamps(component::InfrastructureSystems.InfrastructureSystemsComponent, forecast::InfrastructureSystems.Forecast)\nget_time_series_timestamps(component::InfrastructureSystems.InfrastructureSystemsComponent, forecast::InfrastructureSystems.Forecast, start_time::Union{Nothing, Dates.DateTime}; len) -> Array{D,1} where D<:Dates.TimeType\n\n\nReturn a vector of timestamps from a cached Forecast instance.\n\n\n\n\n\n","category":"function"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_timestamps-2","page":"API","title":"InfrastructureSystems.get_time_series_timestamps","text":"get_time_series_timestamps(component::InfrastructureSystems.InfrastructureSystemsComponent, time_series::InfrastructureSystems.StaticTimeSeries) -> Array{D,1} where D<:Dates.TimeType\nget_time_series_timestamps(component::InfrastructureSystems.InfrastructureSystemsComponent, time_series::InfrastructureSystems.StaticTimeSeries, start_time::Union{Nothing, Dates.DateTime}; len) -> Array{D,1} where D<:Dates.TimeType\n\n\nReturn a vector of timestamps from a cached StaticTimeSeries instance.\n\n\n\n\n\n","category":"function"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_timestamps-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.InfrastructureSystemsComponent,AbstractString}} where T<:InfrastructureSystems.TimeSeriesData","page":"API","title":"InfrastructureSystems.get_time_series_timestamps","text":"Return a vector of timestamps from storage for the given time series parameters.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_type-Tuple{InfrastructureSystems.DeterministicMetadata}","page":"API","title":"InfrastructureSystems.get_time_series_type","text":"get_time_series_type(value::InfrastructureSystems.DeterministicMetadata) -> Type{#s316} where #s316<:InfrastructureSystems.AbstractDeterministic\n\n\nGet DeterministicMetadata time_series_type.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_uuid-Tuple{InfrastructureSystems.DeterministicMetadata}","page":"API","title":"InfrastructureSystems.get_time_series_uuid","text":"get_time_series_uuid(value::InfrastructureSystems.DeterministicMetadata) -> Base.UUID\n\n\nGet DeterministicMetadata time_series_uuid.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_uuid-Tuple{InfrastructureSystems.ProbabilisticMetadata}","page":"API","title":"InfrastructureSystems.get_time_series_uuid","text":"get_time_series_uuid(value::InfrastructureSystems.ProbabilisticMetadata) -> Base.UUID\n\n\nGet ProbabilisticMetadata time_series_uuid.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_uuid-Tuple{InfrastructureSystems.ScenariosMetadata}","page":"API","title":"InfrastructureSystems.get_time_series_uuid","text":"get_time_series_uuid(value::InfrastructureSystems.ScenariosMetadata) -> Base.UUID\n\n\nGet ScenariosMetadata time_series_uuid.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_uuid-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata}","page":"API","title":"InfrastructureSystems.get_time_series_uuid","text":"get_time_series_uuid(value::InfrastructureSystems.SingleTimeSeriesMetadata) -> Base.UUID\n\n\nGet SingleTimeSeriesMetadata time_series_uuid.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_values","page":"API","title":"InfrastructureSystems.get_time_series_values","text":"get_time_series_values(component::InfrastructureSystems.InfrastructureSystemsComponent, time_series::InfrastructureSystems.StaticTimeSeries) -> Any\nget_time_series_values(component::InfrastructureSystems.InfrastructureSystemsComponent, time_series::InfrastructureSystems.StaticTimeSeries, start_time::Union{Nothing, Dates.DateTime}; len, ignore_scaling_factors) -> Any\n\n\nReturn an Array of values from a cached StaticTimeSeries instance for the requested time series parameters.\n\n\n\n\n\n","category":"function"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_values-Tuple{InfrastructureSystems.InfrastructureSystemsComponent,InfrastructureSystems.Forecast,Dates.DateTime}","page":"API","title":"InfrastructureSystems.get_time_series_values","text":"get_time_series_values(component::InfrastructureSystems.InfrastructureSystemsComponent, forecast::InfrastructureSystems.Forecast, start_time::Dates.DateTime; len, ignore_scaling_factors) -> Any\n\n\nReturn an Array of values for one forecast window from a cached Forecast instance.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_time_series_values-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.InfrastructureSystemsComponent,AbstractString}} where T<:InfrastructureSystems.TimeSeriesData","page":"API","title":"InfrastructureSystems.get_time_series_values","text":"Return an Array of values from storage for the requested time series parameters.\n\nIf the data size is small and this will be called many times, consider using the version that accepts a cached TimeSeriesData instance.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_timestamp-Tuple{Type{InfrastructureSystems.TimeSeriesFormatYMDPeriodAsColumn},CSV.File,Int64}","page":"API","title":"InfrastructureSystems.get_timestamp","text":"get_timestamp(_::Type{InfrastructureSystems.TimeSeriesFormatYMDPeriodAsColumn}, file::CSV.File, row_index::Int64) -> Any\n\n\nReturn a Dates.DateTime for the row in the CSV file.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_total_period-Tuple{InfrastructureSystems.Forecast}","page":"API","title":"InfrastructureSystems.get_total_period","text":"get_total_period(f::InfrastructureSystems.Forecast) -> Any\n\n\nReturn the total period covered by the forecast.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_unique_timestamps-Union{Tuple{T}, Tuple{Type{T},CSV.File}} where T<:InfrastructureSystems.TimeSeriesFileFormat","page":"API","title":"InfrastructureSystems.get_unique_timestamps","text":"get_unique_timestamps(_::Type{T<:InfrastructureSystems.TimeSeriesFileFormat}, file::CSV.File) -> Array{Dict{String,Any},1}\n\n\nReturn a vector of dicts of unique timestamps and their counts.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_uuid-Tuple{InfrastructureSystems.InfrastructureSystemsType}","page":"API","title":"InfrastructureSystems.get_uuid","text":"get_uuid(obj::InfrastructureSystems.InfrastructureSystemsType) -> Base.UUID\n\n\nGets the UUID for any InfrastructureSystemsType.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_value_columns-Tuple{Type{InfrastructureSystems.TimeSeriesFormatComponentsAsColumnsNoTime},CSV.File}","page":"API","title":"InfrastructureSystems.get_value_columns","text":"get_value_columns(_::Type{InfrastructureSystems.TimeSeriesFormatComponentsAsColumnsNoTime}, file::CSV.File) -> Array{Symbol,1}\n\n\nReturn the column names with values.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_value_columns-Tuple{Type{InfrastructureSystems.TimeSeriesFormatYMDPeriodAsColumn},CSV.File}","page":"API","title":"InfrastructureSystems.get_value_columns","text":"get_value_columns(_::Type{InfrastructureSystems.TimeSeriesFormatYMDPeriodAsColumn}, file::CSV.File) -> Array{Symbol,1}\n\n\nReturn the column names with values (components).\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.get_window-Tuple{InfrastructureSystems.Forecast,Int64}","page":"API","title":"InfrastructureSystems.get_window","text":"get_window(forecast::InfrastructureSystems.Forecast, index::Int64; len) -> Any\n\n\nReturn the forecast window corresponsing to interval index.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.has_component-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.Components,AbstractString}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.has_component","text":"has_component(_::Type{T<:InfrastructureSystems.InfrastructureSystemsComponent}, components::InfrastructureSystems.Components, name::AbstractString) -> Bool\n\n\nCheck to see if a component exists.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.has_time_series-Tuple{InfrastructureSystems.InfrastructureSystemsComponent}","page":"API","title":"InfrastructureSystems.has_time_series","text":"has_time_series(component::InfrastructureSystems.InfrastructureSystemsComponent) -> Bool\n\n\nReturn true if the component has time series data.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.has_time_series-Union{Tuple{T}, Tuple{InfrastructureSystems.InfrastructureSystemsComponent,Type{T}}} where T<:InfrastructureSystems.TimeSeriesData","page":"API","title":"InfrastructureSystems.has_time_series","text":"has_time_series(component::InfrastructureSystems.InfrastructureSystemsComponent, _::Type{T<:InfrastructureSystems.TimeSeriesData}) -> Bool\n\n\nReturn true if the component has time series data of type T.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.head-Tuple{InfrastructureSystems.SingleTimeSeries}","page":"API","title":"InfrastructureSystems.head","text":"head(time_series::InfrastructureSystems.SingleTimeSeries) -> Any\n\n\nReturn a time_series with only the first num values.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.increment_count!-Tuple{InfrastructureSystems.LogEventTracker,InfrastructureSystems.LogEvent,Bool}","page":"API","title":"InfrastructureSystems.increment_count!","text":"increment_count!(tracker::InfrastructureSystems.LogEventTracker, event::InfrastructureSystems.LogEvent, suppressed::Bool) -> Union{Nothing, Int64, InfrastructureSystems.LogEvent}\n\n\nIncrements the count of a log event.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.index_to_initial_time-Tuple{InfrastructureSystems.Forecast,Int64}","page":"API","title":"InfrastructureSystems.index_to_initial_time","text":"index_to_initial_time(forecast::InfrastructureSystems.Forecast, index::Int64) -> Any\n\n\nReturn the Dates.DateTime corresponding to an interval index.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.iterate_components-Tuple{InfrastructureSystems.Components}","page":"API","title":"InfrastructureSystems.iterate_components","text":"iterate_components(components::InfrastructureSystems.Components) -> Channel{Any}\n\n\nIterates over all components.\n\nExamples\n\nfor component in iterate_components(obj)\n    @show component\nend\n\nSee also: get_components\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.list_recorder_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T<:InfrastructureSystems.AbstractRecorderEvent","page":"API","title":"InfrastructureSystems.list_recorder_events","text":"Return the events of type T in filename.\n\nArguments\n\nT: event type\nfilename::AbstractString: filename containing recorder events\nfilter_func::Union{Nothing, Function} = nothing: Optional function that accepts an event  of type T and returns a Bool. Apply this function to each event and only return events  where the result is true.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.make_time_array-Tuple{InfrastructureSystems.Forecast,Dates.DateTime}","page":"API","title":"InfrastructureSystems.make_time_array","text":"make_time_array(forecast::InfrastructureSystems.Forecast, start_time::Dates.DateTime; len) -> Any\n\n\nReturn a TimeSeries.TimeArray for one forecast window.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.make_time_series!-Tuple{InfrastructureSystems.TimeSeriesParsingCache,InfrastructureSystems.TimeSeriesFileMetadata}","page":"API","title":"InfrastructureSystems.make_time_series!","text":"make_time_series!(cache::InfrastructureSystems.TimeSeriesParsingCache, ts_file_metadata::InfrastructureSystems.TimeSeriesFileMetadata) -> Any\n\n\nReturn a time series from TimeSeriesFileMetadata.\n\nArguments\n\ncache::TimeSeriesParsingCache: cached data\nts_file_metadata::TimeSeriesFileMetadata: metadata\nresolution::{Nothing, Dates.Period}: skip any time_series that don't match this resolution\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.mask_component!-Tuple{InfrastructureSystems.SystemData,InfrastructureSystems.InfrastructureSystemsComponent}","page":"API","title":"InfrastructureSystems.mask_component!","text":"mask_component!(data::InfrastructureSystems.SystemData, component::InfrastructureSystems.InfrastructureSystemsComponent)\n\n\nRemoves the component from the main container and adds it to the masked container.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.open_file_logger","page":"API","title":"InfrastructureSystems.open_file_logger","text":"open_file_logger(func::Function, filename::String) -> Any\nopen_file_logger(func::Function, filename::String, level) -> Any\nopen_file_logger(func::Function, filename::String, level, mode) -> Any\n\n\nOpens a file logger using Logging.SimpleLogger.\n\nExample\n\nopen_file_logger(\"log.txt\", Logging.Info) do logger\n    global_logger(logger)\n    @info \"hello world\"\nend\n\n\n\n\n\n","category":"function"},{"location":"InfrastructureSystems/#InfrastructureSystems.prepare_for_removal!-Tuple{InfrastructureSystems.InfrastructureSystemsComponent}","page":"API","title":"InfrastructureSystems.prepare_for_removal!","text":"prepare_for_removal!(component::InfrastructureSystems.InfrastructureSystemsComponent)\n\n\nThis function must be called when a component is removed from a system.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.prepare_for_serialization!-Tuple{InfrastructureSystems.SystemData,AbstractString}","page":"API","title":"InfrastructureSystems.prepare_for_serialization!","text":"prepare_for_serialization!(data::InfrastructureSystems.SystemData, filename::AbstractString; force)\n\n\nParent object should call this prior to serialization so that SystemData can store the appropriate path information for the time series data.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.read_time_series-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Any}} where T<:InfrastructureSystems.TimeSeriesData","page":"API","title":"InfrastructureSystems.read_time_series","text":"read_time_series(::Type{T<:InfrastructureSystems.TimeSeriesData}, data_file::AbstractString) -> InfrastructureSystems.RawTimeSeries\nread_time_series(::Type{T<:InfrastructureSystems.TimeSeriesData}, data_file::AbstractString, component_name; kwargs...) -> InfrastructureSystems.RawTimeSeries\n\n\nReturn a TimeArray from a CSV file.\n\nPass component_name when the file does not have the component name in a column header.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.read_time_series-Union{Tuple{T}, Tuple{Type{T},Type{#s27} where #s27<:InfrastructureSystems.StaticTimeSeries,CSV.File}, Tuple{Type{T},Type{#s26} where #s26<:InfrastructureSystems.StaticTimeSeries,CSV.File,Any}} where T<:InfrastructureSystems.TimeSeriesFormatComponentsAsColumnsNoTime","page":"API","title":"InfrastructureSystems.read_time_series","text":"read_time_series(::Type{T<:InfrastructureSystems.TimeSeriesFormatComponentsAsColumnsNoTime}, ::Type{#s27} where #s27<:InfrastructureSystems.StaticTimeSeries, file::CSV.File) -> InfrastructureSystems.RawTimeSeries\nread_time_series(::Type{T<:InfrastructureSystems.TimeSeriesFormatComponentsAsColumnsNoTime}, ::Type{#s26} where #s26<:InfrastructureSystems.StaticTimeSeries, file::CSV.File, component_name; kwargs...) -> InfrastructureSystems.RawTimeSeries\n\n\nThis version of the function only has component_name to match the interface. It is unused.\n\nSet start_datetime as a keyword argument for the starting timestamp, otherwise the current day is used.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.read_time_series-Union{Tuple{T}, Tuple{Type{T},Type{#s27} where #s27<:InfrastructureSystems.StaticTimeSeries,CSV.File}, Tuple{Type{T},Type{#s26} where #s26<:InfrastructureSystems.StaticTimeSeries,CSV.File,Any}} where T<:Union{InfrastructureSystems.TimeSeriesFormatDateTimeAsColumn, InfrastructureSystems.TimeSeriesFormatPeriodAsColumn}","page":"API","title":"InfrastructureSystems.read_time_series","text":"read_time_series(::Type{T<:Union{InfrastructureSystems.TimeSeriesFormatDateTimeAsColumn, InfrastructureSystems.TimeSeriesFormatPeriodAsColumn}}, ::Type{#s27} where #s27<:InfrastructureSystems.StaticTimeSeries, file::CSV.File) -> InfrastructureSystems.RawTimeSeries\nread_time_series(::Type{T<:Union{InfrastructureSystems.TimeSeriesFormatDateTimeAsColumn, InfrastructureSystems.TimeSeriesFormatPeriodAsColumn}}, ::Type{#s26} where #s26<:InfrastructureSystems.StaticTimeSeries, file::CSV.File, component_name; kwargs...) -> InfrastructureSystems.RawTimeSeries\n\n\nReturn a TimeSeries.TimeArray representing the CSV file.\n\nThis version of the function only has component_name to match the interface. It is unused.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.read_time_series-Union{Tuple{T}, Tuple{Type{T},Type{#s61} where #s61<:InfrastructureSystems.StaticTimeSeries,CSV.File,AbstractString}} where T<:InfrastructureSystems.TimeSeriesFormatPeriodAsHeader","page":"API","title":"InfrastructureSystems.read_time_series","text":"read_time_series(::Type{T<:InfrastructureSystems.TimeSeriesFormatPeriodAsHeader}, ::Type{#s61} where #s61<:InfrastructureSystems.StaticTimeSeries, file::CSV.File, component_name::AbstractString; kwargs...) -> InfrastructureSystems.RawTimeSeries\n\n\nThis version of the function supports the format where there is no column header for a component, so the component_name must be passed in.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.read_time_series-Union{Tuple{T}, Tuple{Type{T},Type{InfrastructureSystems.Deterministic},CSV.File}, Tuple{Type{T},Type{InfrastructureSystems.Deterministic},CSV.File,Any}} where T<:InfrastructureSystems.TimeSeriesFormatDateTimeAsColumn","page":"API","title":"InfrastructureSystems.read_time_series","text":"read_time_series(::Type{T<:InfrastructureSystems.TimeSeriesFormatDateTimeAsColumn}, ::Type{InfrastructureSystems.Deterministic}, file::CSV.File) -> InfrastructureSystems.RawTimeSeries\nread_time_series(::Type{T<:InfrastructureSystems.TimeSeriesFormatDateTimeAsColumn}, ::Type{InfrastructureSystems.Deterministic}, file::CSV.File, component_name; kwargs...) -> InfrastructureSystems.RawTimeSeries\n\n\nReturn a RawTimeSeries from a CSV file.\n\nPass component_name when the file does not have the component name in a column header.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.read_time_series_file_metadata-Tuple{AbstractString}","page":"API","title":"InfrastructureSystems.read_time_series_file_metadata","text":"read_time_series_file_metadata(file_path::AbstractString) -> Any\n\n\nReads time_series metadata and fixes relative paths to the data files.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.redirect_stdout_to_log-Tuple{Function}","page":"API","title":"InfrastructureSystems.redirect_stdout_to_log","text":"redirect_stdout_to_log(func::Function) -> Any\n\n\nRedirect all data written to stdout by a function to log events.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.register_recorder!-Tuple{Symbol}","page":"API","title":"InfrastructureSystems.register_recorder!","text":"register_recorder!(name::Symbol; io, mode, directory)\n\n\nRegister a recorder to log events. Afterwards, calls to @record name <event-type>() will record the event as JSON in <name>.log.\n\nCallers should guarantee that unregister_recorder! is called to close the file handle.\n\nArguments\n\nname::Symbol: name of recorder\nio::Union{Nothing, IO}:  If nothing, record events in a file using name.\nmode = \"w\":  Only used when io is nothing.\ndirectory = \".\":  Only used when io is nothing.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.remove_component!-Union{Tuple{T}, Tuple{InfrastructureSystems.Components,T}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.remove_component!","text":"Remove a component by its value.\n\nThrows ArgumentError if the component is not stored.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.remove_component!-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.Components,AbstractString}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.remove_component!","text":"Remove a component by its name.\n\nThrows ArgumentError if the component is not stored.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.remove_components!-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.Components}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.remove_components!","text":"remove_components!(_::Type{T<:InfrastructureSystems.InfrastructureSystemsComponent}, components::InfrastructureSystems.Components) -> Base.ValueIterator\n\n\nRemove all components of type T.\n\nThrows ArgumentError if the type is not stored.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.remove_time_series!-Union{Tuple{T}, Tuple{InfrastructureSystems.SystemData,Type{T},InfrastructureSystems.InfrastructureSystemsComponent,String}} where T<:InfrastructureSystems.TimeSeriesData","page":"API","title":"InfrastructureSystems.remove_time_series!","text":"remove_time_series!(data::InfrastructureSystems.SystemData, _::Type{T<:InfrastructureSystems.TimeSeriesData}, component::InfrastructureSystems.InfrastructureSystemsComponent, name::String)\n\n\nRemove the time series data for a component.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.remove_time_series!-Union{Tuple{T}, Tuple{InfrastructureSystems.SystemData,Type{T}}} where T<:InfrastructureSystems.TimeSeriesData","page":"API","title":"InfrastructureSystems.remove_time_series!","text":"remove_time_series!(data::InfrastructureSystems.SystemData, _::Type{T<:InfrastructureSystems.TimeSeriesData})\n\n\nRemoves all time series of a particular type from a System.\n\nArguments\n\ndata::SystemData: system\ntype::Type{<:TimeSeriesData}: Type of time series objects to remove.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.remove_time_series_metadata!-Union{Tuple{T}, Tuple{InfrastructureSystems.InfrastructureSystemsComponent,Type{T},AbstractString}} where T<:InfrastructureSystems.TimeSeriesMetadata","page":"API","title":"InfrastructureSystems.remove_time_series_metadata!","text":"remove_time_series_metadata!(component::InfrastructureSystems.InfrastructureSystemsComponent, _::Type{T<:InfrastructureSystems.TimeSeriesMetadata}, name::AbstractString) -> Bool\n\n\nRemoves the metadata for a time_series. If this returns true then the caller must also remove the actual time series data.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.replace_iterator-Tuple{InfrastructureSystems.LazyDictFromIterator,Any}","page":"API","title":"InfrastructureSystems.replace_iterator","text":"replace_iterator(container::InfrastructureSystems.LazyDictFromIterator, iter)\n\n\nReplace the iterator, maintaining the cached dict.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.report_log_summary-Tuple{InfrastructureSystems.LogEventTracker}","page":"API","title":"InfrastructureSystems.report_log_summary","text":"report_log_summary(tracker::InfrastructureSystems.LogEventTracker) -> String\n\n\nReturns a summary of log event counts by level.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.report_log_summary-Tuple{InfrastructureSystems.MultiLogger}","page":"API","title":"InfrastructureSystems.report_log_summary","text":"report_log_summary(logger::InfrastructureSystems.MultiLogger) -> String\n\n\nReturns a summary of log event counts by level.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.reset!-Tuple{InfrastructureSystems.TimeSeriesCache}","page":"API","title":"InfrastructureSystems.reset!","text":"reset!(cache::InfrastructureSystems.TimeSeriesCache)\n\n\nReset parameters in order to start reading data from the beginning with get_next_time_series_array!\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.reset_iterator-Tuple{InfrastructureSystems.LazyDictFromIterator}","page":"API","title":"InfrastructureSystems.reset_iterator","text":"reset_iterator(container::InfrastructureSystems.LazyDictFromIterator)\n\n\nReset the iterator for cases where underlying arrays have changed.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.serialize-Union{Tuple{T}, Tuple{T}} where T<:InfrastructureSystems.InfrastructureSystemsType","page":"API","title":"InfrastructureSystems.serialize","text":"Serialize the Julia value into standard types that can be converted to non-Julia formats, such as JSON. In cases where val is an instance of a struct, return a Dict. In cases where val is a scalar value, return that value.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_component!-Tuple{InfrastructureSystems.TimeSeriesFileMetadata,InfrastructureSystems.SystemData,Module}","page":"API","title":"InfrastructureSystems.set_component!","text":"set_component!(metadata::InfrastructureSystems.TimeSeriesFileMetadata, data::InfrastructureSystems.SystemData, mod::Module) -> Any\n\n\nSet the component value in metadata by looking up the category in module. This requires that category be a string version of a component's abstract type. Modules can override for custom behavior.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_count!-Tuple{InfrastructureSystems.DeterministicMetadata,Any}","page":"API","title":"InfrastructureSystems.set_count!","text":"set_count!(value::InfrastructureSystems.DeterministicMetadata, val) -> Any\n\n\nSet DeterministicMetadata count.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_count!-Tuple{InfrastructureSystems.DeterministicSingleTimeSeries,Any}","page":"API","title":"InfrastructureSystems.set_count!","text":"set_count!(value::InfrastructureSystems.DeterministicSingleTimeSeries, val) -> Any\n\n\nSet DeterministicSingleTimeSeries count.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_count!-Tuple{InfrastructureSystems.ProbabilisticMetadata,Any}","page":"API","title":"InfrastructureSystems.set_count!","text":"set_count!(value::InfrastructureSystems.ProbabilisticMetadata, val) -> Any\n\n\nSet ProbabilisticMetadata count.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_count!-Tuple{InfrastructureSystems.ScenariosMetadata,Any}","page":"API","title":"InfrastructureSystems.set_count!","text":"set_count!(value::InfrastructureSystems.ScenariosMetadata, val) -> Any\n\n\nSet ScenariosMetadata count.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_data!-Tuple{InfrastructureSystems.Deterministic,Any}","page":"API","title":"InfrastructureSystems.set_data!","text":"set_data!(value::InfrastructureSystems.Deterministic, val) -> Any\n\n\nSet Deterministic data.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_data!-Tuple{InfrastructureSystems.Probabilistic,Any}","page":"API","title":"InfrastructureSystems.set_data!","text":"set_data!(value::InfrastructureSystems.Probabilistic, val) -> Any\n\n\nSet Probabilistic data.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_data!-Tuple{InfrastructureSystems.Scenarios,Any}","page":"API","title":"InfrastructureSystems.set_data!","text":"set_data!(value::InfrastructureSystems.Scenarios, val) -> Any\n\n\nSet Scenarios data.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_data!-Tuple{InfrastructureSystems.SingleTimeSeries,Any}","page":"API","title":"InfrastructureSystems.set_data!","text":"set_data!(value::InfrastructureSystems.SingleTimeSeries, val) -> Any\n\n\nSet SingleTimeSeries data.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_group_level!-Tuple{InfrastructureSystems.MultiLogger,Symbol,Base.CoreLogging.LogLevel}","page":"API","title":"InfrastructureSystems.set_group_level!","text":"set_group_level!(logger::InfrastructureSystems.MultiLogger, group::Symbol, level::Base.CoreLogging.LogLevel)\n\n\nSet the minimum log level for a group.\n\nThe group field of a log message defaults to its file's base name (no extension) as a symbol. It can be customized by setting _group = :a_group_name.\n\nThe minimum log level stored for a console or file logger supercede this setting.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_group_levels!-Tuple{InfrastructureSystems.MultiLogger,Dict{Symbol,Base.CoreLogging.LogLevel}}","page":"API","title":"InfrastructureSystems.set_group_levels!","text":"set_group_levels!(logger::InfrastructureSystems.MultiLogger, group_levels::Dict{Symbol,Base.CoreLogging.LogLevel})\n\n\nSet the minimum log levels for multiple groups. Refer to set_group_level for more information.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_horizon!-Tuple{InfrastructureSystems.DeterministicMetadata,Any}","page":"API","title":"InfrastructureSystems.set_horizon!","text":"set_horizon!(value::InfrastructureSystems.DeterministicMetadata, val) -> Any\n\n\nSet DeterministicMetadata horizon.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_horizon!-Tuple{InfrastructureSystems.DeterministicSingleTimeSeries,Any}","page":"API","title":"InfrastructureSystems.set_horizon!","text":"set_horizon!(value::InfrastructureSystems.DeterministicSingleTimeSeries, val) -> Any\n\n\nSet DeterministicSingleTimeSeries horizon.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_horizon!-Tuple{InfrastructureSystems.ProbabilisticMetadata,Any}","page":"API","title":"InfrastructureSystems.set_horizon!","text":"set_horizon!(value::InfrastructureSystems.ProbabilisticMetadata, val) -> Any\n\n\nSet ProbabilisticMetadata horizon.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_horizon!-Tuple{InfrastructureSystems.ScenariosMetadata,Any}","page":"API","title":"InfrastructureSystems.set_horizon!","text":"set_horizon!(value::InfrastructureSystems.ScenariosMetadata, val) -> Any\n\n\nSet ScenariosMetadata horizon.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_initial_timestamp!-Tuple{InfrastructureSystems.DeterministicMetadata,Any}","page":"API","title":"InfrastructureSystems.set_initial_timestamp!","text":"set_initial_timestamp!(value::InfrastructureSystems.DeterministicMetadata, val) -> Any\n\n\nSet DeterministicMetadata initial_timestamp.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_initial_timestamp!-Tuple{InfrastructureSystems.DeterministicSingleTimeSeries,Any}","page":"API","title":"InfrastructureSystems.set_initial_timestamp!","text":"set_initial_timestamp!(value::InfrastructureSystems.DeterministicSingleTimeSeries, val) -> Any\n\n\nSet DeterministicSingleTimeSeries initial_timestamp.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_initial_timestamp!-Tuple{InfrastructureSystems.ProbabilisticMetadata,Any}","page":"API","title":"InfrastructureSystems.set_initial_timestamp!","text":"set_initial_timestamp!(value::InfrastructureSystems.ProbabilisticMetadata, val) -> Any\n\n\nSet ProbabilisticMetadata initial_timestamp.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_initial_timestamp!-Tuple{InfrastructureSystems.ScenariosMetadata,Any}","page":"API","title":"InfrastructureSystems.set_initial_timestamp!","text":"set_initial_timestamp!(value::InfrastructureSystems.ScenariosMetadata, val) -> Any\n\n\nSet ScenariosMetadata initial_timestamp.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_initial_timestamp!-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata,Any}","page":"API","title":"InfrastructureSystems.set_initial_timestamp!","text":"set_initial_timestamp!(value::InfrastructureSystems.SingleTimeSeriesMetadata, val) -> Any\n\n\nSet SingleTimeSeriesMetadata initial_timestamp.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_internal!-Tuple{InfrastructureSystems.Deterministic,Any}","page":"API","title":"InfrastructureSystems.set_internal!","text":"set_internal!(value::InfrastructureSystems.Deterministic, val) -> Any\n\n\nSet Deterministic internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_internal!-Tuple{InfrastructureSystems.DeterministicMetadata,Any}","page":"API","title":"InfrastructureSystems.set_internal!","text":"set_internal!(value::InfrastructureSystems.DeterministicMetadata, val) -> Any\n\n\nSet DeterministicMetadata internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_internal!-Tuple{InfrastructureSystems.Probabilistic,Any}","page":"API","title":"InfrastructureSystems.set_internal!","text":"set_internal!(value::InfrastructureSystems.Probabilistic, val) -> Any\n\n\nSet Probabilistic internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_internal!-Tuple{InfrastructureSystems.ProbabilisticMetadata,Any}","page":"API","title":"InfrastructureSystems.set_internal!","text":"set_internal!(value::InfrastructureSystems.ProbabilisticMetadata, val) -> Any\n\n\nSet ProbabilisticMetadata internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_internal!-Tuple{InfrastructureSystems.Scenarios,Any}","page":"API","title":"InfrastructureSystems.set_internal!","text":"set_internal!(value::InfrastructureSystems.Scenarios, val) -> Any\n\n\nSet Scenarios internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_internal!-Tuple{InfrastructureSystems.ScenariosMetadata,Any}","page":"API","title":"InfrastructureSystems.set_internal!","text":"set_internal!(value::InfrastructureSystems.ScenariosMetadata, val) -> Any\n\n\nSet ScenariosMetadata internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_internal!-Tuple{InfrastructureSystems.SingleTimeSeries,Any}","page":"API","title":"InfrastructureSystems.set_internal!","text":"set_internal!(value::InfrastructureSystems.SingleTimeSeries, val) -> Any\n\n\nSet SingleTimeSeries internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_internal!-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata,Any}","page":"API","title":"InfrastructureSystems.set_internal!","text":"set_internal!(value::InfrastructureSystems.SingleTimeSeriesMetadata, val) -> Any\n\n\nSet SingleTimeSeriesMetadata internal.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_interval!-Tuple{InfrastructureSystems.DeterministicMetadata,Any}","page":"API","title":"InfrastructureSystems.set_interval!","text":"set_interval!(value::InfrastructureSystems.DeterministicMetadata, val) -> Any\n\n\nSet DeterministicMetadata interval.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_interval!-Tuple{InfrastructureSystems.DeterministicSingleTimeSeries,Any}","page":"API","title":"InfrastructureSystems.set_interval!","text":"set_interval!(value::InfrastructureSystems.DeterministicSingleTimeSeries, val) -> Any\n\n\nSet DeterministicSingleTimeSeries interval.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_interval!-Tuple{InfrastructureSystems.ProbabilisticMetadata,Any}","page":"API","title":"InfrastructureSystems.set_interval!","text":"set_interval!(value::InfrastructureSystems.ProbabilisticMetadata, val) -> Any\n\n\nSet ProbabilisticMetadata interval.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_interval!-Tuple{InfrastructureSystems.ScenariosMetadata,Any}","page":"API","title":"InfrastructureSystems.set_interval!","text":"set_interval!(value::InfrastructureSystems.ScenariosMetadata, val) -> Any\n\n\nSet ScenariosMetadata interval.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_length!-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata,Any}","page":"API","title":"InfrastructureSystems.set_length!","text":"set_length!(value::InfrastructureSystems.SingleTimeSeriesMetadata, val) -> Any\n\n\nSet SingleTimeSeriesMetadata length.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_name!-Tuple{InfrastructureSystems.Deterministic,Any}","page":"API","title":"InfrastructureSystems.set_name!","text":"set_name!(value::InfrastructureSystems.Deterministic, val) -> Any\n\n\nSet Deterministic name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_name!-Tuple{InfrastructureSystems.DeterministicMetadata,Any}","page":"API","title":"InfrastructureSystems.set_name!","text":"set_name!(value::InfrastructureSystems.DeterministicMetadata, val) -> Any\n\n\nSet DeterministicMetadata name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_name!-Tuple{InfrastructureSystems.Probabilistic,Any}","page":"API","title":"InfrastructureSystems.set_name!","text":"set_name!(value::InfrastructureSystems.Probabilistic, val) -> Any\n\n\nSet Probabilistic name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_name!-Tuple{InfrastructureSystems.ProbabilisticMetadata,Any}","page":"API","title":"InfrastructureSystems.set_name!","text":"set_name!(value::InfrastructureSystems.ProbabilisticMetadata, val) -> Any\n\n\nSet ProbabilisticMetadata name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_name!-Tuple{InfrastructureSystems.Scenarios,Any}","page":"API","title":"InfrastructureSystems.set_name!","text":"set_name!(value::InfrastructureSystems.Scenarios, val) -> Any\n\n\nSet Scenarios name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_name!-Tuple{InfrastructureSystems.ScenariosMetadata,Any}","page":"API","title":"InfrastructureSystems.set_name!","text":"set_name!(value::InfrastructureSystems.ScenariosMetadata, val) -> Any\n\n\nSet ScenariosMetadata name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_name!-Tuple{InfrastructureSystems.SingleTimeSeries,Any}","page":"API","title":"InfrastructureSystems.set_name!","text":"set_name!(value::InfrastructureSystems.SingleTimeSeries, val) -> Any\n\n\nSet SingleTimeSeries name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_name!-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata,Any}","page":"API","title":"InfrastructureSystems.set_name!","text":"set_name!(value::InfrastructureSystems.SingleTimeSeriesMetadata, val) -> Any\n\n\nSet SingleTimeSeriesMetadata name.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_percentiles!-Tuple{InfrastructureSystems.Probabilistic,Any}","page":"API","title":"InfrastructureSystems.set_percentiles!","text":"set_percentiles!(value::InfrastructureSystems.Probabilistic, val) -> Any\n\n\nSet Probabilistic percentiles.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_percentiles!-Tuple{InfrastructureSystems.ProbabilisticMetadata,Any}","page":"API","title":"InfrastructureSystems.set_percentiles!","text":"set_percentiles!(value::InfrastructureSystems.ProbabilisticMetadata, val) -> Any\n\n\nSet ProbabilisticMetadata percentiles.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_resolution!-Tuple{InfrastructureSystems.Deterministic,Any}","page":"API","title":"InfrastructureSystems.set_resolution!","text":"set_resolution!(value::InfrastructureSystems.Deterministic, val) -> Any\n\n\nSet Deterministic resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_resolution!-Tuple{InfrastructureSystems.DeterministicMetadata,Any}","page":"API","title":"InfrastructureSystems.set_resolution!","text":"set_resolution!(value::InfrastructureSystems.DeterministicMetadata, val) -> Any\n\n\nSet DeterministicMetadata resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_resolution!-Tuple{InfrastructureSystems.Probabilistic,Any}","page":"API","title":"InfrastructureSystems.set_resolution!","text":"set_resolution!(value::InfrastructureSystems.Probabilistic, val) -> Any\n\n\nSet Probabilistic resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_resolution!-Tuple{InfrastructureSystems.ProbabilisticMetadata,Any}","page":"API","title":"InfrastructureSystems.set_resolution!","text":"set_resolution!(value::InfrastructureSystems.ProbabilisticMetadata, val) -> Any\n\n\nSet ProbabilisticMetadata resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_resolution!-Tuple{InfrastructureSystems.Scenarios,Any}","page":"API","title":"InfrastructureSystems.set_resolution!","text":"set_resolution!(value::InfrastructureSystems.Scenarios, val) -> Any\n\n\nSet Scenarios resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_resolution!-Tuple{InfrastructureSystems.ScenariosMetadata,Any}","page":"API","title":"InfrastructureSystems.set_resolution!","text":"set_resolution!(value::InfrastructureSystems.ScenariosMetadata, val) -> Any\n\n\nSet ScenariosMetadata resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_resolution!-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata,Any}","page":"API","title":"InfrastructureSystems.set_resolution!","text":"set_resolution!(value::InfrastructureSystems.SingleTimeSeriesMetadata, val) -> Any\n\n\nSet SingleTimeSeriesMetadata resolution.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{InfrastructureSystems.Deterministic,Any}","page":"API","title":"InfrastructureSystems.set_scaling_factor_multiplier!","text":"set_scaling_factor_multiplier!(value::InfrastructureSystems.Deterministic, val) -> Any\n\n\nSet Deterministic scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{InfrastructureSystems.DeterministicMetadata,Any}","page":"API","title":"InfrastructureSystems.set_scaling_factor_multiplier!","text":"set_scaling_factor_multiplier!(value::InfrastructureSystems.DeterministicMetadata, val) -> Any\n\n\nSet DeterministicMetadata scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{InfrastructureSystems.Probabilistic,Any}","page":"API","title":"InfrastructureSystems.set_scaling_factor_multiplier!","text":"set_scaling_factor_multiplier!(value::InfrastructureSystems.Probabilistic, val) -> Any\n\n\nSet Probabilistic scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{InfrastructureSystems.ProbabilisticMetadata,Any}","page":"API","title":"InfrastructureSystems.set_scaling_factor_multiplier!","text":"set_scaling_factor_multiplier!(value::InfrastructureSystems.ProbabilisticMetadata, val) -> Any\n\n\nSet ProbabilisticMetadata scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{InfrastructureSystems.Scenarios,Any}","page":"API","title":"InfrastructureSystems.set_scaling_factor_multiplier!","text":"set_scaling_factor_multiplier!(value::InfrastructureSystems.Scenarios, val) -> Any\n\n\nSet Scenarios scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{InfrastructureSystems.ScenariosMetadata,Any}","page":"API","title":"InfrastructureSystems.set_scaling_factor_multiplier!","text":"set_scaling_factor_multiplier!(value::InfrastructureSystems.ScenariosMetadata, val) -> Any\n\n\nSet ScenariosMetadata scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{InfrastructureSystems.SingleTimeSeries,Any}","page":"API","title":"InfrastructureSystems.set_scaling_factor_multiplier!","text":"set_scaling_factor_multiplier!(value::InfrastructureSystems.SingleTimeSeries, val) -> Any\n\n\nSet SingleTimeSeries scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata,Any}","page":"API","title":"InfrastructureSystems.set_scaling_factor_multiplier!","text":"set_scaling_factor_multiplier!(value::InfrastructureSystems.SingleTimeSeriesMetadata, val) -> Any\n\n\nSet SingleTimeSeriesMetadata scaling_factor_multiplier.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_scenario_count!-Tuple{InfrastructureSystems.Scenarios,Any}","page":"API","title":"InfrastructureSystems.set_scenario_count!","text":"set_scenario_count!(value::InfrastructureSystems.Scenarios, val) -> Any\n\n\nSet Scenarios scenario_count.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_scenario_count!-Tuple{InfrastructureSystems.ScenariosMetadata,Any}","page":"API","title":"InfrastructureSystems.set_scenario_count!","text":"set_scenario_count!(value::InfrastructureSystems.ScenariosMetadata, val) -> Any\n\n\nSet ScenariosMetadata scenario_count.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_single_time_series!-Tuple{InfrastructureSystems.DeterministicSingleTimeSeries,Any}","page":"API","title":"InfrastructureSystems.set_single_time_series!","text":"set_single_time_series!(value::InfrastructureSystems.DeterministicSingleTimeSeries, val) -> Any\n\n\nSet DeterministicSingleTimeSeries single_time_series.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_time_series_type!-Tuple{InfrastructureSystems.DeterministicMetadata,Any}","page":"API","title":"InfrastructureSystems.set_time_series_type!","text":"set_time_series_type!(value::InfrastructureSystems.DeterministicMetadata, val) -> Any\n\n\nSet DeterministicMetadata time_series_type.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_time_series_uuid!-Tuple{InfrastructureSystems.DeterministicMetadata,Any}","page":"API","title":"InfrastructureSystems.set_time_series_uuid!","text":"set_time_series_uuid!(value::InfrastructureSystems.DeterministicMetadata, val) -> Any\n\n\nSet DeterministicMetadata time_series_uuid.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_time_series_uuid!-Tuple{InfrastructureSystems.ProbabilisticMetadata,Any}","page":"API","title":"InfrastructureSystems.set_time_series_uuid!","text":"set_time_series_uuid!(value::InfrastructureSystems.ProbabilisticMetadata, val) -> Any\n\n\nSet ProbabilisticMetadata time_series_uuid.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_time_series_uuid!-Tuple{InfrastructureSystems.ScenariosMetadata,Any}","page":"API","title":"InfrastructureSystems.set_time_series_uuid!","text":"set_time_series_uuid!(value::InfrastructureSystems.ScenariosMetadata, val) -> Any\n\n\nSet ScenariosMetadata time_series_uuid.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.set_time_series_uuid!-Tuple{InfrastructureSystems.SingleTimeSeriesMetadata,Any}","page":"API","title":"InfrastructureSystems.set_time_series_uuid!","text":"set_time_series_uuid!(value::InfrastructureSystems.SingleTimeSeriesMetadata, val) -> Any\n\n\nSet SingleTimeSeriesMetadata time_series_uuid.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.show_recorder_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T<:InfrastructureSystems.AbstractRecorderEvent","page":"API","title":"InfrastructureSystems.show_recorder_events","text":"show_recorder_events(::Type{T<:InfrastructureSystems.AbstractRecorderEvent}, filename::AbstractString)\nshow_recorder_events(::Type{T<:InfrastructureSystems.AbstractRecorderEvent}, filename::AbstractString, filter_func::Union{Nothing, Function}; kwargs...)\n\n\nShow the events of type T in filename in a table. Refer to PrettyTables.jl documentation for accepted kwargs.\n\nArguments\n\nT: event type\nfilename::AbstractString: filename containing recorder events\nfilter_func::Union{Nothing, Function} = nothing: Optional function that accepts an event  of type T and returns a Bool. Apply this function to each event and only return events  where the result is true.\nkwargs: Passed to PrettyTables\n\nExamples\n\nshow_recorder_events(TestEvent, test_recorder.log)\nshow_recorder_events(TestEvent, test_recorder.log; x -> x.val2 > 2)\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.strip_module_name-Tuple{String}","page":"API","title":"InfrastructureSystems.strip_module_name","text":"strip_module_name(name::String) -> String\n\n\nStrips the module name off of a type.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.supertypes-Union{Tuple{Type{T}}, Tuple{T}, Tuple{Type{T},Any}} where T","page":"API","title":"InfrastructureSystems.supertypes","text":"supertypes(::Type{T}) -> Array{Any,1}\nsupertypes(::Type{T}, types) -> Any\n\n\nReturns an array of all super types of T.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.tail-Tuple{InfrastructureSystems.SingleTimeSeries}","page":"API","title":"InfrastructureSystems.tail","text":"tail(time_series::InfrastructureSystems.SingleTimeSeries) -> Any\n\n\nReturn a time_series with only the ending num values.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.test_generated_structs-Tuple{Any,Any}","page":"API","title":"InfrastructureSystems.test_generated_structs","text":"test_generated_structs(descriptor_file, existing_dir) -> Bool\n\n\nReturn true if the structs defined in existingdir match structs freshly-generated from descriptorfile.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.to-Tuple{InfrastructureSystems.SingleTimeSeries,Any}","page":"API","title":"InfrastructureSystems.to","text":"to(time_series::InfrastructureSystems.SingleTimeSeries, timestamp) -> InfrastructureSystems.SingleTimeSeries\n\n\nReturn a time_series truncated after timestamp.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.to_json-Union{Tuple{T}, Tuple{T,AbstractString}} where T<:InfrastructureSystems.InfrastructureSystemsType","page":"API","title":"InfrastructureSystems.to_json","text":"to_json(obj::T<:InfrastructureSystems.InfrastructureSystemsType) -> String\n\n\nSerializes a InfrastructureSystemsType to a JSON file.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.to_json-Union{Tuple{T}, Tuple{T}} where T<:InfrastructureSystems.InfrastructureSystemsType","page":"API","title":"InfrastructureSystems.to_json","text":"Serializes a InfrastructureSystemsType to a JSON string.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.transform_single_time_series!-Union{Tuple{T}, Tuple{InfrastructureSystems.SystemData,Type{T},Int64,Dates.Period}} where T<:InfrastructureSystems.DeterministicSingleTimeSeries","page":"API","title":"InfrastructureSystems.transform_single_time_series!","text":"transform_single_time_series!(data::InfrastructureSystems.SystemData, _::Type{T<:InfrastructureSystems.DeterministicSingleTimeSeries}, horizon::Int64, interval::Dates.Period)\n\n\nTransform all instances of SingleTimeSeries to DeterministicSingleTimeSeries.\n\nAny existing DeterministicSingleTimeSeries forecasts will be deleted even if the inputs are invalid.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.transform_single_time_series_internal!-Union{Tuple{T}, Tuple{InfrastructureSystems.InfrastructureSystemsComponent,Type{T},InfrastructureSystems.TimeSeriesParameters}} where T<:InfrastructureSystems.DeterministicSingleTimeSeries","page":"API","title":"InfrastructureSystems.transform_single_time_series_internal!","text":"transform_single_time_series_internal!(component::InfrastructureSystems.InfrastructureSystemsComponent, _::Type{T<:InfrastructureSystems.DeterministicSingleTimeSeries}, params::InfrastructureSystems.TimeSeriesParameters) -> Bool\n\n\nTransform all instances of SingleTimeSeries to DeterministicSingleTimeSeries. Do nothing if the component does not contain any instances.\n\nAll required checks must have been completed by the caller.\n\nReturn true if a transformation occurs.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.type_to_symbol-Tuple{DataType}","page":"API","title":"InfrastructureSystems.type_to_symbol","text":"type_to_symbol(data_type::DataType) -> Symbol\n\n\nConverts a DataType to a Symbol, stripping off the module name(s).\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.unregister_recorder!-Tuple{Symbol}","page":"API","title":"InfrastructureSystems.unregister_recorder!","text":"unregister_recorder!(name::Symbol; close_io) -> Any\n\n\nUnregister the recorder with this name and stop recording events.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.validate_exported_names-Tuple{Module}","page":"API","title":"InfrastructureSystems.validate_exported_names","text":"validate_exported_names(mod::Module) -> Bool\n\n\nReturn true if all publicly exported names in mod are defined.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.validate_struct-Tuple{InfrastructureSystems.InfrastructureSystemsType}","page":"API","title":"InfrastructureSystems.validate_struct","text":"validate_struct(ist::InfrastructureSystems.InfrastructureSystemsType) -> Bool\n\n\nValidates a struct using only information within the struct.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.when-Tuple{InfrastructureSystems.SingleTimeSeries,Function,Integer}","page":"API","title":"InfrastructureSystems.when","text":"when(time_series::InfrastructureSystems.SingleTimeSeries, period::Function, t::Integer) -> Any\n\n\nRefer to TimeSeries.when(). Underlying data is copied.\n\n\n\n\n\n","category":"method"},{"location":"InfrastructureSystems/#InfrastructureSystems.@assert_op-Tuple{Any}","page":"API","title":"InfrastructureSystems.@assert_op","text":"Throw an AssertionError if conditions like op(exp1, exp2) are false, where op is a conditional infix operator.\n\nExamples\n\njulia> a = 3; b = 4;\njulia> @assert_op a == b\nERROR: AssertionError: 3 == 4\n\njulia> @assert_op a + 3 > b + 4\nERROR: AssertionError: 6 > 8\n\n\n\n\n\n","category":"macro"},{"location":"InfrastructureSystems/#InfrastructureSystems.@record-Tuple{Any,Any}","page":"API","title":"InfrastructureSystems.@record","text":"Record an event if the recorder with name is enabled.\n\nArguments\n\nname::Symbol: name of recorder\nevent::AbstractRecorderEvent: event to record\n\nExamples\n\n@record simulation TestEvent(\"start\", 1, 2.0)\n\n\n\n\n\n","category":"macro"},{"location":"InfrastructureSystems/#InfrastructureSystems.@scoped_enum-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"InfrastructureSystems.@scoped_enum","text":"Macro to wrap Enum in a module to keep the top level scope clean.\n\nExamples\n\njulia> @scoped_enum Fruit APPLE = 1 ORANGE = 2\n\njulia> value = Fruit.APPLE\nFruit.APPLE = 1\n\njulia> value = Fruit(1)\nFruit.APPLE = 1\n\njulia> @scoped_enum(Fruit,\n    APPLE = 1,  # comment\n    ORANGE = 2,  # comment\n)\n\n\n\n\n\n","category":"macro"},{"location":"dev_guide/auto_generation/#Auto-Generation-of-Component-Structs","page":"Auto-Generation of Component Structs","title":"Auto-Generation of Component Structs","text":"","category":"section"},{"location":"dev_guide/auto_generation/","page":"Auto-Generation of Component Structs","title":"Auto-Generation of Component Structs","text":"InfrastructureSystems.jl provides a mechanism to auto-generate Julia files containing structs and field accessor functions from JSON descriptors. Here are reasons to consider using this approach:","category":"page"},{"location":"dev_guide/auto_generation/","page":"Auto-Generation of Component Structs","title":"Auto-Generation of Component Structs","text":"Auto-generation allows for easy refactoring of code. Adding fields to many structs can be tedious because you might have to edit many constructors. This process eliminates boiler-plate edits.\nThe JSON descriptor format includes a mechanisim to define range validation on component fields. Validation can be enabled when adding components to a system.\nProvides consistent formatting of structs, fields, and constructors.\nProvides consistent documentation of structs and fields.","category":"page"},{"location":"dev_guide/auto_generation/#Instructions","page":"Auto-Generation of Component Structs","title":"Instructions","text":"","category":"section"},{"location":"dev_guide/auto_generation/","page":"Auto-Generation of Component Structs","title":"Auto-Generation of Component Structs","text":"Create the JSON descriptor file. Follow the PowerSystems.jl example.\nRun the generation script, passing your descriptor file and an output directory.","category":"page"},{"location":"dev_guide/auto_generation/","page":"Auto-Generation of Component Structs","title":"Auto-Generation of Component Structs","text":"InfrastructureSystems.generate_structs(\"./src/descriptors/power_system_structs.json\", \"./src/models/generated\")","category":"page"},{"location":"dev_guide/auto_generation/#Struct-Descriptor-Rules","page":"Auto-Generation of Component Structs","title":"Struct Descriptor Rules","text":"","category":"section"},{"location":"dev_guide/auto_generation/","page":"Auto-Generation of Component Structs","title":"Auto-Generation of Component Structs","text":"Each struct descriptor must define the following fields:","category":"page"},{"location":"dev_guide/auto_generation/","page":"Auto-Generation of Component Structs","title":"Auto-Generation of Component Structs","text":"struct_name: Name of struct\ndocstring: Struct docstring\nfields: Array of struct members. See below for requirements.\nsupertype: Declare the struct with this parent type.","category":"page"},{"location":"dev_guide/auto_generation/","page":"Auto-Generation of Component Structs","title":"Auto-Generation of Component Structs","text":"Required fields for each struct member:","category":"page"},{"location":"dev_guide/auto_generation/","page":"Auto-Generation of Component Structs","title":"Auto-Generation of Component Structs","text":"name: Name of field\ndata_type: Type of field","category":"page"},{"location":"dev_guide/auto_generation/","page":"Auto-Generation of Component Structs","title":"Auto-Generation of Component Structs","text":"Optional fields for each struct member:","category":"page"},{"location":"dev_guide/auto_generation/","page":"Auto-Generation of Component Structs","title":"Auto-Generation of Component Structs","text":"accessor_module: Set this if the the getter/setter function are","category":"page"},{"location":"dev_guide/auto_generation/","page":"Auto-Generation of Component Structs","title":"Auto-Generation of Component Structs","text":"reimplementing a method defined in a different module.","category":"page"},{"location":"dev_guide/auto_generation/","page":"Auto-Generation of Component Structs","title":"Auto-Generation of Component Structs","text":"comment: Field comment\ndefault: The constructors will define this as a default value.\nexclude_setter: Do not generate a setter function for this field.\ninternal_default: Set to true for non-user-facing fields like","category":"page"},{"location":"dev_guide/auto_generation/","page":"Auto-Generation of Component Structs","title":"Auto-Generation of Component Structs","text":"InfrastructureSystemsInternal that have default values.","category":"page"},{"location":"dev_guide/auto_generation/","page":"Auto-Generation of Component Structs","title":"Auto-Generation of Component Structs","text":"needs_conversion: Set to true if the getter and setter function needs to apply unit","category":"page"},{"location":"dev_guide/auto_generation/","page":"Auto-Generation of Component Structs","title":"Auto-Generation of Component Structs","text":"conversion. The type must implement get_value(::InfrastructureSystemsComponent, ::Type) and set_value(::InfrastructureSystemsComponent, ::Type) a for this combination of component type and member type.","category":"page"},{"location":"dev_guide/auto_generation/","page":"Auto-Generation of Component Structs","title":"Auto-Generation of Component Structs","text":"null_value: Value to indicate the value is null, such as 0.0 for floats.","category":"page"},{"location":"dev_guide/auto_generation/","page":"Auto-Generation of Component Structs","title":"Auto-Generation of Component Structs","text":"If all members in the struct define this field then a \"demo\" constructor will be generated. This allows you to enter val = MyType(nothing) in the REPL and see the layout of a struct without worrying about valid values.","category":"page"},{"location":"dev_guide/auto_generation/","page":"Auto-Generation of Component Structs","title":"Auto-Generation of Component Structs","text":"valid_range: Define this as a Dict with min and max and","category":"page"},{"location":"dev_guide/auto_generation/","page":"Auto-Generation of Component Structs","title":"Auto-Generation of Component Structs","text":"InfrastructureSystems will validate any value against that range when you add the component to the system. Use null if one doesn't apply, such as if there is no max limit.","category":"page"},{"location":"dev_guide/auto_generation/","page":"Auto-Generation of Component Structs","title":"Auto-Generation of Component Structs","text":"validation_action: Define this as error or warn. If it is","category":"page"},{"location":"dev_guide/auto_generation/","page":"Auto-Generation of Component Structs","title":"Auto-Generation of Component Structs","text":"error then InfrastructureSystems will raise an exception if the validation code detects a problem. Otherwise, it will log a warning.","category":"page"},{"location":"dev_guide/auto_generation/","page":"Auto-Generation of Component Structs","title":"Auto-Generation of Component Structs","text":"Notes:","category":"page"},{"location":"dev_guide/auto_generation/","page":"Auto-Generation of Component Structs","title":"Auto-Generation of Component Structs","text":"You will need to decide how to manage the generated files. The SIIP packages keep the generated code in the git repository. This is not required. You could choose to generate them at startup.\nYou may need to create custom constructors and this approach will not allow you have put them in the same file as the struct definition.","category":"page"},{"location":"dev_guide/components_and_container/#Managing-Components","page":"Managing Components","title":"Managing Components","text":"","category":"section"},{"location":"dev_guide/components_and_container/","page":"Managing Components","title":"Managing Components","text":"InfrastructureSystems.jl provides a common way of managing component structs in a system.","category":"page"},{"location":"dev_guide/components_and_container/#Type-hierachy","page":"Managing Components","title":"Type hierachy","text":"","category":"section"},{"location":"dev_guide/components_and_container/","page":"Managing Components","title":"Managing Components","text":"Make every component a subtype of InfrastructureSystems.jlComponent.","category":"page"},{"location":"dev_guide/components_and_container/#InfrastructureSystemsInternal","page":"Managing Components","title":"InfrastructureSystemsInternal","text":"","category":"section"},{"location":"dev_guide/components_and_container/","page":"Managing Components","title":"Managing Components","text":"Add this struct to every component struct.","category":"page"},{"location":"dev_guide/components_and_container/","page":"Managing Components","title":"Managing Components","text":"It automatically creates a UUID for the component. This guarantees a unique way to identify the component.\nIt optionally provides an extension dictionary for user data. A user extending your package may want to use your struct but need one more field. Rather than create a new type they can add data to this ext object.","category":"page"},{"location":"dev_guide/components_and_container/#Instructions-to-implement-a-Component","page":"Managing Components","title":"Instructions to implement a Component","text":"","category":"section"},{"location":"dev_guide/components_and_container/","page":"Managing Components","title":"Managing Components","text":"Add the field to your struct. The constructor does not take any parameters.","category":"page"},{"location":"dev_guide/components_and_container/","page":"Managing Components","title":"Managing Components","text":"struct MyComponent\n    internal::InfrastructureSystemsInternal\nend\n\n# Optional\nget_ext(c::MyComponent) = InfrastructureSystems.get_ext(c.ext)\nclear_ext!(c::MyComponent) = InfrastructureSystems.clear_ext(c.ext)","category":"page"},{"location":"dev_guide/components_and_container/","page":"Managing Components","title":"Managing Components","text":"Notes:","category":"page"},{"location":"dev_guide/components_and_container/","page":"Managing Components","title":"Managing Components","text":"InfrastructureSystems.get_uuid with arument obj::InfrastructureSystemsComponent","category":"page"},{"location":"dev_guide/components_and_container/","page":"Managing Components","title":"Managing Components","text":"returns the component UUID.","category":"page"},{"location":"dev_guide/components_and_container/","page":"Managing Components","title":"Managing Components","text":"The extension dictionary is not created until the first time get_ext is called.","category":"page"},{"location":"dev_guide/components_and_container/#Interface-requirements","page":"Managing Components","title":"Interface requirements","text":"","category":"section"},{"location":"dev_guide/components_and_container/","page":"Managing Components","title":"Managing Components","text":"Implement these methods for every struct.","category":"page"},{"location":"dev_guide/components_and_container/","page":"Managing Components","title":"Managing Components","text":"get_internal(c::MyComponent)::InfrastructureSystemsInternal\nget_name(c::MyComponent)::String","category":"page"},{"location":"dev_guide/components_and_container/","page":"Managing Components","title":"Managing Components","text":"If the struct stores time series data:","category":"page"},{"location":"dev_guide/components_and_container/","page":"Managing Components","title":"Managing Components","text":"get_time_series_container(c::MyComponent)::TimeSeriesContainer","category":"page"},{"location":"dev_guide/components_and_container/#Component-Container","page":"Managing Components","title":"Component Container","text":"","category":"section"},{"location":"dev_guide/components_and_container/","page":"Managing Components","title":"Managing Components","text":"InfrastructureSystems.jl provides the SystemData struct to store a collection of components.","category":"page"},{"location":"dev_guide/components_and_container/","page":"Managing Components","title":"Managing Components","text":"It is recommended but not required that you include this struct within your own   system struct for these reasons:","category":"page"},{"location":"dev_guide/components_and_container/","page":"Managing Components","title":"Managing Components","text":"Provides search and iteration with InfrastructureSystems.get_component and InfrastructureSystems.get_components for abstract and concrete types.\nEnforces name uniqueness within a concrete type.\nAllows for component field validation.\nEnables component JSON serialization and deserialization.","category":"page"},{"location":"dev_guide/components_and_container/#Instructions-to-use-the-SystemData-container","page":"Managing Components","title":"Instructions to use the SystemData container","text":"","category":"section"},{"location":"dev_guide/components_and_container/","page":"Managing Components","title":"Managing Components","text":"Add an instance of SystemData to your system struct.\nOptionally pass a component validation descriptor file to the constructor.\nOptionally pass time_series_in_memory = true to the constructor if you know that all time series data will fit in memory and want a performance boost.\nRedirect these function calls to your instance of SystemData.","category":"page"},{"location":"dev_guide/components_and_container/","page":"Managing Components","title":"Managing Components","text":"add_component!\nremove_component!\nget_component\nget_components\nget_components_by_name\nadd_time_series!","category":"page"},{"location":"dev_guide/components_and_container/#Importing-InfrastructureSystems-methods","page":"Managing Components","title":"Importing InfrastructureSystems methods","text":"","category":"section"},{"location":"dev_guide/components_and_container/","page":"Managing Components","title":"Managing Components","text":"It is recommended that you perform redirection on methods that act on SystemData so that those methods don't show up in Julia help or in methods output. For example:","category":"page"},{"location":"dev_guide/components_and_container/","page":"Managing Components","title":"Managing Components","text":"get_time_series_resolution(sys::MySystem) = InfrastructureSystems.get_time_series_resolution(sys.data)","category":"page"},{"location":"dev_guide/components_and_container/","page":"Managing Components","title":"Managing Components","text":"On the other hand, it is recommended that you import methods that act on an InfrastructureSystemsComponent into your package's namespace so that you don't have to duplicate docstrings and perform redirection. For example:","category":"page"},{"location":"dev_guide/components_and_container/","page":"Managing Components","title":"Managing Components","text":"import InfrastructureSystems: get_time_series","category":"page"},{"location":"dev_guide/time_series/#Time-Series-Data","page":"Time Series Data","title":"Time Series Data","text":"","category":"section"},{"location":"dev_guide/time_series/","page":"Time Series Data","title":"Time Series Data","text":"InfrastructureSystems.jl implements containers and routines to efficiently manage time series data. This document contains content for developers of new time series data. For the usage please refer to the documentation in PowerSystems.jl","category":"page"},{"location":"dev_guide/time_series/","page":"Time Series Data","title":"Time Series Data","text":"InfrastructureSystems.jl provides a mechanism to store time series data for components. Here are reasons to consider using it:","category":"page"},{"location":"dev_guide/time_series/","page":"Time Series Data","title":"Time Series Data","text":"Time series data, by default, is stored independently of components in HDF5 files.","category":"page"},{"location":"dev_guide/time_series/","page":"Time Series Data","title":"Time Series Data","text":"Components store references to that data.","category":"page"},{"location":"dev_guide/time_series/","page":"Time Series Data","title":"Time Series Data","text":"System memory is not depleted by loading all time series data at once. Only data that you","category":"page"},{"location":"dev_guide/time_series/","page":"Time Series Data","title":"Time Series Data","text":"need is loaded.","category":"page"},{"location":"dev_guide/time_series/","page":"Time Series Data","title":"Time Series Data","text":"Multiple components can share the same time series data by sharing references instead of","category":"page"},{"location":"dev_guide/time_series/","page":"Time Series Data","title":"Time Series Data","text":"making expensive copies.","category":"page"},{"location":"dev_guide/time_series/","page":"Time Series Data","title":"Time Series Data","text":"Supports serialization and deserialization.\nSupports parsing raw data files of several formats as well as data stored in TimeSeries.TimeArray and DataFrames.DataFrame objects.","category":"page"},{"location":"dev_guide/time_series/","page":"Time Series Data","title":"Time Series Data","text":"Your package must reimplement a deepcopy method if you use HDF5 storage for TimeSeriesData","category":"page"},{"location":"dev_guide/time_series/","page":"Time Series Data","title":"Time Series Data","text":"If you store an instance of InfrastructureSystems.SystemData within your system and then a user calls deepcopy on a system, the .h5 file will not be copied. The new and old instances will have references to the same file. You will need to reimplement deepcopy to handle this. One solution is to serialize and then deserialize the system.","category":"page"},{"location":"dev_guide/time_series/","page":"Time Series Data","title":"Time Series Data","text":"Notes:","category":"page"},{"location":"dev_guide/time_series/","page":"Time Series Data","title":"Time Series Data","text":"Time series data can optionally be stored fully in memory. Refer to the","category":"page"},{"location":"dev_guide/time_series/","page":"Time Series Data","title":"Time Series Data","text":"InfrastructureSystems.SystemData documentation.","category":"page"},{"location":"dev_guide/time_series/","page":"Time Series Data","title":"Time Series Data","text":"InfrastructureSystems.jl creates HDF5 files on the tmp filesystem by default. This can be changed if the time series data is larger than the amount of tmp space available. Refer to the InfrastructureSystems.SystemData link above.","category":"page"},{"location":"dev_guide/time_series/#Instructions","page":"Time Series Data","title":"Instructions","text":"","category":"section"},{"location":"dev_guide/time_series/","page":"Time Series Data","title":"Time Series Data","text":"Add an instance of InfrastructureSystems.TimeSeriesContainer to the component struct.\nImplement the method InfrastructureSystems.get_time_series_container for the component. It must return the TimeSeriesContainer object.","category":"page"},{"location":"dev_guide/time_series/#Data-Format","page":"Time Series Data","title":"Data Format","text":"","category":"section"},{"location":"dev_guide/time_series/","page":"Time Series Data","title":"Time Series Data","text":"Time series arrays are stored in an HDF5 file according the format described here.","category":"page"},{"location":"dev_guide/time_series/","page":"Time Series Data","title":"Time Series Data","text":"The root path /time_series defines these HDF5 attributes to control deserialization:","category":"page"},{"location":"dev_guide/time_series/","page":"Time Series Data","title":"Time Series Data","text":"data_format_version: Designates the InfrastructureSystems format for the file.\ncompression_enabled: Specifies whether compression is enabled and will be used for new time series.\ncompression_type: Specifies the type of compression being used.\ncompression_level: Specifies the level of compression being used.\ncompression_shuffle: Specifies whether the shuffle filter is being used.","category":"page"},{"location":"dev_guide/time_series/","page":"Time Series Data","title":"Time Series Data","text":"Each time series array is stored in an HDF5 group named with the array's UUID. Each group contains a dataset called data which contains the actual data. Each group also contains a group called component_references which contains an HDF5 attribute for each component reference. The component reference uses the format <component_uuid>__<time_series_name>.","category":"page"},{"location":"dev_guide/time_series/","page":"Time Series Data","title":"Time Series Data","text":"Each time series group defines attributes that control how the data will be deserialized into a TimeSeriesData instance.","category":"page"},{"location":"dev_guide/time_series/","page":"Time Series Data","title":"Time Series Data","text":"initial_timestamp: Defines the first timestamp of the array. (All times are not stored.)\nresolution: Resolution of the time series in milliseconds.\ntype: Type of the time series. Subtype of TimeSeriesData.\nmodule: Module that defines the type of the time series.\ndata_type: Describes the type of the array stored.","category":"page"},{"location":"dev_guide/time_series/","page":"Time Series Data","title":"Time Series Data","text":"Example:","category":"page"},{"location":"dev_guide/time_series/","page":"Time Series Data","title":"Time Series Data","text":"/time_series\n    data_format_version = \"1.0.1\"\n    compression_enabled = 1\n    /9f02f706-3394-4af3-8084-8903d302cbba\n        /component_references\n            0b6ecb61-8e8d-4563-b795-f001246c3ea5__max_active_power\n            613ddbc2-b666-4c9d-adb5-fa69e7f40a95__max_active_power\n        /data","category":"page"},{"location":"dev_guide/time_series/#Debugging","page":"Time Series Data","title":"Debugging","text":"","category":"section"},{"location":"dev_guide/time_series/","page":"Time Series Data","title":"Time Series Data","text":"The HDF Group provides tools to inspect and manipulate files. Refer to their website.","category":"page"},{"location":"dev_guide/time_series/","page":"Time Series Data","title":"Time Series Data","text":"HDFView is especially useful for viewing data. Note that using h5ls and h5dump in a terminal combined with UNIX tools like grep can sometimes be faster.","category":"page"},{"location":"dev_guide/time_series/#Maintenance","page":"Time Series Data","title":"Maintenance","text":"","category":"section"},{"location":"dev_guide/time_series/","page":"Time Series Data","title":"Time Series Data","text":"If you delete time series arrays in your system you may notice that the actual size of the HDF5 does not decrease. The only way to recover this space is to build a new file with only the active objects. The HDF5 tools package provides the tool h5repack for this purpose.","category":"page"},{"location":"dev_guide/time_series/","page":"Time Series Data","title":"Time Series Data","text":"$ h5repack time_series.h5 new.h5\n$ mv new.h5 time_series.h5","category":"page"},{"location":"dev_guide/logging/#Logging","page":"Logging","title":"Logging","text":"","category":"section"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"InfrastructureSystems.jl provides a MultiLogger object that allows customized logging to console and file. Refer to the logging documentation.","category":"page"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"If you want to create a package-specific log file during a simulation, consider the workflow used by PowerSimulations.jl. It creates a custom logger in its build!(Simulation) function and then uses Julia's Logging.with_logger function to temporarily take over the global logger during build() and execute().","category":"page"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"This document describes logging facilities available in the modules that use InfrastructureSystems.jl. The examples assume the following imports:","category":"page"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"import Logging\nimport InfrastructureSystems: configure_logging, open_file_logger, MultiLogger, LogEventTracker, make_logging_config_file","category":"page"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"Note: Packages that depend on InfrastructureSystems.jl already re-export configure_logging, open_file_logger, MultiLogger, LogEventTracker","category":"page"},{"location":"dev_guide/logging/#Use-Cases","page":"Logging","title":"Use Cases","text":"","category":"section"},{"location":"dev_guide/logging/#Enable-logging-in-REPL-or-Jupyter-Notebook","page":"Logging","title":"Enable logging in REPL or Jupyter Notebook","text":"","category":"section"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"Use InfrastructureSystems.configure_logging to create a logger with your preferences (console and/or file, levels, etc.).","category":"page"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"Note: log messages are not automatically flushed to files. Call flush(logger) to make this happen.","category":"page"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"Example: Global logger configuration","category":"page"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"logger = configure_logging(; filename=\"log.txt\")\n@info \"hello world\"\nflush(logger)\n@error \"some error\"\nclose(logger)","category":"page"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"You can also configure logging from a configuration file.","category":"page"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"make_logging_config_file(\"logging_config.toml\")\n# Customize in an editor.\nlogger = configure_logging(\"logging_config.toml\")","category":"page"},{"location":"dev_guide/logging/#Enable-debug-logging-for-code-you-are-debugging-but-not-for-noisy-areas-you-don't-care-about.","page":"Logging","title":"Enable debug logging for code you are debugging but not for noisy areas you don't care about.","text":"","category":"section"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"InfrastructureSystems uses the _group field of a log event to perform additional filtering. All debug log messages that run frequently should have this field defined.","category":"page"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"Note that the default value of _group for a log event is its filename. Refer to the Julia docs for more information.","category":"page"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"Run this in the REPL to see commonly-used groups in InfrastructureSystems:","category":"page"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"@show InfrastructureSystems.LOG_GROUPS","category":"page"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"You can tell InfrastructureSystems to filter out messages from a particular group in two ways:","category":"page"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"Specify the group level in the logging_config.toml file mentioned above and configure logging with it.\nChange the logger dynamically from with Julia. Here is an example:","category":"page"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"logger = configure_logging(console_level = Logging.Debug)\nInfrastructureSystems.set_group_level!(logger, InfrastructureSystems.LOG_GROUP_TIME_SERIES, Logging.Info)\n\n# Or many at once.\nInfrastructureSystems.set_group_levels!(\n    logger,\n    Dict(\n        InfrastructureSystems.LOG_GROUP_SERIALIZATION => Logging.Info,\n        InfrastructureSystems.LOG_GROUP_TIME_SERIES => Logging.Info,\n    ),\n)\n\n# Get current settings\nInfrastructureSystems.get_group_levels(logger)\nInfrastructureSystems.get_group_level(logger, InfrastructureSystems.LOG_GROUP_TIME_SERIES)","category":"page"},{"location":"dev_guide/logging/#Log-to-console-and-file-in-an-application-or-unit-test-environment","page":"Logging","title":"Log to console and file in an application or unit test environment","text":"","category":"section"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"Create a MultiLogger from Logging.ConsoleLogger and Logging.SimpleLogger. Use open_file_logger to guarantee that all messages get flushed to the file.","category":"page"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"Example Multilogger configuration","category":"page"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"console_logger = ConsoleLogger(stderr, Logging.Error)\n\nopen_file_logger(\"log.txt\", Logging.Info) do file_logger\n    multi_logger = MultiLogger([console_logger, file_logger])\n    global_logger(multi_logger)\n\n    do_stuff()\nend","category":"page"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"Note: If someone may execute the code in the REPL then wrap that code in a try/finally block and reset the global logger upon exit.","category":"page"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"function run_tests()\n    console_logger = ConsoleLogger(stderr, Logging.Error)\n\n    open_file_logger(\"log.txt\", Logging.Info) do file_logger\n        multi_logger = MultiLogger([console_logger, file_logger])\n        global_logger(multi_logger)\n\n        do_stuff()\n    end\nend\n\nlogger = global_logger()\n\ntry\n    run_tests()\nfinally\n    # Guarantee that the global logger is reset.\n    global_logger(logger)\n    nothing\nend","category":"page"},{"location":"dev_guide/logging/#Suppress-frequent-messages","page":"Logging","title":"Suppress frequent messages","text":"","category":"section"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"The standard Logging module in Julia provides a method to suppress messages. Tag the log message with maxlog = X.","category":"page"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"for i in range(1, length=100)\n    @error \"something happened\" i maxlog = 2\nend","category":"page"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"Only 2 messages will get logged.","category":"page"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"The InfrastructureSystems logger provides a customization to make maxlog apply to a period of time instead of the duration of the Julia process.","category":"page"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"In this example the suppression will timeout and two messages will get logged every five seconds. It will log how many log messages were suppressed on the first message that gets logged after a timeout.","category":"page"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"for i in range(1, length=100)\n    @error \"something happened\" i maxlog = 2 _suppression_period = 5\n    sleep(0.5)\nend","category":"page"},{"location":"dev_guide/logging/#Get-a-summary-of-log-messages","page":"Logging","title":"Get a summary of log messages","text":"","category":"section"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"By default a MultiLogger creates a LogEventTracker that keeps counts of all messages. Call report_log_summary after execution.","category":"page"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"logger = configure_logging(; filename=\"log.txt\")\n@info \"hello world\"\n\n# Include a summary in the log file.\n@info report_log_summary(logger)\nclose(logger)","category":"page"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"The output of the logger can ve explored in the REPL","category":"page"},{"location":"dev_guide/logging/","page":"Logging","title":"Logging","text":"julia> for i in range(1, length=100)\n           @info \"hello\" maxlog=2\n           @warn \"beware\" maxlog=2\n       end\njulia> @info report_log_summary(logger)\n┌ Info:\n│ Log message summary:\n│\n│ 0 Error events:\n│\n│ 1 Warn events:\n│   count=100 at REPL[19]:3\n│     example message=\"beware\"\n│     suppressed=98\n│\n│ 1 Info events:\n│   count=100 at REPL[19]:2\n│     example message=\"hello\"\n└     suppressed=98","category":"page"},{"location":"#InfrastructureSystems.jl","page":"Welcome Page","title":"InfrastructureSystems.jl","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"CurrentModule = InfrastructureSystems","category":"page"},{"location":"#Overview","page":"Welcome Page","title":"Overview","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"InfrastructureSystems.jl is a Julia package that provides data management services and common utility software for the packages in NREL's SIIP Initiative. This package is meant for module development. It is used primarily by PowerSystems.jl and PowerSimulations.jl but is written to be extensible for other kinds of infrastructure models.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"This document describes how to integrate it with other packages.","category":"page"},{"location":"#Installation","page":"Welcome Page","title":"Installation","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The latest stable release of InfrastructureSystems.jl can be installed using the Julia package manager with","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"] add InfrastructureSystems","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"For the current development version, \"checkout\" this package with","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"] add InfrastructureSystems#master","category":"page"},{"location":"#Usage","page":"Welcome Page","title":"Usage","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"InfrastructureSystems.jl does not export any method or struct by design. For detailed use of InfrastructureSystems.jl visit the API section of the documentation.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"InfrastructureSystems.jl provides several utilities for the development of packages, the documentation includes several guides for developers","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"Pages = [\n        \"dev_guide/components_and_container.md\",\n        \"dev_guide/auto_generation.md\",\n        \"dev_guide/time_series.md\",\n        \"dev_guide/recorder.md\",\n        \"dev_guide/tests.md\",\n        \"dev_guide/logging.md\"\n]\nDepth = 1","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"InfrastructureSystems has been developed as part of the Scalable Integrated Infrastructure Planning (SIIP) initiative at the U.S. Department of Energy's National Renewable Energy Laboratory (NREL)","category":"page"},{"location":"dev_guide/recorder/#Recorder-Events","page":"Recorder Events","title":"Recorder Events","text":"","category":"section"},{"location":"dev_guide/recorder/","page":"Recorder Events","title":"Recorder Events","text":"InfrastructureSystems.jl provides a mechanism to store structured data in events that get recorded in one or more files. They can be filtered and displayed in tabular form.","category":"page"},{"location":"dev_guide/recorder/","page":"Recorder Events","title":"Recorder Events","text":"The primary use is to store information that can help debug problems and it is largely used in PowerSimulations.jl. For example, you may want to store all state transitions in a simulation or every update of a variable.  If a problem occurs you can then display filtered tables of that data to figure out what went wrong.","category":"page"},{"location":"dev_guide/recorder/#Instructions","page":"Recorder Events","title":"Instructions","text":"","category":"section"},{"location":"dev_guide/recorder/","page":"Recorder Events","title":"Recorder Events","text":"Create events that are subtypes of InfrastructureSystems.AbstractRecorderEvent. Include an instance of RecorderEventCommon in each struct.\nCall InfrastructureSystems.register_recorder! with arguments recorder-name for each recorder object you want to create.\nDepending on how often your code create events you may want to make this conditional. You may only need it for debug runs.\nPowerSimulations creates one recorder for simulation step and stage start/stop events that is always enabled. It creates another that is optional but used for frequently-generated events.\nCall @InfrastructureSystems.record with arguments recorder-name event","category":"page"},{"location":"dev_guide/recorder/","page":"Recorder Events","title":"Recorder Events","text":"wherever you want to generate events in your code. The event will only get constructed if the recorder is registered.","category":"page"},{"location":"dev_guide/recorder/","page":"Recorder Events","title":"Recorder Events","text":"Call InfrastructureSystems.unregister_recorder! with arguments recorder-name for each registered recorder. You should guarantee this this gets called, even if an exception is thrown.  Otherwise, the file may not get flushed and closed.\nAfter your code runs call InfrastructureSystems.show_recorder_events to view events.  Refer to the docstrings for more information.\nRefer to PowerSimulations.showsimulationevents for an example on how to customize this behavior for your package.","category":"page"},{"location":"dev_guide/tests/#Running-Tests","page":"Running Tests","title":"Running Tests","text":"","category":"section"},{"location":"dev_guide/tests/","page":"Running Tests","title":"Running Tests","text":"Unit tests can be executed in the REPL by executing the following:","category":"page"},{"location":"dev_guide/tests/","page":"Running Tests","title":"Running Tests","text":"julia> ] test","category":"page"},{"location":"dev_guide/tests/","page":"Running Tests","title":"Running Tests","text":"The unit test module supports several customizations to aid development and debug. For instance, runnning a specific test file","category":"page"},{"location":"dev_guide/tests/","page":"Running Tests","title":"Running Tests","text":"Run a subset of tests in the REPL:","category":"page"},{"location":"dev_guide/tests/","page":"Running Tests","title":"Running Tests","text":"julia> push!(ARGS, \"<test_filename_without_.jl>\")\njulia> include(\"test/runtests.jl\")","category":"page"},{"location":"dev_guide/tests/","page":"Running Tests","title":"Running Tests","text":"Change logging level(s):","category":"page"},{"location":"dev_guide/tests/","page":"Running Tests","title":"Running Tests","text":"julia> IS.make_logging_config_file(\"logging_config.toml\")\njulia> ENV[\"SIIP_LOGGING_CONFIG\"] = \"logging_config.toml\"\n# Edit the file to suit your preferences.\njulia> include(\"test/runtests.jl\")","category":"page"},{"location":"dev_guide/tests/","page":"Running Tests","title":"Running Tests","text":"Note that you can filter out noisy log groups in this file.","category":"page"},{"location":"dev_guide/tests/","page":"Running Tests","title":"Running Tests","text":"The unit test module appends a summary of all log message counts to the log file.  If a message is logged too frequently then consider tagging that message with maxlog=X to suppress it.","category":"page"}]
}
